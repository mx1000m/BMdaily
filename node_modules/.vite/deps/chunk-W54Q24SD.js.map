{
  "version": 3,
  "sources": ["../../viem/accounts/toAccount.ts", "../../viem/experimental/erc7821/errors.ts", "../../viem/experimental/erc7821/utils/getExecuteError.ts", "../../viem/experimental/erc7821/constants.ts", "../../viem/experimental/erc7821/actions/supportsExecutionMode.ts"],
  "sourcesContent": ["// TODO(v3): Rename to `toLocalAccount` + add `source` property to define source (privateKey, mnemonic, hdKey, etc).\n\nimport type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../errors/address.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport {\n  type IsAddressErrorType,\n  isAddress,\n} from '../utils/address/isAddress.js'\nimport type {\n  AccountSource,\n  CustomSource,\n  JsonRpcAccount,\n  LocalAccount,\n} from './types.js'\n\ntype GetAccountReturnType<accountSource extends AccountSource> =\n  | (accountSource extends Address ? JsonRpcAccount : never)\n  | (accountSource extends CustomSource ? LocalAccount : never)\n\nexport type ToAccountErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/**\n * @description Creates an Account from a custom signing implementation.\n *\n * @returns A Local Account.\n */\nexport function toAccount<accountSource extends AccountSource>(\n  source: accountSource,\n): GetAccountReturnType<accountSource> {\n  if (typeof source === 'string') {\n    if (!isAddress(source, { strict: false }))\n      throw new InvalidAddressError({ address: source })\n    return {\n      address: source,\n      type: 'json-rpc',\n    } as GetAccountReturnType<accountSource>\n  }\n\n  if (!isAddress(source.address, { strict: false }))\n    throw new InvalidAddressError({ address: source.address })\n  return {\n    address: source.address,\n    nonceManager: source.nonceManager,\n    sign: source.sign,\n    signAuthorization: source.signAuthorization,\n    signMessage: source.signMessage,\n    signTransaction: source.signTransaction,\n    signTypedData: source.signTypedData,\n    source: 'custom',\n    type: 'local',\n  } as GetAccountReturnType<accountSource>\n}\n", "import { BaseError } from '../../errors/base.js'\n\nexport type ExecuteUnsupportedErrorType = ExecuteUnsupportedError & {\n  name: 'ExecuteUnsupportedError'\n}\nexport class ExecuteUnsupportedError extends BaseError {\n  constructor() {\n    super('ERC-7821 execution is not supported.', {\n      name: 'ExecuteUnsupportedError',\n    })\n  }\n}\n\nexport type FunctionSelectorNotRecognizedErrorType =\n  FunctionSelectorNotRecognizedError & {\n    name: 'FunctionSelectorNotRecognizedError'\n  }\nexport class FunctionSelectorNotRecognizedError extends BaseError {\n  constructor() {\n    super('Function is not recognized.', {\n      metaMessages: [\n        'This could be due to any of the following:',\n        '  - The contract does not have the function,',\n        '  - The address is not a contract.',\n      ],\n      name: 'FunctionSelectorNotRecognizedError',\n    })\n  }\n}\n", "import type { Abi, Narrow } from 'abitype'\nimport * as AbiError from 'ox/AbiError'\n\nimport type { BaseError } from '../../../errors/base.js'\nimport type { Call, Calls } from '../../../types/calls.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { decodeErrorResult } from '../../../utils/abi/decodeErrorResult.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../../utils/errors/getContractError.js'\nimport {\n  FunctionSelectorNotRecognizedError,\n  type FunctionSelectorNotRecognizedErrorType,\n} from '../errors.js'\n\nexport type GetExecuteErrorParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Calls to execute. */\n  calls: Calls<Narrow<calls>>\n}\n\nexport type GetExecuteErrorReturnType =\n  | FunctionSelectorNotRecognizedErrorType\n  | GetContractErrorReturnType\n\nexport function getExecuteError<const calls extends readonly unknown[]>(\n  e: BaseError,\n  parameters: GetExecuteErrorParameters<calls>,\n): GetExecuteErrorReturnType {\n  const error = e.walk((e) => 'data' in (e as Error)) as\n    | (BaseError & { data?: Hex | undefined })\n    | undefined\n\n  if (!error?.data) return e as never\n  if (\n    error.data ===\n    AbiError.getSelector(AbiError.from('error FnSelectorNotRecognized()'))\n  )\n    return new FunctionSelectorNotRecognizedError() as never\n\n  let matched: Call | null = null\n  for (const c of parameters.calls) {\n    const call = c as Call\n    if (!call.abi) continue\n    try {\n      const matches = Boolean(\n        decodeErrorResult({\n          abi: call.abi,\n          data: error.data!,\n        }),\n      )\n      if (!matches) continue\n      matched = call\n    } catch {}\n  }\n  if (matched)\n    return getContractError(error as BaseError, {\n      abi: matched.abi as Abi,\n      address: matched.to,\n      args: matched.args,\n      functionName: matched.functionName,\n    })\n\n  return e as never\n}\n", "export const abi = [\n  {\n    type: 'fallback',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'receive',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'execute',\n    inputs: [\n      {\n        name: 'mode',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n      {\n        name: 'executionData',\n        type: 'bytes',\n        internalType: 'bytes',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'supportsExecutionMode',\n    inputs: [\n      {\n        name: 'mode',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: 'result',\n        type: 'bool',\n        internalType: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'error',\n    name: 'FnSelectorNotRecognized',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'UnsupportedExecutionMode',\n    inputs: [],\n  },\n] as const\n\nexport const executionMode = {\n  default: '0x0100000000000000000000000000000000000000000000000000000000000000',\n  opData: '0x0100000000007821000100000000000000000000000000000000000000000000',\n  batchOfBatches:\n    '0x0100000000007821000200000000000000000000000000000000000000000000',\n} as const\n", "import type { Address } from '../../../accounts/index.js'\nimport { readContract } from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { withCache } from '../../../utils/promise/withCache.js'\nimport { abi, executionMode } from '../constants.js'\n\nexport type SupportsExecutionModeParameters = {\n  address: Address\n  mode?: 'default' | 'opData' | 'batchOfBatches' | Hex\n}\n\nexport type SupportsExecutionModeReturnType = boolean\n\nexport type SupportsExecutionModeErrorType = ErrorType\n\nconst toSerializedMode = {\n  default: executionMode.default,\n  opData: executionMode.opData,\n  batchOfBatches: executionMode.batchOfBatches,\n} as const\n\n/**\n * Checks if the contract supports the ERC-7821 execution mode.\n *\n * @example\n * ```ts\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { supportsExecutionMode } from 'viem/experimental/erc7821'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const supported = await supportsExecutionMode(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link SupportsExecutionModeParameters}\n * @returns If the execution mode is supported. {@link SupportsExecutionModeReturnType}\n */\nexport async function supportsExecutionMode<\n  chain extends Chain | undefined = Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: SupportsExecutionModeParameters,\n): Promise<SupportsExecutionModeReturnType> {\n  const { address, mode: m = 'default' } = parameters\n  const mode = m.startsWith('0x') ? m : (toSerializedMode as any)[m]\n  try {\n    return await withCache(\n      () =>\n        readContract(client, {\n          abi,\n          address,\n          functionName: 'supportsExecutionMode',\n          args: [mode],\n        }),\n      {\n        cacheKey: `supportsExecutionMode.${address}.${mode}`,\n      },\n    )\n  } catch {\n    return false\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;AAkCM,SAAU,UACd,QAAqB;AAErB,MAAI,OAAO,WAAW,UAAU;AAC9B,QAAI,CAAC,UAAU,QAAQ,EAAE,QAAQ,MAAK,CAAE;AACtC,YAAM,IAAI,oBAAoB,EAAE,SAAS,OAAM,CAAE;AACnD,WAAO;MACL,SAAS;MACT,MAAM;;EAEV;AAEA,MAAI,CAAC,UAAU,OAAO,SAAS,EAAE,QAAQ,MAAK,CAAE;AAC9C,UAAM,IAAI,oBAAoB,EAAE,SAAS,OAAO,QAAO,CAAE;AAC3D,SAAO;IACL,SAAS,OAAO;IAChB,cAAc,OAAO;IACrB,MAAM,OAAO;IACb,mBAAmB,OAAO;IAC1B,aAAa,OAAO;IACpB,iBAAiB,OAAO;IACxB,eAAe,OAAO;IACtB,QAAQ;IACR,MAAM;;AAEV;;;AC1CM,IAAO,qCAAP,cAAkD,UAAS;EAC/D,cAAA;AACE,UAAM,+BAA+B;MACnC,cAAc;QACZ;QACA;QACA;;MAEF,MAAM;KACP;EACH;;;;ACAI,SAAU,gBACd,GACA,YAA4C;AAE5C,QAAM,QAAQ,EAAE,KAAK,CAACA,OAAM,UAAWA,EAAW;AAIlD,MAAI,EAAC,+BAAO;AAAM,WAAO;AACzB,MACE,MAAM,SACG,YAAqB,KAAK,iCAAiC,CAAC;AAErE,WAAO,IAAI,mCAAkC;AAE/C,MAAI,UAAuB;AAC3B,aAAW,KAAK,WAAW,OAAO;AAChC,UAAM,OAAO;AACb,QAAI,CAAC,KAAK;AAAK;AACf,QAAI;AACF,YAAM,UAAU,QACd,kBAAkB;QAChB,KAAK,KAAK;QACV,MAAM,MAAM;OACb,CAAC;AAEJ,UAAI,CAAC;AAAS;AACd,gBAAU;IACZ,QAAQ;IAAC;EACX;AACA,MAAI;AACF,WAAO,iBAAiB,OAAoB;MAC1C,KAAK,QAAQ;MACb,SAAS,QAAQ;MACjB,MAAM,QAAQ;MACd,cAAc,QAAQ;KACvB;AAEH,SAAO;AACT;;;ACRO,IAAM,gBAAgB;EAC3B,SAAS;EACT,QAAQ;EACR,gBACE;;;;AC3CJ,IAAM,mBAAmB;EACvB,SAAS,cAAc;EACvB,QAAQ,cAAc;EACtB,gBAAgB,cAAc;;",
  "names": ["e"]
}
