import {
  require_dijkstra
} from "./chunk-G4ANPXC6.js";
import {
  entryPoint06Address
} from "./chunk-KJY3VXYG.js";
import {
  Address,
  Avatar,
  DEFAULT_QUERY_OPTIONS,
  EthBalance,
  FALLBACK_DEFAULT_MAX_SLIPPAGE,
  Identity,
  IdentityProvider,
  LOW_LIQUIDITY_ERROR_CODE,
  Name,
  PERMIT2_CONTRACT_ADDRESS,
  SwapMessage,
  TOO_MANY_REQUESTS_ERROR_CODE,
  UNIVERSALROUTER_CONTRACT_ADDRESS,
  UNSUPPORTED_AMOUNT_REFERENCE_ERROR_CODE,
  USER_REJECTED_ERROR_CODE,
  copyToClipboard,
  defaultAvatarSVG,
  findComponent,
  getAddress,
  getName,
  getRoundedAmount,
  getSlicedAddress,
  getSwapErrorCode,
  isBasename,
  useGetETHBalance,
  useName,
  zIndex
} from "./chunk-NKSYB7BF.js";
import "./chunk-CKWBFEDU.js";
import "./chunk-JHQIELAH.js";
import {
  CloseSvg,
  ErrorSvg,
  GENERIC_ERROR_MESSAGE,
  Spinner,
  SuccessSvg,
  Toast,
  Transaction,
  TransactionButton,
  TransactionStatus,
  TransactionStatusAction,
  TransactionStatusLabel,
  getChainExplorer,
  isUserRejectedRequestError,
  normalizeStatus,
  normalizeTransactionId,
  useAnalytics,
  useCapabilitiesSafe,
  useIsMounted,
  useTransactionContext
} from "./chunk-KRBD3JGL.js";
import "./chunk-TMW3BKOM.js";
import {
  background,
  border,
  cn,
  color,
  icon,
  pressable,
  text,
  usePreferredColorScheme,
  useTheme,
  useValue
} from "./chunk-JTJHCETJ.js";
import {
  baseAccount,
  coinbaseWallet,
  metaMask
} from "./chunk-QARRE4OG.js";
import "./chunk-7AO4FBFE.js";
import "./chunk-FR7KSM5Q.js";
import "./chunk-ANJCMEYS.js";
import "./chunk-53EOX26Q.js";
import {
  CONTEXT_HEADER,
  Capabilities,
  FundEvent,
  JSON_HEADERS,
  JSON_RPC_VERSION,
  POST_METHOD,
  RequestContext,
  SwapEvent,
  WalletEvent,
  WalletOption,
  clientMetaManager,
  version
} from "./chunk-2YAJQTYP.js";
import "./chunk-T6DGKBO6.js";
import "./chunk-PGZVUQA3.js";
import "./chunk-64SD37WF.js";
import "./chunk-W54Q24SD.js";
import {
  ONCHAIN_KIT_CONFIG,
  useOnchainKit
} from "./chunk-D3A4POTL.js";
import "./chunk-PD5WAEH4.js";
import {
  useAccount,
  useCallsStatus,
  useChainId,
  useConfig,
  useConnect,
  useDisconnect,
  useReadContract,
  useSendCalls,
  useSendTransaction,
  useSwitchChain
} from "./chunk-5WJVUKOY.js";
import {
  injected,
  waitForTransactionReceipt
} from "./chunk-XNSTLHSV.js";
import "./chunk-EDDRWZDP.js";
import "./chunk-RFGAV5EN.js";
import "./chunk-LWLUVSGB.js";
import {
  parseUnits
} from "./chunk-TE2KEVK5.js";
import {
  useQuery
} from "./chunk-SYWZVBRI.js";
import {
  base,
  baseSepolia,
  mainnet
} from "./chunk-73ADTDOL.js";
import "./chunk-IFKI425K.js";
import "./chunk-4BVTQS2C.js";
import "./chunk-2YXMKDAC.js";
import {
  encodeFunctionData,
  erc20Abi
} from "./chunk-SBWNL4JE.js";
import {
  checksumAddress,
  decodeAbiParameters,
  formatUnits,
  isAddress,
  parseAbi
} from "./chunk-IR6OLA2F.js";
import "./chunk-NSDO7JQ5.js";
import "./chunk-CVLLH7Z4.js";
import {
  require_jsx_runtime
} from "./chunk-TLG7CTPL.js";
import {
  require_react_dom
} from "./chunk-Z2GUPSCO.js";
import {
  require_react
} from "./chunk-VT65UQWK.js";
import {
  __commonJS,
  __toESM
} from "./chunk-ONY6HBPH.js";

// node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
var require_react_dom_server_legacy_browser_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React2 = require_react();
        var ReactVersion = "18.3.1";
        var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function scheduleWork(callback) {
          callback();
        }
        function beginWriting(destination) {
        }
        function writeChunk(destination, chunk) {
          writeChunkAndReturn(destination, chunk);
        }
        function writeChunkAndReturn(destination, chunk) {
          return destination.push(chunk);
        }
        function completeWriting(destination) {
        }
        function close(destination) {
          destination.push(null);
        }
        function stringToChunk(content) {
          return content;
        }
        function stringToPrecomputedChunk(content) {
          return content;
        }
        function closeWithError(destination, error2) {
          destination.destroy(error2);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error(
              "Unsupported style property %s. Did you mean %s?",
              name,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name.replace(msPattern, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          {
            checkHtmlStringCoercion(string);
          }
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape = "&quot;";
                break;
              case 38:
                escape = "&amp;";
                break;
              case 39:
                escape = "&#x27;";
                break;
              case 60:
                escape = "&lt;";
                break;
              case 62:
                escape = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text2) {
          if (typeof text2 === "boolean" || typeof text2 === "number") {
            return "" + text2;
          }
          return escapeHtml(text2);
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern$1 = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
        }
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        var startInlineScript = stringToPrecomputedChunk("<script>");
        var endInlineScript = stringToPrecomputedChunk("<\/script>");
        var startScriptSrc = stringToPrecomputedChunk('<script src="');
        var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
        var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
        function escapeBootstrapScriptContent(scriptText) {
          {
            checkHtmlStringCoercion(scriptText);
          }
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        var scriptRegex = /(<\/|<)(s)(cript)/gi;
        var scriptReplacer = function(match, prefix2, s, suffix) {
          return "" + prefix2 + (s === "s" ? "\\u0073" : "\\u0053") + suffix;
        };
        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
          var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
          var bootstrapChunks = [];
          if (bootstrapScriptContent !== void 0) {
            bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
          }
          if (bootstrapScripts !== void 0) {
            for (var i = 0; i < bootstrapScripts.length; i++) {
              bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
            }
          }
          if (bootstrapModules !== void 0) {
            for (var _i = 0; _i < bootstrapModules.length; _i++) {
              bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
            }
          }
          return {
            bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
            boundaryPrefix: idPrefix + "B:",
            idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
          };
        }
        var ROOT_HTML_MODE = 0;
        var HTML_MODE = 1;
        var SVG_MODE = 2;
        var MATHML_MODE = 3;
        var HTML_TABLE_MODE = 4;
        var HTML_TABLE_BODY_MODE = 5;
        var HTML_TABLE_ROW_MODE = 6;
        var HTML_COLGROUP_MODE = 7;
        function createFormatContext(insertionMode, selectedValue) {
          return {
            insertionMode,
            selectedValue
          };
        }
        function getChildFormatContext(parentContext, type, props) {
          switch (type) {
            case "select":
              return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
            case "svg":
              return createFormatContext(SVG_MODE, null);
            case "math":
              return createFormatContext(MATHML_MODE, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case "colgroup":
              return createFormatContext(HTML_COLGROUP_MODE, null);
            case "tr":
              return createFormatContext(HTML_TABLE_ROW_MODE, null);
          }
          if (parentContext.insertionMode >= HTML_TABLE_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          if (parentContext.insertionMode === ROOT_HTML_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          return parentContext;
        }
        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
        function assignSuspenseBoundaryID(responseState) {
          var generatedID = responseState.nextSuspenseID++;
          return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
        }
        function makeId(responseState, treeId, localId) {
          var idPrefix = responseState.idPrefix;
          var id = ":" + idPrefix + "R" + treeId;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          return id + ":";
        }
        function encodeHTMLTextNode(text2) {
          return escapeTextForBrowser(text2);
        }
        var textSeparator = stringToPrecomputedChunk("<!-- -->");
        function pushTextInstance(target, text2, responseState, textEmbedded) {
          if (text2 === "") {
            return textEmbedded;
          }
          if (textEmbedded) {
            target.push(textSeparator);
          }
          target.push(stringToChunk(encodeHTMLTextNode(text2)));
          return true;
        }
        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
          if (lastPushedText && textEmbedded) {
            target.push(textSeparator);
          }
        }
        var styleNameCache = /* @__PURE__ */ new Map();
        function processStyleName(styleName) {
          var chunk = styleNameCache.get(styleName);
          if (chunk !== void 0) {
            return chunk;
          }
          var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
          styleNameCache.set(styleName, result);
          return result;
        }
        var styleAttributeStart = stringToPrecomputedChunk(' style="');
        var styleAssign = stringToPrecomputedChunk(":");
        var styleSeparator = stringToPrecomputedChunk(";");
        function pushStyle(target, responseState, style) {
          if (typeof style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
          var isFirst = true;
          for (var styleName in style) {
            if (!hasOwnProperty.call(style, styleName)) {
              continue;
            }
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
              continue;
            }
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty = styleName.indexOf("--") === 0;
            if (isCustomProperty) {
              nameChunk = stringToChunk(escapeTextForBrowser(styleName));
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            } else {
              {
                warnValidStyle$1(styleName, styleValue);
              }
              nameChunk = processStyleName(styleName);
              if (typeof styleValue === "number") {
                if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                  valueChunk = stringToChunk(styleValue + "px");
                } else {
                  valueChunk = stringToChunk("" + styleValue);
                }
              } else {
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              }
            }
            if (isFirst) {
              isFirst = false;
              target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else {
              target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
          if (!isFirst) {
            target.push(attributeEnd);
          }
        }
        var attributeSeparator = stringToPrecomputedChunk(" ");
        var attributeAssign = stringToPrecomputedChunk('="');
        var attributeEnd = stringToPrecomputedChunk('"');
        var attributeEmptyString = stringToPrecomputedChunk('=""');
        function pushAttribute(target, responseState, name, value) {
          switch (name) {
            case "style": {
              pushStyle(target, responseState, value);
              return;
            }
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              return;
          }
          if (
            // shouldIgnoreAttribute
            // We have already filtered out null/undefined and reserved words.
            name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")
          ) {
            return;
          }
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                if (!propertyInfo.acceptsBooleans) {
                  return;
                }
              }
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName);
            switch (propertyInfo.type) {
              case BOOLEAN:
                if (value) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                }
                return;
              case OVERLOADED_BOOLEAN:
                if (value === true) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                } else if (value === false) ;
                else {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                return;
              case NUMERIC:
                if (!isNaN(value)) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              case POSITIVE_NUMERIC:
                if (!isNaN(value) && value >= 1) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              default:
                if (propertyInfo.sanitizeURL) {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  value = "" + value;
                  sanitizeURL(value);
                }
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix2 = name.toLowerCase().slice(0, 5);
                if (prefix2 !== "data-" && prefix2 !== "aria-") {
                  return;
                }
              }
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        }
        var endOfStartTag = stringToPrecomputedChunk(">");
        var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
        function pushInnerHTML(target, innerHTML, children) {
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnInvalidOptionInnerHTML = false;
        var didWarnSelectedSetOnOption = false;
        function checkSelectProp(props, propName) {
          {
            var value = props[propName];
            if (value != null) {
              var array = isArray(value);
              if (props.multiple && !array) {
                error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
              } else if (!props.multiple && array) {
                error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
              }
            }
          }
        }
        function pushStartSelect(target, props, responseState) {
          {
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
              error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultSelectValue = true;
            }
          }
          target.push(startChunkForTag("select"));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function flattenOptionChildren(children) {
          var content = "";
          React2.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
              }
            }
          });
          return content;
        }
        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
        function pushStartOption(target, props, responseState, formatContext) {
          var selectedValue = formatContext.selectedValue;
          target.push(startChunkForTag("option"));
          var children = null;
          var value = null;
          var selected = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "selected":
                  selected = propValue;
                  {
                    if (!didWarnSelectedSetOnOption) {
                      error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                      didWarnSelectedSetOnOption = true;
                    }
                  }
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "value":
                  value = propValue;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (selectedValue != null) {
            var stringValue;
            if (value !== null) {
              {
                checkAttributeStringCoercion(value, "value");
              }
              stringValue = "" + value;
            } else {
              {
                if (innerHTML !== null) {
                  if (!didWarnInvalidOptionInnerHTML) {
                    didWarnInvalidOptionInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              stringValue = flattenOptionChildren(children);
            }
            if (isArray(selectedValue)) {
              for (var i = 0; i < selectedValue.length; i++) {
                {
                  checkAttributeStringCoercion(selectedValue[i], "value");
                }
                var v = "" + selectedValue[i];
                if (v === stringValue) {
                  target.push(selectedMarkerAttribute);
                  break;
                }
              }
            } else {
              {
                checkAttributeStringCoercion(selectedValue, "select.value");
              }
              if ("" + selectedValue === stringValue) {
                target.push(selectedMarkerAttribute);
              }
            }
          } else if (selected) {
            target.push(selectedMarkerAttribute);
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function pushInput(target, props, responseState) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
              error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
              error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultInputValue = true;
            }
          }
          target.push(startChunkForTag("input"));
          var value = null;
          var defaultValue = null;
          var checked = null;
          var defaultChecked = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  defaultChecked = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "checked":
                  checked = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (checked !== null) {
            pushAttribute(target, responseState, "checked", checked);
          } else if (defaultChecked !== null) {
            pushAttribute(target, responseState, "checked", defaultChecked);
          }
          if (value !== null) {
            pushAttribute(target, responseState, "value", value);
          } else if (defaultValue !== null) {
            pushAttribute(target, responseState, "value", defaultValue);
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartTextArea(target, props, responseState) {
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
              error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultTextareaValue = true;
            }
          }
          target.push(startChunkForTag("textarea"));
          var value = null;
          var defaultValue = null;
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (value === null && defaultValue !== null) {
            value = defaultValue;
          }
          target.push(endOfStartTag);
          if (children != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            if (value != null) {
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
            if (isArray(children)) {
              if (children.length > 1) {
                throw new Error("<textarea> can only have at most one child.");
              }
              {
                checkHtmlStringCoercion(children[0]);
              }
              value = "" + children[0];
            }
            {
              checkHtmlStringCoercion(children);
            }
            value = "" + children;
          }
          if (typeof value === "string" && value[0] === "\n") {
            target.push(leadingNewline);
          }
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            target.push(stringToChunk(encodeHTMLTextNode("" + value)));
          }
          return null;
        }
        function pushSelfClosing(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartMenuItem(target, props, responseState) {
          target.push(startChunkForTag("menuitem"));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          return null;
        }
        function pushStartTitle(target, props, responseState) {
          target.push(startChunkForTag("title"));
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          {
            var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
            if (Array.isArray(children) && children.length > 1) {
              error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && child.$$typeof != null) {
              error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && typeof child !== "string" && typeof child !== "number") {
              error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            }
          }
          return children;
        }
        function pushStartGenericElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          if (typeof children === "string") {
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
          }
          return children;
        }
        function pushStartCustomElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "style":
                  pushStyle(target, responseState, propValue);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                    target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                  }
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        var leadingNewline = stringToPrecomputedChunk("\n");
        function pushStartPreformattedElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                target.push(leadingNewline, stringToChunk(html));
              } else {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          if (typeof children === "string" && children[0] === "\n") {
            target.push(leadingNewline);
          }
          return children;
        }
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = /* @__PURE__ */ new Map();
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (tagStartChunk === void 0) {
            if (!VALID_TAG_REGEX.test(tag)) {
              throw new Error("Invalid tag: " + tag);
            }
            tagStartChunk = stringToPrecomputedChunk("<" + tag);
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
        function pushStartInstance(target, type, props, responseState, formatContext) {
          {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
            if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
              if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
          }
          switch (type) {
            case "select":
              return pushStartSelect(target, props, responseState);
            case "option":
              return pushStartOption(target, props, responseState, formatContext);
            case "textarea":
              return pushStartTextArea(target, props, responseState);
            case "input":
              return pushInput(target, props, responseState);
            case "menuitem":
              return pushStartMenuItem(target, props, responseState);
            case "title":
              return pushStartTitle(target, props, responseState);
            case "listing":
            case "pre": {
              return pushStartPreformattedElement(target, props, type, responseState);
            }
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              return pushSelfClosing(target, props, type, responseState);
            }
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph": {
              return pushStartGenericElement(target, props, type, responseState);
            }
            case "html": {
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                target.push(DOCTYPE);
              }
              return pushStartGenericElement(target, props, type, responseState);
            }
            default: {
              if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                return pushStartGenericElement(target, props, type, responseState);
              } else {
                return pushStartCustomElement(target, props, type, responseState);
              }
            }
          }
        }
        var endTag1 = stringToPrecomputedChunk("</");
        var endTag2 = stringToPrecomputedChunk(">");
        function pushEndInstance(target, type, props) {
          switch (type) {
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              break;
            }
            default: {
              target.push(endTag1, stringToChunk(type), endTag2);
            }
          }
        }
        function writeCompletedRoot(destination, responseState) {
          var bootstrapChunks = responseState.bootstrapChunks;
          var i = 0;
          for (; i < bootstrapChunks.length - 1; i++) {
            writeChunk(destination, bootstrapChunks[i]);
          }
          if (i < bootstrapChunks.length) {
            return writeChunkAndReturn(destination, bootstrapChunks[i]);
          }
          return true;
        }
        var placeholder1 = stringToPrecomputedChunk('<template id="');
        var placeholder2 = stringToPrecomputedChunk('"></template>');
        function writePlaceholder(destination, responseState, id) {
          writeChunk(destination, placeholder1);
          writeChunk(destination, responseState.placeholderPrefix);
          var formattedID = stringToChunk(id.toString(16));
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, placeholder2);
        }
        var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
        var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
        function writeStartCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        }
        function writeStartPendingSuspenseBoundary(destination, responseState, id) {
          writeChunk(destination, startPendingSuspenseBoundary1);
          if (id === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, id);
          return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
        }
        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
          var result;
          result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          {
            if (errorMesssage) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
          }
          result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          return result;
        }
        function writeEndCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndPendingSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
        var startSegmentHTML2 = stringToPrecomputedChunk('">');
        var endSegmentHTML = stringToPrecomputedChunk("</div>");
        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
        var startSegmentSVG2 = stringToPrecomputedChunk('">');
        var endSegmentSVG = stringToPrecomputedChunk("</svg>");
        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
        var startSegmentMathML2 = stringToPrecomputedChunk('">');
        var endSegmentMathML = stringToPrecomputedChunk("</math>");
        var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
        var startSegmentTable2 = stringToPrecomputedChunk('">');
        var endSegmentTable = stringToPrecomputedChunk("</table>");
        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
        var startSegmentTableBody2 = stringToPrecomputedChunk('">');
        var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
        var startSegmentTableRow2 = stringToPrecomputedChunk('">');
        var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
        var startSegmentColGroup2 = stringToPrecomputedChunk('">');
        var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
        function writeStartSegment(destination, responseState, formatContext, id) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              writeChunk(destination, startSegmentHTML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentHTML2);
            }
            case SVG_MODE: {
              writeChunk(destination, startSegmentSVG);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentSVG2);
            }
            case MATHML_MODE: {
              writeChunk(destination, startSegmentMathML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentMathML2);
            }
            case HTML_TABLE_MODE: {
              writeChunk(destination, startSegmentTable);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTable2);
            }
            case HTML_TABLE_BODY_MODE: {
              writeChunk(destination, startSegmentTableBody);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableBody2);
            }
            case HTML_TABLE_ROW_MODE: {
              writeChunk(destination, startSegmentTableRow);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableRow2);
            }
            case HTML_COLGROUP_MODE: {
              writeChunk(destination, startSegmentColGroup);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentColGroup2);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              return writeChunkAndReturn(destination, endSegmentHTML);
            }
            case SVG_MODE: {
              return writeChunkAndReturn(destination, endSegmentSVG);
            }
            case MATHML_MODE: {
              return writeChunkAndReturn(destination, endSegmentMathML);
            }
            case HTML_TABLE_MODE: {
              return writeChunkAndReturn(destination, endSegmentTable);
            }
            case HTML_TABLE_BODY_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableBody);
            }
            case HTML_TABLE_ROW_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableRow);
            }
            case HTML_COLGROUP_MODE: {
              return writeChunkAndReturn(destination, endSegmentColGroup);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
        var completeSegmentScript2 = stringToPrecomputedChunk('","');
        var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteSegmentFunction) {
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
          } else {
            writeChunk(destination, completeSegmentScript1Partial);
          }
          writeChunk(destination, responseState.segmentPrefix);
          var formattedID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, formattedID);
          writeChunk(destination, completeSegmentScript2);
          writeChunk(destination, responseState.placeholderPrefix);
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, completeSegmentScript3);
        }
        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
        var completeBoundaryScript2 = stringToPrecomputedChunk('","');
        var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteBoundaryFunction) {
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
          } else {
            writeChunk(destination, completeBoundaryScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          var formattedContentID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, boundaryID);
          writeChunk(destination, completeBoundaryScript2);
          writeChunk(destination, responseState.segmentPrefix);
          writeChunk(destination, formattedContentID);
          return writeChunkAndReturn(destination, completeBoundaryScript3);
        }
        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
        var clientRenderScript1A = stringToPrecomputedChunk('"');
        var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentClientRenderFunction) {
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
          } else {
            writeChunk(destination, clientRenderScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, boundaryID);
          writeChunk(destination, clientRenderScript1A);
          if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
          }
          if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
          }
          return writeChunkAndReturn(destination, clientRenderScript2);
        }
        var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
        function escapeJSStringsForInstructionScripts(input) {
          var escaped = JSON.stringify(input);
          return escaped.replace(regexForJSStringsInScripts, function(match) {
            switch (match) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default: {
                throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
              }
            }
          });
        }
        function createResponseState$1(generateStaticMarkup, identifierPrefix) {
          var responseState = createResponseState(identifierPrefix, void 0);
          return {
            // Keep this in sync with ReactDOMServerFormatConfig
            bootstrapChunks: responseState.bootstrapChunks,
            startInlineScript: responseState.startInlineScript,
            placeholderPrefix: responseState.placeholderPrefix,
            segmentPrefix: responseState.segmentPrefix,
            boundaryPrefix: responseState.boundaryPrefix,
            idPrefix: responseState.idPrefix,
            nextSuspenseID: responseState.nextSuspenseID,
            sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
            sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
            sentClientRenderFunction: responseState.sentClientRenderFunction,
            // This is an extra field for the legacy renderer
            generateStaticMarkup
          };
        }
        function createRootFormatContext() {
          return {
            insertionMode: HTML_MODE,
            // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
            selectedValue: null
          };
        }
        function pushTextInstance$1(target, text2, responseState, textEmbedded) {
          if (responseState.generateStaticMarkup) {
            target.push(stringToChunk(escapeTextForBrowser(text2)));
            return false;
          } else {
            return pushTextInstance(target, text2, responseState, textEmbedded);
          }
        }
        function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
          if (responseState.generateStaticMarkup) {
            return;
          } else {
            return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
          }
        }
        function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeStartCompletedSuspenseBoundary(destination);
        }
        function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
        }
        function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeEndCompletedSuspenseBoundary(destination);
        }
        function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
          if (responseState.generateStaticMarkup) {
            return true;
          }
          return writeEndClientRenderedSuspenseBoundary(destination);
        }
        var assign = Object.assign;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        function getMaskedContext(type, unmaskedContext) {
          {
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var context = {};
            for (var key in contextTypes) {
              context[key] = unmaskedContext[key];
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(contextTypes, context, "context", name);
            }
            return context;
          }
        }
        function processChildContext(instance, type, parentContext, childContextTypes) {
          {
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign({}, parentContext, childContext);
          }
        }
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev) {
          {
            prev.context._currentValue2 = prev.parentValue;
          }
        }
        function pushNode(next) {
          {
            next.context._currentValue2 = next.value;
          }
        }
        function popToNearestCommonAncestor(prev, next) {
          if (prev === next) ;
          else {
            popNode(prev);
            var parentPrev = prev.parent;
            var parentNext = next.parent;
            if (parentPrev === null) {
              if (parentNext !== null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
            } else {
              if (parentNext === null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
              popToNearestCommonAncestor(parentPrev, parentNext);
            }
            pushNode(next);
          }
        }
        function popAllPrevious(prev) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev !== null) {
            popAllPrevious(parentPrev);
          }
        }
        function pushAllNext(next) {
          var parentNext = next.parent;
          if (parentNext !== null) {
            pushAllNext(parentNext);
          }
          pushNode(next);
        }
        function popPreviousToCommonLevel(prev, next) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (parentPrev.depth === next.depth) {
            popToNearestCommonAncestor(parentPrev, next);
          } else {
            popPreviousToCommonLevel(parentPrev, next);
          }
        }
        function popNextToCommonLevel(prev, next) {
          var parentNext = next.parent;
          if (parentNext === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (prev.depth === parentNext.depth) {
            popToNearestCommonAncestor(prev, parentNext);
          } else {
            popNextToCommonLevel(prev, parentNext);
          }
          pushNode(next);
        }
        function switchContext(newSnapshot) {
          var prev = currentActiveSnapshot;
          var next = newSnapshot;
          if (prev !== next) {
            if (prev === null) {
              pushAllNext(next);
            } else if (next === null) {
              popAllPrevious(prev);
            } else if (prev.depth === next.depth) {
              popToNearestCommonAncestor(prev, next);
            } else if (prev.depth > next.depth) {
              popPreviousToCommonLevel(prev, next);
            } else {
              popNextToCommonLevel(prev, next);
            }
            currentActiveSnapshot = next;
          }
        }
        function pushProvider(context, nextValue) {
          var prevValue;
          {
            prevValue = context._currentValue2;
            context._currentValue2 = nextValue;
            {
              if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer2 = rendererSigil;
            }
          }
          var prevNode = currentActiveSnapshot;
          var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context,
            parentValue: prevValue,
            value: nextValue
          };
          currentActiveSnapshot = newNode;
          return newNode;
        }
        function popProvider(context) {
          var prevSnapshot = currentActiveSnapshot;
          if (prevSnapshot === null) {
            throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          }
          {
            if (prevSnapshot.context !== context) {
              error("The parent context is not the expected context. This is probably a bug in React.");
            }
          }
          {
            var _value = prevSnapshot.parentValue;
            if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
              prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
            } else {
              prevSnapshot.context._currentValue2 = _value;
            }
            {
              if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer2 = rendererSigil;
            }
          }
          return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
          return currentActiveSnapshot;
        }
        function readContext(context) {
          var value = context._currentValue2;
          return value;
        }
        function get(key) {
          return key._reactInternals;
        }
        function set(key, value) {
          key._reactInternals = value;
        }
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key)) {
              didWarnOnInvalidCallback.add(key);
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        var classComponentUpdater = {
          isMounted: function(inst) {
            return false;
          },
          enqueueSetState: function(inst, payload, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "setState");
            } else {
              internals.queue.push(payload);
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var internals = get(inst);
            internals.replace = true;
            internals.queue = [payload];
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "forceUpdate");
            } else {
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          }
        };
        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var newState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
          return newState;
        }
        function constructClassInstance(ctor, props, maskedLegacyContext) {
          var context = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context = readContext(contextType);
          } else {
            context = maskedLegacyContext;
          }
          var instance = new ctor(props, context);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          return instance;
        }
        function checkClassInstance(instance, ctor, newProps) {
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray(_state))) {
              error("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function callComponentWillMount(type, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                  warn(
                    // keep this warning in sync with ReactStrictModeWarning.js
                    "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName
                  );
                  didWarnAboutDeprecatedWillMount[componentName] = true;
                }
              }
            }
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
          if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) {
              inst.state = oldQueue[0];
            } else {
              var nextState = oldReplace ? oldQueue[0] : inst.state;
              var dontMutate = true;
              for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                var partial = oldQueue[i];
                var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                if (partialState != null) {
                  if (dontMutate) {
                    dontMutate = false;
                    nextState = assign({}, nextState, partialState);
                  } else {
                    assign(nextState, partialState);
                  }
                }
              }
              inst.state = nextState;
            }
          } else {
            internalInstance.queue = null;
          }
        }
        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
          {
            checkClassInstance(instance, ctor, newProps);
          }
          var initialState = instance.state !== void 0 ? instance.state : null;
          instance.updater = classComponentUpdater;
          instance.props = newProps;
          instance.state = initialState;
          var internalInstance = {
            queue: [],
            replace: false
          };
          set(instance, internalInstance);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            instance.context = maskedLegacyContext;
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(ctor, instance);
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
          }
        }
        var emptyTreeContext = {
          id: 1,
          overflow: ""
        };
        function getTreeId(context) {
          var overflow = context.overflow;
          var idWithLeadingBit = context.id;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeContext(baseContext, totalChildren, index) {
          var baseIdWithLeadingBit = baseContext.id;
          var baseOverflow = baseContext.overflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index + 1;
          var length = getBitLength(totalChildren) + baseLength;
          if (length > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
              id: 1 << restOfLength | id,
              overflow
            };
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
              id: 1 << length | _id,
              overflow: _overflow
            };
          }
        }
        function getBitLength(number) {
          return 32 - clz32(number);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x) {
          var asUint = x >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var currentlyRenderingTask = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var localIdCounter = 0;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (currentlyRenderingComponent === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
            if (objectIs(nextDeps[i], prevDeps[i])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            throw new Error("Rendered more hooks than during the previous render");
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(task, componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          currentlyRenderingTask = task;
          {
            isInHookUserCodeInDev = false;
          }
          localIdCounter = 0;
        }
        function finishHooks(Component, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          return didRenderIdHook;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          currentlyRenderingTask = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext$1(context) {
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return readContext(context);
        }
        function useContext5(context) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          return readContext(context);
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState17(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(
            basicStateReducer,
            // useReducer has a special case to support lazy useState initializers
            initialState
          );
        }
        function useReducer(reducer, initialArg, init) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue = workInProgressHook.queue;
            var dispatch = queue.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init !== void 0 ? init(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo28(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef16(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect2(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue, action) {
          if (numberOfReRenders >= RE_RENDER_LIMIT) {
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback49(callback, deps) {
          return useMemo28(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          return getServerSnapshot();
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function unsupportedStartTransition() {
          throw new Error("startTransition cannot be called during server rendering.");
        }
        function useTransition() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }
        function useId2() {
          var task = currentlyRenderingTask;
          var treeId = getTreeId(task.treeContext);
          var responseState = currentResponseState;
          if (responseState === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
          }
          var localId = localIdCounter++;
          return makeId(responseState, treeId, localId);
        }
        function noop() {
        }
        var Dispatcher = {
          readContext: readContext$1,
          useContext: useContext5,
          useMemo: useMemo28,
          useReducer,
          useRef: useRef16,
          useState: useState17,
          useInsertionEffect: noop,
          useLayoutEffect: useLayoutEffect2,
          useCallback: useCallback49,
          // useImperativeHandle is not run in the server environment
          useImperativeHandle: noop,
          // Effects are not run in the server environment.
          useEffect: noop,
          // Debugging effect
          useDebugValue: noop,
          useDeferredValue,
          useTransition,
          useId: useId2,
          // Subscriptions are not setup in a server environment.
          useMutableSource,
          useSyncExternalStore
        };
        var currentResponseState = null;
        function setCurrentResponseState(responseState) {
          currentResponseState = responseState;
        }
        function getStackByComponentStackNode(componentStack) {
          try {
            var info = "";
            var node = componentStack;
            do {
              switch (node.tag) {
                case 0:
                  info += describeBuiltInComponentFrame(node.type, null, null);
                  break;
                case 1:
                  info += describeFunctionComponentFrame(node.type, null, null);
                  break;
                case 2:
                  info += describeClassComponentFrame(node.type, null, null);
                  break;
              }
              node = node.parent;
            } while (node);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        var PENDING = 0;
        var COMPLETED = 1;
        var FLUSHED = 2;
        var ABORTED = 3;
        var ERRORED = 4;
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
        function defaultErrorHandler(error2) {
          console["error"](error2);
          return null;
        }
        function noop$1() {
        }
        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
          var pingedTasks = [];
          var abortSet = /* @__PURE__ */ new Set();
          var request = {
            destination: null,
            responseState,
            progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError2 === void 0 ? defaultErrorHandler : onError2,
            onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
            onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
            onShellError: onShellError === void 0 ? noop$1 : onShellError,
            onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
          };
          var rootSegment = createPendingSegment(
            request,
            0,
            null,
            rootFormatContext,
            // Root segments are never embedded in Text on either edge
            false,
            false
          );
          rootSegment.parentFlushed = true;
          var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
          pingedTasks.push(rootTask);
          return request;
        }
        function pingTask(request, task) {
          var pingedTasks = request.pingedTasks;
          pingedTasks.push(task);
          if (pingedTasks.length === 1) {
            scheduleWork(function() {
              return performWork(request);
            });
          }
        }
        function createSuspenseBoundary(request, fallbackAbortableTasks) {
          return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null
          };
        }
        function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
          request.allPendingTasks++;
          if (blockedBoundary === null) {
            request.pendingRootTasks++;
          } else {
            blockedBoundary.pendingTasks++;
          }
          var task = {
            node,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment,
            abortSet,
            legacyContext,
            context,
            treeContext
          };
          {
            task.componentStack = null;
          }
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            id: -1,
            // lazily assigned later
            index,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        var currentTaskInDEV = null;
        function getCurrentStackInDEV() {
          {
            if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
              return "";
            }
            return getStackByComponentStackNode(currentTaskInDEV.componentStack);
          }
        }
        function pushBuiltInComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 0,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushFunctionComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 1,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushClassComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 2,
              parent: task.componentStack,
              type
            };
          }
        }
        function popComponentStackInDEV(task) {
          {
            if (task.componentStack === null) {
              error("Unexpectedly popped too many stack frames. This is a bug in React.");
            } else {
              task.componentStack = task.componentStack.parent;
            }
          }
        }
        var lastBoundaryErrorComponentStackDev = null;
        function captureBoundaryErrorDetailsDev(boundary, error2) {
          {
            var errorMessage;
            if (typeof error2 === "string") {
              errorMessage = error2;
            } else if (error2 && typeof error2.message === "string") {
              errorMessage = error2.message;
            } else {
              errorMessage = String(error2);
            }
            var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
            lastBoundaryErrorComponentStackDev = null;
            boundary.errorMessage = errorMessage;
            boundary.errorComponentStack = errorComponentStack;
          }
        }
        function logRecoverableError(request, error2) {
          var errorDigest = request.onError(error2);
          if (errorDigest != null && typeof errorDigest !== "string") {
            throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
          }
          return errorDigest;
        }
        function fatalError(request, error2) {
          var onShellError = request.onShellError;
          onShellError(error2);
          var onFatalError = request.onFatalError;
          onFatalError(error2);
          if (request.destination !== null) {
            request.status = CLOSED;
            closeWithError(request.destination, error2);
          } else {
            request.status = CLOSING;
            request.fatalError = error2;
          }
        }
        function renderSuspenseBoundary(request, task, props) {
          pushBuiltInComponentStackInDEV(task, "Suspense");
          var parentBoundary = task.blockedBoundary;
          var parentSegment = task.blockedSegment;
          var fallback = props.fallback;
          var content = props.children;
          var fallbackAbortSet = /* @__PURE__ */ new Set();
          var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
          var insertionIndex = parentSegment.chunks.length;
          var boundarySegment = createPendingSegment(
            request,
            insertionIndex,
            newBoundary,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          parentSegment.children.push(boundarySegment);
          parentSegment.lastPushedText = false;
          var contentRootSegment = createPendingSegment(
            request,
            0,
            null,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          contentRootSegment.parentFlushed = true;
          task.blockedBoundary = newBoundary;
          task.blockedSegment = contentRootSegment;
          try {
            renderNode(request, task, content);
            pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
              popComponentStackInDEV(task);
              return;
            }
          } catch (error2) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request, error2);
            {
              captureBoundaryErrorDetailsDev(newBoundary, error2);
            }
          } finally {
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
          }
          var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
          {
            suspendedFallbackTask.componentStack = task.componentStack;
          }
          request.pingedTasks.push(suspendedFallbackTask);
          popComponentStackInDEV(task);
        }
        function renderHostElement(request, task, type, props) {
          pushBuiltInComponentStackInDEV(task, type);
          var segment = task.blockedSegment;
          var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
          segment.lastPushedText = false;
          var prevContext = segment.formatContext;
          segment.formatContext = getChildFormatContext(prevContext, type, props);
          renderNode(request, task, children);
          segment.formatContext = prevContext;
          pushEndInstance(segment.chunks, type);
          segment.lastPushedText = false;
          popComponentStackInDEV(task);
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function renderWithHooks(request, task, Component, props, secondArg) {
          var componentIdentity = {};
          prepareToUseHooks(task, componentIdentity);
          var result = Component(props, secondArg);
          return finishHooks(Component, props, result, secondArg);
        }
        function finishClassComponent(request, task, instance, Component, props) {
          var nextChildren = instance.render();
          {
            if (instance.props !== props) {
              if (!didWarnAboutReassigningProps) {
                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          {
            var childContextTypes = Component.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              var previousContext = task.legacyContext;
              var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
              task.legacyContext = mergedContext;
              renderNodeDestructive(request, task, nextChildren);
              task.legacyContext = previousContext;
              return;
            }
          }
          renderNodeDestructive(request, task, nextChildren);
        }
        function renderClassComponent(request, task, Component, props) {
          pushClassComponentStackInDEV(task, Component);
          var maskedContext = getMaskedContext(Component, task.legacyContext);
          var instance = constructClassInstance(Component, props, maskedContext);
          mountClassInstance(instance, Component, props, maskedContext);
          finishClassComponent(request, task, instance, Component, props);
          popComponentStackInDEV(task);
        }
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutDefaultPropsOnFunctionComponent = {};
        var didWarnAboutGenerators = false;
        var didWarnAboutMaps = false;
        var hasWarnedAboutUsingContextAsConsumer = false;
        function renderIndeterminateComponent(request, task, Component, props) {
          var legacyContext;
          {
            legacyContext = getMaskedContext(Component, task.legacyContext);
          }
          pushFunctionComponentStackInDEV(task, Component);
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
          }
          var value = renderWithHooks(request, task, Component, props, legacyContext);
          var hasId = checkDidRenderIdHook();
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            mountClassInstance(value, Component, props, legacyContext);
            finishClassComponent(request, task, value, Component, props);
          } else {
            {
              validateFunctionComponentInDev(Component);
            }
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
              try {
                renderNodeDestructive(request, task, value);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request, task, value);
            }
          }
          popComponentStackInDEV(task);
        }
        function validateFunctionComponentInDev(Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (Component.defaultProps !== void 0) {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        function renderForwardRef(request, task, type, props, ref) {
          pushFunctionComponentStackInDEV(task, type.render);
          var children = renderWithHooks(request, task, type.render, props, ref);
          var hasId = checkDidRenderIdHook();
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, children);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, children);
          }
          popComponentStackInDEV(task);
        }
        function renderMemo(request, task, type, props, ref) {
          var innerType = type.type;
          var resolvedProps = resolveDefaultProps(innerType, props);
          renderElement(request, task, innerType, resolvedProps, ref);
        }
        function renderContextConsumer(request, task, context, props) {
          {
            if (context._context === void 0) {
              if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context = context._context;
            }
          }
          var render = props.children;
          {
            if (typeof render !== "function") {
              error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          var newValue = readContext(context);
          var newChildren = render(newValue);
          renderNodeDestructive(request, task, newChildren);
        }
        function renderContextProvider(request, task, type, props) {
          var context = type._context;
          var value = props.value;
          var children = props.children;
          var prevSnapshot;
          {
            prevSnapshot = task.context;
          }
          task.context = pushProvider(context, value);
          renderNodeDestructive(request, task, children);
          task.context = popProvider(context);
          {
            if (prevSnapshot !== task.context) {
              error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
            }
          }
        }
        function renderLazyComponent(request, task, lazyComponent, props, ref) {
          pushBuiltInComponentStackInDEV(task, "Lazy");
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component = init(payload);
          var resolvedProps = resolveDefaultProps(Component, props);
          renderElement(request, task, Component, resolvedProps, ref);
          popComponentStackInDEV(task);
        }
        function renderElement(request, task, type, props, ref) {
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              renderClassComponent(request, task, type, props);
              return;
            } else {
              renderIndeterminateComponent(request, task, type, props);
              return;
            }
          }
          if (typeof type === "string") {
            renderHostElement(request, task, type, props);
            return;
          }
          switch (type) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE: {
              renderNodeDestructive(request, task, props.children);
              return;
            }
            case REACT_SUSPENSE_LIST_TYPE: {
              pushBuiltInComponentStackInDEV(task, "SuspenseList");
              renderNodeDestructive(request, task, props.children);
              popComponentStackInDEV(task);
              return;
            }
            case REACT_SCOPE_TYPE: {
              throw new Error("ReactDOMServer does not yet support scope components.");
            }
            case REACT_SUSPENSE_TYPE: {
              {
                renderSuspenseBoundary(request, task, props);
              }
              return;
            }
          }
          if (typeof type === "object" && type !== null) {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE: {
                renderForwardRef(request, task, type, props, ref);
                return;
              }
              case REACT_MEMO_TYPE: {
                renderMemo(request, task, type, props, ref);
                return;
              }
              case REACT_PROVIDER_TYPE: {
                renderContextProvider(request, task, type, props);
                return;
              }
              case REACT_CONTEXT_TYPE: {
                renderContextConsumer(request, task, type, props);
                return;
              }
              case REACT_LAZY_TYPE: {
                renderLazyComponent(request, task, type, props);
                return;
              }
            }
          }
          var info = "";
          {
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
          }
          throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
        }
        function validateIterable(iterable, iteratorFn) {
          {
            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
            iterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (iterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
          }
        }
        function renderNodeDestructive(request, task, node) {
          {
            try {
              return renderNodeDestructiveImpl(request, task, node);
            } catch (x) {
              if (typeof x === "object" && x !== null && typeof x.then === "function") ;
              else {
                lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
              }
              throw x;
            }
          }
        }
        function renderNodeDestructiveImpl(request, task, node) {
          task.node = node;
          if (typeof node === "object" && node !== null) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var element = node;
                var type = element.type;
                var props = element.props;
                var ref = element.ref;
                renderElement(request, task, type, props, ref);
                return;
              }
              case REACT_PORTAL_TYPE:
                throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
              case REACT_LAZY_TYPE: {
                var lazyNode = node;
                var payload = lazyNode._payload;
                var init = lazyNode._init;
                var resolvedNode;
                {
                  try {
                    resolvedNode = init(payload);
                  } catch (x) {
                    if (typeof x === "object" && x !== null && typeof x.then === "function") {
                      pushBuiltInComponentStackInDEV(task, "Lazy");
                    }
                    throw x;
                  }
                }
                renderNodeDestructive(request, task, resolvedNode);
                return;
              }
            }
            if (isArray(node)) {
              renderChildrenArray(request, task, node);
              return;
            }
            var iteratorFn = getIteratorFn(node);
            if (iteratorFn) {
              {
                validateIterable(node, iteratorFn);
              }
              var iterator = iteratorFn.call(node);
              if (iterator) {
                var step = iterator.next();
                if (!step.done) {
                  var children = [];
                  do {
                    children.push(step.value);
                    step = iterator.next();
                  } while (!step.done);
                  renderChildrenArray(request, task, children);
                  return;
                }
                return;
              }
            }
            var childString = Object.prototype.toString.call(node);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          if (typeof node === "string") {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
            return;
          }
          if (typeof node === "number") {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
            return;
          }
          {
            if (typeof node === "function") {
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
        }
        function renderChildrenArray(request, task, children) {
          var totalChildren = children.length;
          for (var i = 0; i < totalChildren; i++) {
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
            try {
              renderNode(request, task, children[i]);
            } finally {
              task.treeContext = prevTreeContext;
            }
          }
        }
        function spawnNewSuspendedTask(request, task, x) {
          var segment = task.blockedSegment;
          var insertionIndex = segment.chunks.length;
          var newSegment = createPendingSegment(
            request,
            insertionIndex,
            null,
            segment.formatContext,
            // Adopt the parent segment's leading text embed
            segment.lastPushedText,
            // Assume we are text embedded at the trailing edge
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
          {
            if (task.componentStack !== null) {
              newTask.componentStack = task.componentStack.parent;
            }
          }
          var ping = newTask.ping;
          x.then(ping, ping);
        }
        function renderNode(request, task, node) {
          var previousFormatContext = task.blockedSegment.formatContext;
          var previousLegacyContext = task.legacyContext;
          var previousContext = task.context;
          var previousComponentStack = null;
          {
            previousComponentStack = task.componentStack;
          }
          try {
            return renderNodeDestructive(request, task, node);
          } catch (x) {
            resetHooksState();
            if (typeof x === "object" && x !== null && typeof x.then === "function") {
              spawnNewSuspendedTask(request, task, x);
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              return;
            } else {
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              throw x;
            }
          }
        }
        function erroredTask(request, boundary, segment, error2) {
          var errorDigest = logRecoverableError(request, error2);
          if (boundary === null) {
            fatalError(request, error2);
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              boundary.errorDigest = errorDigest;
              {
                captureBoundaryErrorDetailsDev(boundary, error2);
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function abortTaskSoft(task) {
          var request = this;
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          finishedTask(request, boundary, segment);
        }
        function abortTask(task, request, reason) {
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          if (boundary === null) {
            request.allPendingTasks--;
            if (request.status !== CLOSED) {
              request.status = CLOSED;
              if (request.destination !== null) {
                close(request.destination);
              }
            }
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
              boundary.errorDigest = request.onError(_error);
              {
                var errorPrefix = "The server did not finish this Suspense boundary: ";
                if (_error && typeof _error.message === "string") {
                  _error = errorPrefix + _error.message;
                } else {
                  _error = errorPrefix + String(_error);
                }
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                  captureBoundaryErrorDetailsDev(boundary, _error);
                } finally {
                  currentTaskInDEV = previousTaskInDev;
                }
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
        }
        function queueCompletedSegment(boundary, segment) {
          if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) {
              queueCompletedSegment(boundary, childSegment);
            }
          } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
          }
        }
        function finishedTask(request, boundary, segment) {
          if (boundary === null) {
            if (segment.parentFlushed) {
              if (request.completedRootSegment !== null) {
                throw new Error("There can only be one root segment. This is a bug in React.");
              }
              request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            if (request.pendingRootTasks === 0) {
              request.onShellError = noop$1;
              var onShellReady = request.onShellReady;
              onShellReady();
            }
          } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender) ;
            else if (boundary.pendingTasks === 0) {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                }
              }
              if (boundary.parentFlushed) {
                request.completedBoundaries.push(boundary);
              }
              boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
              boundary.fallbackAbortableTasks.clear();
            } else {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                  var completedSegments = boundary.completedSegments;
                  if (completedSegments.length === 1) {
                    if (boundary.parentFlushed) {
                      request.partialBoundaries.push(boundary);
                    }
                  }
                }
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function retryTask(request, task) {
          var segment = task.blockedSegment;
          if (segment.status !== PENDING) {
            return;
          }
          switchContext(task.context);
          var prevTaskInDEV = null;
          {
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = task;
          }
          try {
            renderNodeDestructive(request, task, task.node);
            pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request, task.blockedBoundary, segment);
          } catch (x) {
            resetHooksState();
            if (typeof x === "object" && x !== null && typeof x.then === "function") {
              var ping = task.ping;
              x.then(ping, ping);
            } else {
              task.abortSet.delete(task);
              segment.status = ERRORED;
              erroredTask(request, task.blockedBoundary, segment, x);
            }
          } finally {
            {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        }
        function performWork(request) {
          if (request.status === CLOSED) {
            return;
          }
          var prevContext = getActiveContext();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          {
            prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
            ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          }
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks;
            var i;
            for (i = 0; i < pingedTasks.length; i++) {
              var task = pingedTasks[i];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i);
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          } finally {
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            }
            if (prevDispatcher === Dispatcher) {
              switchContext(prevContext);
            }
          }
        }
        function flushSubtree(request, destination, segment) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING: {
              var segmentID = segment.id = request.nextSegmentId++;
              segment.lastPushedText = false;
              segment.textEmbedded = false;
              return writePlaceholder(destination, request.responseState, segmentID);
            }
            case COMPLETED: {
              segment.status = FLUSHED;
              var r = true;
              var chunks = segment.chunks;
              var chunkIdx = 0;
              var children = segment.children;
              for (var childIdx = 0; childIdx < children.length; childIdx++) {
                var nextChild = children[childIdx];
                for (; chunkIdx < nextChild.index; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                r = flushSegment(request, destination, nextChild);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              if (chunkIdx < chunks.length) {
                r = writeChunkAndReturn(destination, chunks[chunkIdx]);
              }
              return r;
            }
            default: {
              throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
            }
          }
        }
        function flushSegment(request, destination, segment) {
          var boundary = segment.boundary;
          if (boundary === null) {
            return flushSubtree(request, destination, segment);
          }
          boundary.parentFlushed = true;
          if (boundary.forceClientRender) {
            writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
            flushSubtree(request, destination, segment);
            return writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
          } else if (boundary.pendingTasks > 0) {
            boundary.rootSegmentID = request.nextSegmentId++;
            if (boundary.completedSegments.length > 0) {
              request.partialBoundaries.push(boundary);
            }
            var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
            writeStartPendingSuspenseBoundary(destination, request.responseState, id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else if (boundary.byteSize > request.progressiveChunkSize) {
            boundary.rootSegmentID = request.nextSegmentId++;
            request.completedBoundaries.push(boundary);
            writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else {
            writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) {
              throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
            }
            var contentSegment = completedSegments[0];
            flushSegment(request, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
          }
        }
        function flushClientRenderedBoundary(request, destination, boundary) {
          return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
        }
        function flushSegmentContainer(request, destination, segment) {
          writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
          flushSegment(request, destination, segment);
          return writeEndSegment(destination, segment.formatContext);
        }
        function flushCompletedBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i = 0;
          for (; i < completedSegments.length; i++) {
            var segment = completedSegments[i];
            flushPartiallyCompletedSegment(request, destination, boundary, segment);
          }
          completedSegments.length = 0;
          return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
        }
        function flushPartialBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i = 0;
          for (; i < completedSegments.length; i++) {
            var segment = completedSegments[i];
            if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
              i++;
              completedSegments.splice(0, i);
              return false;
            }
          }
          completedSegments.splice(0, i);
          return true;
        }
        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
          if (segment.status === FLUSHED) {
            return true;
          }
          var segmentID = segment.id;
          if (segmentID === -1) {
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) {
              throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
            }
            return flushSegmentContainer(request, destination, segment);
          } else {
            flushSegmentContainer(request, destination, segment);
            return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
          }
        }
        function flushCompletedQueues(request, destination) {
          try {
            var completedRootSegment = request.completedRootSegment;
            if (completedRootSegment !== null && request.pendingRootTasks === 0) {
              flushSegment(request, destination, completedRootSegment);
              request.completedRootSegment = null;
              writeCompletedRoot(destination, request.responseState);
            }
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            var i;
            for (i = 0; i < clientRenderedBoundaries.length; i++) {
              var boundary = clientRenderedBoundaries[i];
              if (!flushClientRenderedBoundary(request, destination, boundary)) {
                request.destination = null;
                i++;
                clientRenderedBoundaries.splice(0, i);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i);
            var completedBoundaries = request.completedBoundaries;
            for (i = 0; i < completedBoundaries.length; i++) {
              var _boundary = completedBoundaries[i];
              if (!flushCompletedBoundary(request, destination, _boundary)) {
                request.destination = null;
                i++;
                completedBoundaries.splice(0, i);
                return;
              }
            }
            completedBoundaries.splice(0, i);
            completeWriting(destination);
            beginWriting(destination);
            var partialBoundaries = request.partialBoundaries;
            for (i = 0; i < partialBoundaries.length; i++) {
              var _boundary2 = partialBoundaries[i];
              if (!flushPartialBoundary(request, destination, _boundary2)) {
                request.destination = null;
                i++;
                partialBoundaries.splice(0, i);
                return;
              }
            }
            partialBoundaries.splice(0, i);
            var largeBoundaries = request.completedBoundaries;
            for (i = 0; i < largeBoundaries.length; i++) {
              var _boundary3 = largeBoundaries[i];
              if (!flushCompletedBoundary(request, destination, _boundary3)) {
                request.destination = null;
                i++;
                largeBoundaries.splice(0, i);
                return;
              }
            }
            largeBoundaries.splice(0, i);
          } finally {
            if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
              {
                if (request.abortableTasks.size !== 0) {
                  error("There was still abortable task at the root when we closed. This is a bug in React.");
                }
              }
              close(destination);
            }
          }
        }
        function startWork(request) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
        function startFlowing(request, destination) {
          if (request.status === CLOSING) {
            request.status = CLOSED;
            closeWithError(destination, request.fatalError);
            return;
          }
          if (request.status === CLOSED) {
            return;
          }
          if (request.destination !== null) {
            return;
          }
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function abort(request, reason) {
          try {
            var abortableTasks = request.abortableTasks;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, reason);
            });
            abortableTasks.clear();
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function onError() {
        }
        function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
          var didFatal = false;
          var fatalError2 = null;
          var result = "";
          var destination = {
            push: function(chunk) {
              if (chunk !== null) {
                result += chunk;
              }
              return true;
            },
            destroy: function(error2) {
              didFatal = true;
              fatalError2 = error2;
            }
          };
          var readyToStream = false;
          function onShellReady() {
            readyToStream = true;
          }
          var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : void 0), createRootFormatContext(), Infinity, onError, void 0, onShellReady, void 0, void 0);
          startWork(request);
          abort(request, abortReason);
          startFlowing(request, destination);
          if (didFatal) {
            throw fatalError2;
          }
          if (!readyToStream) {
            throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          }
          return result;
        }
        function renderToString(children, options) {
          return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
        }
        function renderToStaticMarkup(children, options) {
          return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
        }
        function renderToNodeStream() {
          throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
        }
        function renderToStaticNodeStream() {
          throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
        }
        exports.renderToNodeStream = renderToNodeStream;
        exports.renderToStaticMarkup = renderToStaticMarkup;
        exports.renderToStaticNodeStream = renderToStaticNodeStream;
        exports.renderToString = renderToString;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/cjs/react-dom-server.browser.development.js
var require_react_dom_server_browser_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.browser.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React2 = require_react();
        var ReactVersion = "18.3.1";
        var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function scheduleWork(callback) {
          callback();
        }
        var VIEW_SIZE = 512;
        var currentView = null;
        var writtenBytes = 0;
        function beginWriting(destination) {
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
        function writeChunk(destination, chunk) {
          if (chunk.length === 0) {
            return;
          }
          if (chunk.length > VIEW_SIZE) {
            if (writtenBytes > 0) {
              destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
              currentView = new Uint8Array(VIEW_SIZE);
              writtenBytes = 0;
            }
            destination.enqueue(chunk);
            return;
          }
          var bytesToWrite = chunk;
          var allowableBytes = currentView.length - writtenBytes;
          if (allowableBytes < bytesToWrite.length) {
            if (allowableBytes === 0) {
              destination.enqueue(currentView);
            } else {
              currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
              destination.enqueue(currentView);
              bytesToWrite = bytesToWrite.subarray(allowableBytes);
            }
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          currentView.set(bytesToWrite, writtenBytes);
          writtenBytes += bytesToWrite.length;
        }
        function writeChunkAndReturn(destination, chunk) {
          writeChunk(destination, chunk);
          return true;
        }
        function completeWriting(destination) {
          if (currentView && writtenBytes > 0) {
            destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
            currentView = null;
            writtenBytes = 0;
          }
        }
        function close(destination) {
          destination.close();
        }
        var textEncoder = new TextEncoder();
        function stringToChunk(content) {
          return textEncoder.encode(content);
        }
        function stringToPrecomputedChunk(content) {
          return textEncoder.encode(content);
        }
        function closeWithError(destination, error2) {
          if (typeof destination.error === "function") {
            destination.error(error2);
          } else {
            destination.close();
          }
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            RESERVED,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            BOOLEAN,
            true,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(
            name,
            NUMERIC,
            false,
            // mustUseProperty
            name.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(
            name,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error(
              "Unsupported style property %s. Did you mean %s?",
              name,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name.replace(msPattern, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          {
            checkHtmlStringCoercion(string);
          }
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape = "&quot;";
                break;
              case 38:
                escape = "&amp;";
                break;
              case 39:
                escape = "&#x27;";
                break;
              case 60:
                escape = "&lt;";
                break;
              case 62:
                escape = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text2) {
          if (typeof text2 === "boolean" || typeof text2 === "number") {
            return "" + text2;
          }
          return escapeHtml(text2);
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern$1 = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
        }
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        var startInlineScript = stringToPrecomputedChunk("<script>");
        var endInlineScript = stringToPrecomputedChunk("<\/script>");
        var startScriptSrc = stringToPrecomputedChunk('<script src="');
        var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
        var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
        function escapeBootstrapScriptContent(scriptText) {
          {
            checkHtmlStringCoercion(scriptText);
          }
          return ("" + scriptText).replace(scriptRegex, scriptReplacer);
        }
        var scriptRegex = /(<\/|<)(s)(cript)/gi;
        var scriptReplacer = function(match, prefix2, s, suffix) {
          return "" + prefix2 + (s === "s" ? "\\u0073" : "\\u0053") + suffix;
        };
        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
          var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
          var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
          var bootstrapChunks = [];
          if (bootstrapScriptContent !== void 0) {
            bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
          }
          if (bootstrapScripts !== void 0) {
            for (var i = 0; i < bootstrapScripts.length; i++) {
              bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
            }
          }
          if (bootstrapModules !== void 0) {
            for (var _i = 0; _i < bootstrapModules.length; _i++) {
              bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
            }
          }
          return {
            bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
            boundaryPrefix: idPrefix + "B:",
            idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
          };
        }
        var ROOT_HTML_MODE = 0;
        var HTML_MODE = 1;
        var SVG_MODE = 2;
        var MATHML_MODE = 3;
        var HTML_TABLE_MODE = 4;
        var HTML_TABLE_BODY_MODE = 5;
        var HTML_TABLE_ROW_MODE = 6;
        var HTML_COLGROUP_MODE = 7;
        function createFormatContext(insertionMode, selectedValue) {
          return {
            insertionMode,
            selectedValue
          };
        }
        function createRootFormatContext(namespaceURI) {
          var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
          return createFormatContext(insertionMode, null);
        }
        function getChildFormatContext(parentContext, type, props) {
          switch (type) {
            case "select":
              return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
            case "svg":
              return createFormatContext(SVG_MODE, null);
            case "math":
              return createFormatContext(MATHML_MODE, null);
            case "foreignObject":
              return createFormatContext(HTML_MODE, null);
            case "table":
              return createFormatContext(HTML_TABLE_MODE, null);
            case "thead":
            case "tbody":
            case "tfoot":
              return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case "colgroup":
              return createFormatContext(HTML_COLGROUP_MODE, null);
            case "tr":
              return createFormatContext(HTML_TABLE_ROW_MODE, null);
          }
          if (parentContext.insertionMode >= HTML_TABLE_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          if (parentContext.insertionMode === ROOT_HTML_MODE) {
            return createFormatContext(HTML_MODE, null);
          }
          return parentContext;
        }
        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
        function assignSuspenseBoundaryID(responseState) {
          var generatedID = responseState.nextSuspenseID++;
          return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
        }
        function makeId(responseState, treeId, localId) {
          var idPrefix = responseState.idPrefix;
          var id = ":" + idPrefix + "R" + treeId;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          return id + ":";
        }
        function encodeHTMLTextNode(text2) {
          return escapeTextForBrowser(text2);
        }
        var textSeparator = stringToPrecomputedChunk("<!-- -->");
        function pushTextInstance(target, text2, responseState, textEmbedded) {
          if (text2 === "") {
            return textEmbedded;
          }
          if (textEmbedded) {
            target.push(textSeparator);
          }
          target.push(stringToChunk(encodeHTMLTextNode(text2)));
          return true;
        }
        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
          if (lastPushedText && textEmbedded) {
            target.push(textSeparator);
          }
        }
        var styleNameCache = /* @__PURE__ */ new Map();
        function processStyleName(styleName) {
          var chunk = styleNameCache.get(styleName);
          if (chunk !== void 0) {
            return chunk;
          }
          var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
          styleNameCache.set(styleName, result);
          return result;
        }
        var styleAttributeStart = stringToPrecomputedChunk(' style="');
        var styleAssign = stringToPrecomputedChunk(":");
        var styleSeparator = stringToPrecomputedChunk(";");
        function pushStyle(target, responseState, style) {
          if (typeof style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
          var isFirst = true;
          for (var styleName in style) {
            if (!hasOwnProperty.call(style, styleName)) {
              continue;
            }
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
              continue;
            }
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty = styleName.indexOf("--") === 0;
            if (isCustomProperty) {
              nameChunk = stringToChunk(escapeTextForBrowser(styleName));
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            } else {
              {
                warnValidStyle$1(styleName, styleValue);
              }
              nameChunk = processStyleName(styleName);
              if (typeof styleValue === "number") {
                if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                  valueChunk = stringToChunk(styleValue + "px");
                } else {
                  valueChunk = stringToChunk("" + styleValue);
                }
              } else {
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              }
            }
            if (isFirst) {
              isFirst = false;
              target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else {
              target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
            }
          }
          if (!isFirst) {
            target.push(attributeEnd);
          }
        }
        var attributeSeparator = stringToPrecomputedChunk(" ");
        var attributeAssign = stringToPrecomputedChunk('="');
        var attributeEnd = stringToPrecomputedChunk('"');
        var attributeEmptyString = stringToPrecomputedChunk('=""');
        function pushAttribute(target, responseState, name, value) {
          switch (name) {
            case "style": {
              pushStyle(target, responseState, value);
              return;
            }
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              return;
          }
          if (
            // shouldIgnoreAttribute
            // We have already filtered out null/undefined and reserved words.
            name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")
          ) {
            return;
          }
          var propertyInfo = getPropertyInfo(name);
          if (propertyInfo !== null) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                if (!propertyInfo.acceptsBooleans) {
                  return;
                }
              }
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName);
            switch (propertyInfo.type) {
              case BOOLEAN:
                if (value) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                }
                return;
              case OVERLOADED_BOOLEAN:
                if (value === true) {
                  target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                } else if (value === false) ;
                else {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                return;
              case NUMERIC:
                if (!isNaN(value)) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              case POSITIVE_NUMERIC:
                if (!isNaN(value) && value >= 1) {
                  target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                }
                break;
              default:
                if (propertyInfo.sanitizeURL) {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  value = "" + value;
                  sanitizeURL(value);
                }
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
          } else if (isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean": {
                var prefix2 = name.toLowerCase().slice(0, 5);
                if (prefix2 !== "data-" && prefix2 !== "aria-") {
                  return;
                }
              }
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        }
        var endOfStartTag = stringToPrecomputedChunk(">");
        var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
        function pushInnerHTML(target, innerHTML, children) {
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnInvalidOptionInnerHTML = false;
        var didWarnSelectedSetOnOption = false;
        function checkSelectProp(props, propName) {
          {
            var value = props[propName];
            if (value != null) {
              var array = isArray(value);
              if (props.multiple && !array) {
                error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
              } else if (!props.multiple && array) {
                error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
              }
            }
          }
        }
        function pushStartSelect(target, props, responseState) {
          {
            checkControlledValueProps("select", props);
            checkSelectProp(props, "value");
            checkSelectProp(props, "defaultValue");
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
              error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultSelectValue = true;
            }
          }
          target.push(startChunkForTag("select"));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function flattenOptionChildren(children) {
          var content = "";
          React2.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
              }
            }
          });
          return content;
        }
        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
        function pushStartOption(target, props, responseState, formatContext) {
          var selectedValue = formatContext.selectedValue;
          target.push(startChunkForTag("option"));
          var children = null;
          var value = null;
          var selected = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "selected":
                  selected = propValue;
                  {
                    if (!didWarnSelectedSetOnOption) {
                      error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                      didWarnSelectedSetOnOption = true;
                    }
                  }
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "value":
                  value = propValue;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (selectedValue != null) {
            var stringValue;
            if (value !== null) {
              {
                checkAttributeStringCoercion(value, "value");
              }
              stringValue = "" + value;
            } else {
              {
                if (innerHTML !== null) {
                  if (!didWarnInvalidOptionInnerHTML) {
                    didWarnInvalidOptionInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              stringValue = flattenOptionChildren(children);
            }
            if (isArray(selectedValue)) {
              for (var i = 0; i < selectedValue.length; i++) {
                {
                  checkAttributeStringCoercion(selectedValue[i], "value");
                }
                var v = "" + selectedValue[i];
                if (v === stringValue) {
                  target.push(selectedMarkerAttribute);
                  break;
                }
              }
            } else {
              {
                checkAttributeStringCoercion(selectedValue, "select.value");
              }
              if ("" + selectedValue === stringValue) {
                target.push(selectedMarkerAttribute);
              }
            }
          } else if (selected) {
            target.push(selectedMarkerAttribute);
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        function pushInput(target, props, responseState) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
              error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
              error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
              didWarnDefaultInputValue = true;
            }
          }
          target.push(startChunkForTag("input"));
          var value = null;
          var defaultValue = null;
          var checked = null;
          var defaultChecked = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  defaultChecked = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "checked":
                  checked = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (checked !== null) {
            pushAttribute(target, responseState, "checked", checked);
          } else if (defaultChecked !== null) {
            pushAttribute(target, responseState, "checked", defaultChecked);
          }
          if (value !== null) {
            pushAttribute(target, responseState, "value", value);
          } else if (defaultValue !== null) {
            pushAttribute(target, responseState, "value", defaultValue);
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartTextArea(target, props, responseState) {
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
              error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnDefaultTextareaValue = true;
            }
          }
          target.push(startChunkForTag("textarea"));
          var value = null;
          var defaultValue = null;
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "value":
                  value = propValue;
                  break;
                case "defaultValue":
                  defaultValue = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          if (value === null && defaultValue !== null) {
            value = defaultValue;
          }
          target.push(endOfStartTag);
          if (children != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            }
            if (value != null) {
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
            if (isArray(children)) {
              if (children.length > 1) {
                throw new Error("<textarea> can only have at most one child.");
              }
              {
                checkHtmlStringCoercion(children[0]);
              }
              value = "" + children[0];
            }
            {
              checkHtmlStringCoercion(children);
            }
            value = "" + children;
          }
          if (typeof value === "string" && value[0] === "\n") {
            target.push(leadingNewline);
          }
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            target.push(stringToChunk(encodeHTMLTextNode("" + value)));
          }
          return null;
        }
        function pushSelfClosing(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTagSelfClosing);
          return null;
        }
        function pushStartMenuItem(target, props, responseState) {
          target.push(startChunkForTag("menuitem"));
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          return null;
        }
        function pushStartTitle(target, props, responseState) {
          target.push(startChunkForTag("title"));
          var children = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          {
            var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
            if (Array.isArray(children) && children.length > 1) {
              error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && child.$$typeof != null) {
              error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            } else if (child != null && typeof child !== "string" && typeof child !== "number") {
              error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
            }
          }
          return children;
        }
        function pushStartGenericElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          if (typeof children === "string") {
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
          }
          return children;
        }
        function pushStartCustomElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "style":
                  pushStyle(target, responseState, propValue);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                    target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                  }
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          pushInnerHTML(target, innerHTML, children);
          return children;
        }
        var leadingNewline = stringToPrecomputedChunk("\n");
        function pushStartPreformattedElement(target, props, tag, responseState) {
          target.push(startChunkForTag(tag));
          var children = null;
          var innerHTML = null;
          for (var propKey in props) {
            if (hasOwnProperty.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue == null) {
                continue;
              }
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                default:
                  pushAttribute(target, responseState, propKey, propValue);
                  break;
              }
            }
          }
          target.push(endOfStartTag);
          if (innerHTML != null) {
            if (children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
            var html = innerHTML.__html;
            if (html !== null && html !== void 0) {
              if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                target.push(leadingNewline, stringToChunk(html));
              } else {
                {
                  checkHtmlStringCoercion(html);
                }
                target.push(stringToChunk("" + html));
              }
            }
          }
          if (typeof children === "string" && children[0] === "\n") {
            target.push(leadingNewline);
          }
          return children;
        }
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = /* @__PURE__ */ new Map();
        function startChunkForTag(tag) {
          var tagStartChunk = validatedTagCache.get(tag);
          if (tagStartChunk === void 0) {
            if (!VALID_TAG_REGEX.test(tag)) {
              throw new Error("Invalid tag: " + tag);
            }
            tagStartChunk = stringToPrecomputedChunk("<" + tag);
            validatedTagCache.set(tag, tagStartChunk);
          }
          return tagStartChunk;
        }
        var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
        function pushStartInstance(target, type, props, responseState, formatContext) {
          {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
            if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
              if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
          }
          switch (type) {
            case "select":
              return pushStartSelect(target, props, responseState);
            case "option":
              return pushStartOption(target, props, responseState, formatContext);
            case "textarea":
              return pushStartTextArea(target, props, responseState);
            case "input":
              return pushInput(target, props, responseState);
            case "menuitem":
              return pushStartMenuItem(target, props, responseState);
            case "title":
              return pushStartTitle(target, props, responseState);
            case "listing":
            case "pre": {
              return pushStartPreformattedElement(target, props, type, responseState);
            }
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              return pushSelfClosing(target, props, type, responseState);
            }
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph": {
              return pushStartGenericElement(target, props, type, responseState);
            }
            case "html": {
              if (formatContext.insertionMode === ROOT_HTML_MODE) {
                target.push(DOCTYPE);
              }
              return pushStartGenericElement(target, props, type, responseState);
            }
            default: {
              if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                return pushStartGenericElement(target, props, type, responseState);
              } else {
                return pushStartCustomElement(target, props, type, responseState);
              }
            }
          }
        }
        var endTag1 = stringToPrecomputedChunk("</");
        var endTag2 = stringToPrecomputedChunk(">");
        function pushEndInstance(target, type, props) {
          switch (type) {
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr": {
              break;
            }
            default: {
              target.push(endTag1, stringToChunk(type), endTag2);
            }
          }
        }
        function writeCompletedRoot(destination, responseState) {
          var bootstrapChunks = responseState.bootstrapChunks;
          var i = 0;
          for (; i < bootstrapChunks.length - 1; i++) {
            writeChunk(destination, bootstrapChunks[i]);
          }
          if (i < bootstrapChunks.length) {
            return writeChunkAndReturn(destination, bootstrapChunks[i]);
          }
          return true;
        }
        var placeholder1 = stringToPrecomputedChunk('<template id="');
        var placeholder2 = stringToPrecomputedChunk('"></template>');
        function writePlaceholder(destination, responseState, id) {
          writeChunk(destination, placeholder1);
          writeChunk(destination, responseState.placeholderPrefix);
          var formattedID = stringToChunk(id.toString(16));
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, placeholder2);
        }
        var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
        var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
        function writeStartCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
        }
        function writeStartPendingSuspenseBoundary(destination, responseState, id) {
          writeChunk(destination, startPendingSuspenseBoundary1);
          if (id === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, id);
          return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
        }
        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
          var result;
          result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
          writeChunk(destination, clientRenderedSuspenseBoundaryError1);
          if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          {
            if (errorMesssage) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
          }
          result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
          return result;
        }
        function writeEndCompletedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndPendingSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
          return writeChunkAndReturn(destination, endSuspenseBoundary);
        }
        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
        var startSegmentHTML2 = stringToPrecomputedChunk('">');
        var endSegmentHTML = stringToPrecomputedChunk("</div>");
        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
        var startSegmentSVG2 = stringToPrecomputedChunk('">');
        var endSegmentSVG = stringToPrecomputedChunk("</svg>");
        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
        var startSegmentMathML2 = stringToPrecomputedChunk('">');
        var endSegmentMathML = stringToPrecomputedChunk("</math>");
        var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
        var startSegmentTable2 = stringToPrecomputedChunk('">');
        var endSegmentTable = stringToPrecomputedChunk("</table>");
        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
        var startSegmentTableBody2 = stringToPrecomputedChunk('">');
        var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
        var startSegmentTableRow2 = stringToPrecomputedChunk('">');
        var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
        var startSegmentColGroup2 = stringToPrecomputedChunk('">');
        var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
        function writeStartSegment(destination, responseState, formatContext, id) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              writeChunk(destination, startSegmentHTML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentHTML2);
            }
            case SVG_MODE: {
              writeChunk(destination, startSegmentSVG);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentSVG2);
            }
            case MATHML_MODE: {
              writeChunk(destination, startSegmentMathML);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentMathML2);
            }
            case HTML_TABLE_MODE: {
              writeChunk(destination, startSegmentTable);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTable2);
            }
            case HTML_TABLE_BODY_MODE: {
              writeChunk(destination, startSegmentTableBody);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableBody2);
            }
            case HTML_TABLE_ROW_MODE: {
              writeChunk(destination, startSegmentTableRow);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentTableRow2);
            }
            case HTML_COLGROUP_MODE: {
              writeChunk(destination, startSegmentColGroup);
              writeChunk(destination, responseState.segmentPrefix);
              writeChunk(destination, stringToChunk(id.toString(16)));
              return writeChunkAndReturn(destination, startSegmentColGroup2);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        function writeEndSegment(destination, formatContext) {
          switch (formatContext.insertionMode) {
            case ROOT_HTML_MODE:
            case HTML_MODE: {
              return writeChunkAndReturn(destination, endSegmentHTML);
            }
            case SVG_MODE: {
              return writeChunkAndReturn(destination, endSegmentSVG);
            }
            case MATHML_MODE: {
              return writeChunkAndReturn(destination, endSegmentMathML);
            }
            case HTML_TABLE_MODE: {
              return writeChunkAndReturn(destination, endSegmentTable);
            }
            case HTML_TABLE_BODY_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableBody);
            }
            case HTML_TABLE_ROW_MODE: {
              return writeChunkAndReturn(destination, endSegmentTableRow);
            }
            case HTML_COLGROUP_MODE: {
              return writeChunkAndReturn(destination, endSegmentColGroup);
            }
            default: {
              throw new Error("Unknown insertion mode. This is a bug in React.");
            }
          }
        }
        var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
        var completeSegmentScript2 = stringToPrecomputedChunk('","');
        var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteSegmentFunction) {
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
          } else {
            writeChunk(destination, completeSegmentScript1Partial);
          }
          writeChunk(destination, responseState.segmentPrefix);
          var formattedID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, formattedID);
          writeChunk(destination, completeSegmentScript2);
          writeChunk(destination, responseState.placeholderPrefix);
          writeChunk(destination, formattedID);
          return writeChunkAndReturn(destination, completeSegmentScript3);
        }
        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
        var completeBoundaryScript2 = stringToPrecomputedChunk('","');
        var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentCompleteBoundaryFunction) {
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
          } else {
            writeChunk(destination, completeBoundaryScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          var formattedContentID = stringToChunk(contentSegmentID.toString(16));
          writeChunk(destination, boundaryID);
          writeChunk(destination, completeBoundaryScript2);
          writeChunk(destination, responseState.segmentPrefix);
          writeChunk(destination, formattedContentID);
          return writeChunkAndReturn(destination, completeBoundaryScript3);
        }
        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
        var clientRenderScript1A = stringToPrecomputedChunk('"');
        var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
          writeChunk(destination, responseState.startInlineScript);
          if (!responseState.sentClientRenderFunction) {
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
          } else {
            writeChunk(destination, clientRenderScript1Partial);
          }
          if (boundaryID === null) {
            throw new Error("An ID must have been assigned before we can complete the boundary.");
          }
          writeChunk(destination, boundaryID);
          writeChunk(destination, clientRenderScript1A);
          if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
          }
          if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
          }
          return writeChunkAndReturn(destination, clientRenderScript2);
        }
        var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
        function escapeJSStringsForInstructionScripts(input) {
          var escaped = JSON.stringify(input);
          return escaped.replace(regexForJSStringsInScripts, function(match) {
            switch (match) {
              case "<":
                return "\\u003c";
              case "\u2028":
                return "\\u2028";
              case "\u2029":
                return "\\u2029";
              default: {
                throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
              }
            }
          });
        }
        var assign = Object.assign;
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        function getMaskedContext(type, unmaskedContext) {
          {
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var context = {};
            for (var key in contextTypes) {
              context[key] = unmaskedContext[key];
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(contextTypes, context, "context", name);
            }
            return context;
          }
        }
        function processChildContext(instance, type, parentContext, childContextTypes) {
          {
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromType(type) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign({}, parentContext, childContext);
          }
        }
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var rootContextSnapshot = null;
        var currentActiveSnapshot = null;
        function popNode(prev) {
          {
            prev.context._currentValue = prev.parentValue;
          }
        }
        function pushNode(next) {
          {
            next.context._currentValue = next.value;
          }
        }
        function popToNearestCommonAncestor(prev, next) {
          if (prev === next) ;
          else {
            popNode(prev);
            var parentPrev = prev.parent;
            var parentNext = next.parent;
            if (parentPrev === null) {
              if (parentNext !== null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
            } else {
              if (parentNext === null) {
                throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
              }
              popToNearestCommonAncestor(parentPrev, parentNext);
            }
            pushNode(next);
          }
        }
        function popAllPrevious(prev) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev !== null) {
            popAllPrevious(parentPrev);
          }
        }
        function pushAllNext(next) {
          var parentNext = next.parent;
          if (parentNext !== null) {
            pushAllNext(parentNext);
          }
          pushNode(next);
        }
        function popPreviousToCommonLevel(prev, next) {
          popNode(prev);
          var parentPrev = prev.parent;
          if (parentPrev === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (parentPrev.depth === next.depth) {
            popToNearestCommonAncestor(parentPrev, next);
          } else {
            popPreviousToCommonLevel(parentPrev, next);
          }
        }
        function popNextToCommonLevel(prev, next) {
          var parentNext = next.parent;
          if (parentNext === null) {
            throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
          }
          if (prev.depth === parentNext.depth) {
            popToNearestCommonAncestor(prev, parentNext);
          } else {
            popNextToCommonLevel(prev, parentNext);
          }
          pushNode(next);
        }
        function switchContext(newSnapshot) {
          var prev = currentActiveSnapshot;
          var next = newSnapshot;
          if (prev !== next) {
            if (prev === null) {
              pushAllNext(next);
            } else if (next === null) {
              popAllPrevious(prev);
            } else if (prev.depth === next.depth) {
              popToNearestCommonAncestor(prev, next);
            } else if (prev.depth > next.depth) {
              popPreviousToCommonLevel(prev, next);
            } else {
              popNextToCommonLevel(prev, next);
            }
            currentActiveSnapshot = next;
          }
        }
        function pushProvider(context, nextValue) {
          var prevValue;
          {
            prevValue = context._currentValue;
            context._currentValue = nextValue;
            {
              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer = rendererSigil;
            }
          }
          var prevNode = currentActiveSnapshot;
          var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context,
            parentValue: prevValue,
            value: nextValue
          };
          currentActiveSnapshot = newNode;
          return newNode;
        }
        function popProvider(context) {
          var prevSnapshot = currentActiveSnapshot;
          if (prevSnapshot === null) {
            throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          }
          {
            if (prevSnapshot.context !== context) {
              error("The parent context is not the expected context. This is probably a bug in React.");
            }
          }
          {
            var value = prevSnapshot.parentValue;
            if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
              prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
            } else {
              prevSnapshot.context._currentValue = value;
            }
            {
              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer = rendererSigil;
            }
          }
          return currentActiveSnapshot = prevSnapshot.parent;
        }
        function getActiveContext() {
          return currentActiveSnapshot;
        }
        function readContext(context) {
          var value = context._currentValue;
          return value;
        }
        function get(key) {
          return key._reactInternals;
        }
        function set(key, value) {
          key._reactInternals = value;
        }
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key)) {
              didWarnOnInvalidCallback.add(key);
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        var classComponentUpdater = {
          isMounted: function(inst) {
            return false;
          },
          enqueueSetState: function(inst, payload, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "setState");
            } else {
              internals.queue.push(payload);
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var internals = get(inst);
            internals.replace = true;
            internals.queue = [payload];
            {
              if (callback !== void 0 && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var internals = get(inst);
            if (internals.queue === null) {
              warnNoop(inst, "forceUpdate");
            } else {
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            }
          }
        };
        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var newState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
          return newState;
        }
        function constructClassInstance(ctor, props, maskedLegacyContext) {
          var context = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
              );
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context = readContext(contextType);
          } else {
            context = maskedLegacyContext;
          }
          var instance = new ctor(props, context);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          return instance;
        }
        function checkClassInstance(instance, ctor, newProps) {
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance.propTypes) {
              error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance.contextType) {
              error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance.contextTypes) {
                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance.defaultProps) {
              error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray(_state))) {
              error("%s.state: must be set to an object or null", name);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function callComponentWillMount(type, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type) || "Unknown";
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                  warn(
                    // keep this warning in sync with ReactStrictModeWarning.js
                    "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                    componentName
                  );
                  didWarnAboutDeprecatedWillMount[componentName] = true;
                }
              }
            }
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
          if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) {
              inst.state = oldQueue[0];
            } else {
              var nextState = oldReplace ? oldQueue[0] : inst.state;
              var dontMutate = true;
              for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                var partial = oldQueue[i];
                var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                if (partialState != null) {
                  if (dontMutate) {
                    dontMutate = false;
                    nextState = assign({}, nextState, partialState);
                  } else {
                    assign(nextState, partialState);
                  }
                }
              }
              inst.state = nextState;
            }
          } else {
            internalInstance.queue = null;
          }
        }
        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
          {
            checkClassInstance(instance, ctor, newProps);
          }
          var initialState = instance.state !== void 0 ? instance.state : null;
          instance.updater = classComponentUpdater;
          instance.props = newProps;
          instance.state = initialState;
          var internalInstance = {
            queue: [],
            replace: false
          };
          set(instance, internalInstance);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            instance.context = maskedLegacyContext;
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(ctor, instance);
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
          }
        }
        var emptyTreeContext = {
          id: 1,
          overflow: ""
        };
        function getTreeId(context) {
          var overflow = context.overflow;
          var idWithLeadingBit = context.id;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeContext(baseContext, totalChildren, index) {
          var baseIdWithLeadingBit = baseContext.id;
          var baseOverflow = baseContext.overflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index + 1;
          var length = getBitLength(totalChildren) + baseLength;
          if (length > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
              id: 1 << restOfLength | id,
              overflow
            };
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
              id: 1 << length | _id,
              overflow: _overflow
            };
          }
        }
        function getBitLength(number) {
          return 32 - clz32(number);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x) {
          var asUint = x >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var currentlyRenderingTask = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var localIdCounter = 0;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (currentlyRenderingComponent === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
            if (objectIs(nextDeps[i], prevDeps[i])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            throw new Error("Rendered more hooks than during the previous render");
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(task, componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          currentlyRenderingTask = task;
          {
            isInHookUserCodeInDev = false;
          }
          localIdCounter = 0;
        }
        function finishHooks(Component, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          return didRenderIdHook;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          currentlyRenderingTask = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext$1(context) {
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return readContext(context);
        }
        function useContext5(context) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          return readContext(context);
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState17(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(
            basicStateReducer,
            // useReducer has a special case to support lazy useState initializers
            initialState
          );
        }
        function useReducer(reducer, initialArg, init) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue = workInProgressHook.queue;
            var dispatch = queue.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init !== void 0 ? init(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo28(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef16(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect2(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue, action) {
          if (numberOfReRenders >= RE_RENDER_LIMIT) {
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback49(callback, deps) {
          return useMemo28(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          if (getServerSnapshot === void 0) {
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          }
          return getServerSnapshot();
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function unsupportedStartTransition() {
          throw new Error("startTransition cannot be called during server rendering.");
        }
        function useTransition() {
          resolveCurrentlyRenderingComponent();
          return [false, unsupportedStartTransition];
        }
        function useId2() {
          var task = currentlyRenderingTask;
          var treeId = getTreeId(task.treeContext);
          var responseState = currentResponseState;
          if (responseState === null) {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
          }
          var localId = localIdCounter++;
          return makeId(responseState, treeId, localId);
        }
        function noop() {
        }
        var Dispatcher = {
          readContext: readContext$1,
          useContext: useContext5,
          useMemo: useMemo28,
          useReducer,
          useRef: useRef16,
          useState: useState17,
          useInsertionEffect: noop,
          useLayoutEffect: useLayoutEffect2,
          useCallback: useCallback49,
          // useImperativeHandle is not run in the server environment
          useImperativeHandle: noop,
          // Effects are not run in the server environment.
          useEffect: noop,
          // Debugging effect
          useDebugValue: noop,
          useDeferredValue,
          useTransition,
          useId: useId2,
          // Subscriptions are not setup in a server environment.
          useMutableSource,
          useSyncExternalStore
        };
        var currentResponseState = null;
        function setCurrentResponseState(responseState) {
          currentResponseState = responseState;
        }
        function getStackByComponentStackNode(componentStack) {
          try {
            var info = "";
            var node = componentStack;
            do {
              switch (node.tag) {
                case 0:
                  info += describeBuiltInComponentFrame(node.type, null, null);
                  break;
                case 1:
                  info += describeFunctionComponentFrame(node.type, null, null);
                  break;
                case 2:
                  info += describeClassComponentFrame(node.type, null, null);
                  break;
              }
              node = node.parent;
            } while (node);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        var PENDING = 0;
        var COMPLETED = 1;
        var FLUSHED = 2;
        var ABORTED = 3;
        var ERRORED = 4;
        var OPEN = 0;
        var CLOSING = 1;
        var CLOSED = 2;
        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
        function defaultErrorHandler(error2) {
          console["error"](error2);
          return null;
        }
        function noop$1() {
        }
        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
          var pingedTasks = [];
          var abortSet = /* @__PURE__ */ new Set();
          var request = {
            destination: null,
            responseState,
            progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError === void 0 ? defaultErrorHandler : onError,
            onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
            onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
            onShellError: onShellError === void 0 ? noop$1 : onShellError,
            onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
          };
          var rootSegment = createPendingSegment(
            request,
            0,
            null,
            rootFormatContext,
            // Root segments are never embedded in Text on either edge
            false,
            false
          );
          rootSegment.parentFlushed = true;
          var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
          pingedTasks.push(rootTask);
          return request;
        }
        function pingTask(request, task) {
          var pingedTasks = request.pingedTasks;
          pingedTasks.push(task);
          if (pingedTasks.length === 1) {
            scheduleWork(function() {
              return performWork(request);
            });
          }
        }
        function createSuspenseBoundary(request, fallbackAbortableTasks) {
          return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks,
            errorDigest: null
          };
        }
        function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
          request.allPendingTasks++;
          if (blockedBoundary === null) {
            request.pendingRootTasks++;
          } else {
            blockedBoundary.pendingTasks++;
          }
          var task = {
            node,
            ping: function() {
              return pingTask(request, task);
            },
            blockedBoundary,
            blockedSegment,
            abortSet,
            legacyContext,
            context,
            treeContext
          };
          {
            task.componentStack = null;
          }
          abortSet.add(task);
          return task;
        }
        function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
          return {
            status: PENDING,
            id: -1,
            // lazily assigned later
            index,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext,
            boundary,
            lastPushedText,
            textEmbedded
          };
        }
        var currentTaskInDEV = null;
        function getCurrentStackInDEV() {
          {
            if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
              return "";
            }
            return getStackByComponentStackNode(currentTaskInDEV.componentStack);
          }
        }
        function pushBuiltInComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 0,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushFunctionComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 1,
              parent: task.componentStack,
              type
            };
          }
        }
        function pushClassComponentStackInDEV(task, type) {
          {
            task.componentStack = {
              tag: 2,
              parent: task.componentStack,
              type
            };
          }
        }
        function popComponentStackInDEV(task) {
          {
            if (task.componentStack === null) {
              error("Unexpectedly popped too many stack frames. This is a bug in React.");
            } else {
              task.componentStack = task.componentStack.parent;
            }
          }
        }
        var lastBoundaryErrorComponentStackDev = null;
        function captureBoundaryErrorDetailsDev(boundary, error2) {
          {
            var errorMessage;
            if (typeof error2 === "string") {
              errorMessage = error2;
            } else if (error2 && typeof error2.message === "string") {
              errorMessage = error2.message;
            } else {
              errorMessage = String(error2);
            }
            var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
            lastBoundaryErrorComponentStackDev = null;
            boundary.errorMessage = errorMessage;
            boundary.errorComponentStack = errorComponentStack;
          }
        }
        function logRecoverableError(request, error2) {
          var errorDigest = request.onError(error2);
          if (errorDigest != null && typeof errorDigest !== "string") {
            throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
          }
          return errorDigest;
        }
        function fatalError(request, error2) {
          var onShellError = request.onShellError;
          onShellError(error2);
          var onFatalError = request.onFatalError;
          onFatalError(error2);
          if (request.destination !== null) {
            request.status = CLOSED;
            closeWithError(request.destination, error2);
          } else {
            request.status = CLOSING;
            request.fatalError = error2;
          }
        }
        function renderSuspenseBoundary(request, task, props) {
          pushBuiltInComponentStackInDEV(task, "Suspense");
          var parentBoundary = task.blockedBoundary;
          var parentSegment = task.blockedSegment;
          var fallback = props.fallback;
          var content = props.children;
          var fallbackAbortSet = /* @__PURE__ */ new Set();
          var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
          var insertionIndex = parentSegment.chunks.length;
          var boundarySegment = createPendingSegment(
            request,
            insertionIndex,
            newBoundary,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          parentSegment.children.push(boundarySegment);
          parentSegment.lastPushedText = false;
          var contentRootSegment = createPendingSegment(
            request,
            0,
            null,
            parentSegment.formatContext,
            // boundaries never require text embedding at their edges because comment nodes bound them
            false,
            false
          );
          contentRootSegment.parentFlushed = true;
          task.blockedBoundary = newBoundary;
          task.blockedSegment = contentRootSegment;
          try {
            renderNode(request, task, content);
            pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
              popComponentStackInDEV(task);
              return;
            }
          } catch (error2) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request, error2);
            {
              captureBoundaryErrorDetailsDev(newBoundary, error2);
            }
          } finally {
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
          }
          var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
          {
            suspendedFallbackTask.componentStack = task.componentStack;
          }
          request.pingedTasks.push(suspendedFallbackTask);
          popComponentStackInDEV(task);
        }
        function renderHostElement(request, task, type, props) {
          pushBuiltInComponentStackInDEV(task, type);
          var segment = task.blockedSegment;
          var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
          segment.lastPushedText = false;
          var prevContext = segment.formatContext;
          segment.formatContext = getChildFormatContext(prevContext, type, props);
          renderNode(request, task, children);
          segment.formatContext = prevContext;
          pushEndInstance(segment.chunks, type);
          segment.lastPushedText = false;
          popComponentStackInDEV(task);
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function renderWithHooks(request, task, Component, props, secondArg) {
          var componentIdentity = {};
          prepareToUseHooks(task, componentIdentity);
          var result = Component(props, secondArg);
          return finishHooks(Component, props, result, secondArg);
        }
        function finishClassComponent(request, task, instance, Component, props) {
          var nextChildren = instance.render();
          {
            if (instance.props !== props) {
              if (!didWarnAboutReassigningProps) {
                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          {
            var childContextTypes = Component.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== void 0) {
              var previousContext = task.legacyContext;
              var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
              task.legacyContext = mergedContext;
              renderNodeDestructive(request, task, nextChildren);
              task.legacyContext = previousContext;
              return;
            }
          }
          renderNodeDestructive(request, task, nextChildren);
        }
        function renderClassComponent(request, task, Component, props) {
          pushClassComponentStackInDEV(task, Component);
          var maskedContext = getMaskedContext(Component, task.legacyContext);
          var instance = constructClassInstance(Component, props, maskedContext);
          mountClassInstance(instance, Component, props, maskedContext);
          finishClassComponent(request, task, instance, Component, props);
          popComponentStackInDEV(task);
        }
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutDefaultPropsOnFunctionComponent = {};
        var didWarnAboutGenerators = false;
        var didWarnAboutMaps = false;
        var hasWarnedAboutUsingContextAsConsumer = false;
        function renderIndeterminateComponent(request, task, Component, props) {
          var legacyContext;
          {
            legacyContext = getMaskedContext(Component, task.legacyContext);
          }
          pushFunctionComponentStackInDEV(task, Component);
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
          }
          var value = renderWithHooks(request, task, Component, props, legacyContext);
          var hasId = checkDidRenderIdHook();
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            mountClassInstance(value, Component, props, legacyContext);
            finishClassComponent(request, task, value, Component, props);
          } else {
            {
              validateFunctionComponentInDev(Component);
            }
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
              try {
                renderNodeDestructive(request, task, value);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request, task, value);
            }
          }
          popComponentStackInDEV(task);
        }
        function validateFunctionComponentInDev(Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (Component.defaultProps !== void 0) {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        function renderForwardRef(request, task, type, props, ref) {
          pushFunctionComponentStackInDEV(task, type.render);
          var children = renderWithHooks(request, task, type.render, props, ref);
          var hasId = checkDidRenderIdHook();
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, children);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, children);
          }
          popComponentStackInDEV(task);
        }
        function renderMemo(request, task, type, props, ref) {
          var innerType = type.type;
          var resolvedProps = resolveDefaultProps(innerType, props);
          renderElement(request, task, innerType, resolvedProps, ref);
        }
        function renderContextConsumer(request, task, context, props) {
          {
            if (context._context === void 0) {
              if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context = context._context;
            }
          }
          var render = props.children;
          {
            if (typeof render !== "function") {
              error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          var newValue = readContext(context);
          var newChildren = render(newValue);
          renderNodeDestructive(request, task, newChildren);
        }
        function renderContextProvider(request, task, type, props) {
          var context = type._context;
          var value = props.value;
          var children = props.children;
          var prevSnapshot;
          {
            prevSnapshot = task.context;
          }
          task.context = pushProvider(context, value);
          renderNodeDestructive(request, task, children);
          task.context = popProvider(context);
          {
            if (prevSnapshot !== task.context) {
              error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
            }
          }
        }
        function renderLazyComponent(request, task, lazyComponent, props, ref) {
          pushBuiltInComponentStackInDEV(task, "Lazy");
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component = init(payload);
          var resolvedProps = resolveDefaultProps(Component, props);
          renderElement(request, task, Component, resolvedProps, ref);
          popComponentStackInDEV(task);
        }
        function renderElement(request, task, type, props, ref) {
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              renderClassComponent(request, task, type, props);
              return;
            } else {
              renderIndeterminateComponent(request, task, type, props);
              return;
            }
          }
          if (typeof type === "string") {
            renderHostElement(request, task, type, props);
            return;
          }
          switch (type) {
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE: {
              renderNodeDestructive(request, task, props.children);
              return;
            }
            case REACT_SUSPENSE_LIST_TYPE: {
              pushBuiltInComponentStackInDEV(task, "SuspenseList");
              renderNodeDestructive(request, task, props.children);
              popComponentStackInDEV(task);
              return;
            }
            case REACT_SCOPE_TYPE: {
              throw new Error("ReactDOMServer does not yet support scope components.");
            }
            case REACT_SUSPENSE_TYPE: {
              {
                renderSuspenseBoundary(request, task, props);
              }
              return;
            }
          }
          if (typeof type === "object" && type !== null) {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE: {
                renderForwardRef(request, task, type, props, ref);
                return;
              }
              case REACT_MEMO_TYPE: {
                renderMemo(request, task, type, props, ref);
                return;
              }
              case REACT_PROVIDER_TYPE: {
                renderContextProvider(request, task, type, props);
                return;
              }
              case REACT_CONTEXT_TYPE: {
                renderContextConsumer(request, task, type, props);
                return;
              }
              case REACT_LAZY_TYPE: {
                renderLazyComponent(request, task, type, props);
                return;
              }
            }
          }
          var info = "";
          {
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
          }
          throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
        }
        function validateIterable(iterable, iteratorFn) {
          {
            if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
            iterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (iterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
          }
        }
        function renderNodeDestructive(request, task, node) {
          {
            try {
              return renderNodeDestructiveImpl(request, task, node);
            } catch (x) {
              if (typeof x === "object" && x !== null && typeof x.then === "function") ;
              else {
                lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
              }
              throw x;
            }
          }
        }
        function renderNodeDestructiveImpl(request, task, node) {
          task.node = node;
          if (typeof node === "object" && node !== null) {
            switch (node.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var element = node;
                var type = element.type;
                var props = element.props;
                var ref = element.ref;
                renderElement(request, task, type, props, ref);
                return;
              }
              case REACT_PORTAL_TYPE:
                throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
              case REACT_LAZY_TYPE: {
                var lazyNode = node;
                var payload = lazyNode._payload;
                var init = lazyNode._init;
                var resolvedNode;
                {
                  try {
                    resolvedNode = init(payload);
                  } catch (x) {
                    if (typeof x === "object" && x !== null && typeof x.then === "function") {
                      pushBuiltInComponentStackInDEV(task, "Lazy");
                    }
                    throw x;
                  }
                }
                renderNodeDestructive(request, task, resolvedNode);
                return;
              }
            }
            if (isArray(node)) {
              renderChildrenArray(request, task, node);
              return;
            }
            var iteratorFn = getIteratorFn(node);
            if (iteratorFn) {
              {
                validateIterable(node, iteratorFn);
              }
              var iterator = iteratorFn.call(node);
              if (iterator) {
                var step = iterator.next();
                if (!step.done) {
                  var children = [];
                  do {
                    children.push(step.value);
                    step = iterator.next();
                  } while (!step.done);
                  renderChildrenArray(request, task, children);
                  return;
                }
                return;
              }
            }
            var childString = Object.prototype.toString.call(node);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          if (typeof node === "string") {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
            return;
          }
          if (typeof node === "number") {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
            return;
          }
          {
            if (typeof node === "function") {
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
        }
        function renderChildrenArray(request, task, children) {
          var totalChildren = children.length;
          for (var i = 0; i < totalChildren; i++) {
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
            try {
              renderNode(request, task, children[i]);
            } finally {
              task.treeContext = prevTreeContext;
            }
          }
        }
        function spawnNewSuspendedTask(request, task, x) {
          var segment = task.blockedSegment;
          var insertionIndex = segment.chunks.length;
          var newSegment = createPendingSegment(
            request,
            insertionIndex,
            null,
            segment.formatContext,
            // Adopt the parent segment's leading text embed
            segment.lastPushedText,
            // Assume we are text embedded at the trailing edge
            true
          );
          segment.children.push(newSegment);
          segment.lastPushedText = false;
          var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
          {
            if (task.componentStack !== null) {
              newTask.componentStack = task.componentStack.parent;
            }
          }
          var ping = newTask.ping;
          x.then(ping, ping);
        }
        function renderNode(request, task, node) {
          var previousFormatContext = task.blockedSegment.formatContext;
          var previousLegacyContext = task.legacyContext;
          var previousContext = task.context;
          var previousComponentStack = null;
          {
            previousComponentStack = task.componentStack;
          }
          try {
            return renderNodeDestructive(request, task, node);
          } catch (x) {
            resetHooksState();
            if (typeof x === "object" && x !== null && typeof x.then === "function") {
              spawnNewSuspendedTask(request, task, x);
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              return;
            } else {
              task.blockedSegment.formatContext = previousFormatContext;
              task.legacyContext = previousLegacyContext;
              task.context = previousContext;
              switchContext(previousContext);
              {
                task.componentStack = previousComponentStack;
              }
              throw x;
            }
          }
        }
        function erroredTask(request, boundary, segment, error2) {
          var errorDigest = logRecoverableError(request, error2);
          if (boundary === null) {
            fatalError(request, error2);
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              boundary.errorDigest = errorDigest;
              {
                captureBoundaryErrorDetailsDev(boundary, error2);
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function abortTaskSoft(task) {
          var request = this;
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          finishedTask(request, boundary, segment);
        }
        function abortTask(task, request, reason) {
          var boundary = task.blockedBoundary;
          var segment = task.blockedSegment;
          segment.status = ABORTED;
          if (boundary === null) {
            request.allPendingTasks--;
            if (request.status !== CLOSED) {
              request.status = CLOSED;
              if (request.destination !== null) {
                close(request.destination);
              }
            }
          } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
              boundary.forceClientRender = true;
              var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
              boundary.errorDigest = request.onError(_error);
              {
                var errorPrefix = "The server did not finish this Suspense boundary: ";
                if (_error && typeof _error.message === "string") {
                  _error = errorPrefix + _error.message;
                } else {
                  _error = errorPrefix + String(_error);
                }
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                  captureBoundaryErrorDetailsDev(boundary, _error);
                } finally {
                  currentTaskInDEV = previousTaskInDev;
                }
              }
              if (boundary.parentFlushed) {
                request.clientRenderedBoundaries.push(boundary);
              }
            }
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask(fallbackTask, request, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
              var onAllReady = request.onAllReady;
              onAllReady();
            }
          }
        }
        function queueCompletedSegment(boundary, segment) {
          if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) {
              queueCompletedSegment(boundary, childSegment);
            }
          } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
          }
        }
        function finishedTask(request, boundary, segment) {
          if (boundary === null) {
            if (segment.parentFlushed) {
              if (request.completedRootSegment !== null) {
                throw new Error("There can only be one root segment. This is a bug in React.");
              }
              request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            if (request.pendingRootTasks === 0) {
              request.onShellError = noop$1;
              var onShellReady = request.onShellReady;
              onShellReady();
            }
          } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender) ;
            else if (boundary.pendingTasks === 0) {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                }
              }
              if (boundary.parentFlushed) {
                request.completedBoundaries.push(boundary);
              }
              boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
              boundary.fallbackAbortableTasks.clear();
            } else {
              if (segment.parentFlushed) {
                if (segment.status === COMPLETED) {
                  queueCompletedSegment(boundary, segment);
                  var completedSegments = boundary.completedSegments;
                  if (completedSegments.length === 1) {
                    if (boundary.parentFlushed) {
                      request.partialBoundaries.push(boundary);
                    }
                  }
                }
              }
            }
          }
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
        function retryTask(request, task) {
          var segment = task.blockedSegment;
          if (segment.status !== PENDING) {
            return;
          }
          switchContext(task.context);
          var prevTaskInDEV = null;
          {
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = task;
          }
          try {
            renderNodeDestructive(request, task, task.node);
            pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request, task.blockedBoundary, segment);
          } catch (x) {
            resetHooksState();
            if (typeof x === "object" && x !== null && typeof x.then === "function") {
              var ping = task.ping;
              x.then(ping, ping);
            } else {
              task.abortSet.delete(task);
              segment.status = ERRORED;
              erroredTask(request, task.blockedBoundary, segment, x);
            }
          } finally {
            {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        }
        function performWork(request) {
          if (request.status === CLOSED) {
            return;
          }
          var prevContext = getActiveContext();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = Dispatcher;
          var prevGetCurrentStackImpl;
          {
            prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
            ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
          }
          var prevResponseState = currentResponseState;
          setCurrentResponseState(request.responseState);
          try {
            var pingedTasks = request.pingedTasks;
            var i;
            for (i = 0; i < pingedTasks.length; i++) {
              var task = pingedTasks[i];
              retryTask(request, task);
            }
            pingedTasks.splice(0, i);
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          } finally {
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            }
            if (prevDispatcher === Dispatcher) {
              switchContext(prevContext);
            }
          }
        }
        function flushSubtree(request, destination, segment) {
          segment.parentFlushed = true;
          switch (segment.status) {
            case PENDING: {
              var segmentID = segment.id = request.nextSegmentId++;
              segment.lastPushedText = false;
              segment.textEmbedded = false;
              return writePlaceholder(destination, request.responseState, segmentID);
            }
            case COMPLETED: {
              segment.status = FLUSHED;
              var r = true;
              var chunks = segment.chunks;
              var chunkIdx = 0;
              var children = segment.children;
              for (var childIdx = 0; childIdx < children.length; childIdx++) {
                var nextChild = children[childIdx];
                for (; chunkIdx < nextChild.index; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                r = flushSegment(request, destination, nextChild);
              }
              for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              if (chunkIdx < chunks.length) {
                r = writeChunkAndReturn(destination, chunks[chunkIdx]);
              }
              return r;
            }
            default: {
              throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
            }
          }
        }
        function flushSegment(request, destination, segment) {
          var boundary = segment.boundary;
          if (boundary === null) {
            return flushSubtree(request, destination, segment);
          }
          boundary.parentFlushed = true;
          if (boundary.forceClientRender) {
            writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
            flushSubtree(request, destination, segment);
            return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
          } else if (boundary.pendingTasks > 0) {
            boundary.rootSegmentID = request.nextSegmentId++;
            if (boundary.completedSegments.length > 0) {
              request.partialBoundaries.push(boundary);
            }
            var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
            writeStartPendingSuspenseBoundary(destination, request.responseState, id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else if (boundary.byteSize > request.progressiveChunkSize) {
            boundary.rootSegmentID = request.nextSegmentId++;
            request.completedBoundaries.push(boundary);
            writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
          } else {
            writeStartCompletedSuspenseBoundary(destination, request.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) {
              throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
            }
            var contentSegment = completedSegments[0];
            flushSegment(request, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary(destination, request.responseState);
          }
        }
        function flushClientRenderedBoundary(request, destination, boundary) {
          return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
        }
        function flushSegmentContainer(request, destination, segment) {
          writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
          flushSegment(request, destination, segment);
          return writeEndSegment(destination, segment.formatContext);
        }
        function flushCompletedBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i = 0;
          for (; i < completedSegments.length; i++) {
            var segment = completedSegments[i];
            flushPartiallyCompletedSegment(request, destination, boundary, segment);
          }
          completedSegments.length = 0;
          return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
        }
        function flushPartialBoundary(request, destination, boundary) {
          var completedSegments = boundary.completedSegments;
          var i = 0;
          for (; i < completedSegments.length; i++) {
            var segment = completedSegments[i];
            if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
              i++;
              completedSegments.splice(0, i);
              return false;
            }
          }
          completedSegments.splice(0, i);
          return true;
        }
        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
          if (segment.status === FLUSHED) {
            return true;
          }
          var segmentID = segment.id;
          if (segmentID === -1) {
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) {
              throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
            }
            return flushSegmentContainer(request, destination, segment);
          } else {
            flushSegmentContainer(request, destination, segment);
            return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
          }
        }
        function flushCompletedQueues(request, destination) {
          beginWriting();
          try {
            var completedRootSegment = request.completedRootSegment;
            if (completedRootSegment !== null && request.pendingRootTasks === 0) {
              flushSegment(request, destination, completedRootSegment);
              request.completedRootSegment = null;
              writeCompletedRoot(destination, request.responseState);
            }
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            var i;
            for (i = 0; i < clientRenderedBoundaries.length; i++) {
              var boundary = clientRenderedBoundaries[i];
              if (!flushClientRenderedBoundary(request, destination, boundary)) {
                request.destination = null;
                i++;
                clientRenderedBoundaries.splice(0, i);
                return;
              }
            }
            clientRenderedBoundaries.splice(0, i);
            var completedBoundaries = request.completedBoundaries;
            for (i = 0; i < completedBoundaries.length; i++) {
              var _boundary = completedBoundaries[i];
              if (!flushCompletedBoundary(request, destination, _boundary)) {
                request.destination = null;
                i++;
                completedBoundaries.splice(0, i);
                return;
              }
            }
            completedBoundaries.splice(0, i);
            completeWriting(destination);
            beginWriting(destination);
            var partialBoundaries = request.partialBoundaries;
            for (i = 0; i < partialBoundaries.length; i++) {
              var _boundary2 = partialBoundaries[i];
              if (!flushPartialBoundary(request, destination, _boundary2)) {
                request.destination = null;
                i++;
                partialBoundaries.splice(0, i);
                return;
              }
            }
            partialBoundaries.splice(0, i);
            var largeBoundaries = request.completedBoundaries;
            for (i = 0; i < largeBoundaries.length; i++) {
              var _boundary3 = largeBoundaries[i];
              if (!flushCompletedBoundary(request, destination, _boundary3)) {
                request.destination = null;
                i++;
                largeBoundaries.splice(0, i);
                return;
              }
            }
            largeBoundaries.splice(0, i);
          } finally {
            completeWriting(destination);
            if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
              {
                if (request.abortableTasks.size !== 0) {
                  error("There was still abortable task at the root when we closed. This is a bug in React.");
                }
              }
              close(destination);
            }
          }
        }
        function startWork(request) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
        function startFlowing(request, destination) {
          if (request.status === CLOSING) {
            request.status = CLOSED;
            closeWithError(destination, request.fatalError);
            return;
          }
          if (request.status === CLOSED) {
            return;
          }
          if (request.destination !== null) {
            return;
          }
          request.destination = destination;
          try {
            flushCompletedQueues(request, destination);
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function abort(request, reason) {
          try {
            var abortableTasks = request.abortableTasks;
            abortableTasks.forEach(function(task) {
              return abortTask(task, request, reason);
            });
            abortableTasks.clear();
            if (request.destination !== null) {
              flushCompletedQueues(request, request.destination);
            }
          } catch (error2) {
            logRecoverableError(request, error2);
            fatalError(request, error2);
          }
        }
        function renderToReadableStream(children, options) {
          return new Promise(function(resolve, reject) {
            var onFatalError;
            var onAllReady;
            var allReady = new Promise(function(res, rej) {
              onAllReady = res;
              onFatalError = rej;
            });
            function onShellReady() {
              var stream = new ReadableStream(
                {
                  type: "bytes",
                  pull: function(controller) {
                    startFlowing(request, controller);
                  },
                  cancel: function(reason) {
                    abort(request);
                  }
                },
                // $FlowFixMe size() methods are not allowed on byte streams.
                {
                  highWaterMark: 0
                }
              );
              stream.allReady = allReady;
              resolve(stream);
            }
            function onShellError(error2) {
              allReady.catch(function() {
              });
              reject(error2);
            }
            var request = createRequest(children, createResponseState(options ? options.identifierPrefix : void 0, options ? options.nonce : void 0, options ? options.bootstrapScriptContent : void 0, options ? options.bootstrapScripts : void 0, options ? options.bootstrapModules : void 0), createRootFormatContext(options ? options.namespaceURI : void 0), options ? options.progressiveChunkSize : void 0, options ? options.onError : void 0, onAllReady, onShellReady, onShellError, onFatalError);
            if (options && options.signal) {
              var signal = options.signal;
              var listener = function() {
                abort(request, signal.reason);
                signal.removeEventListener("abort", listener);
              };
              signal.addEventListener("abort", listener);
            }
            startWork(request);
          });
        }
        exports.renderToReadableStream = renderToReadableStream;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/server.browser.js
var require_server_browser = __commonJS({
  "node_modules/react-dom/server.browser.js"(exports) {
    "use strict";
    var l;
    var s;
    if (false) {
      l = null;
      s = null;
    } else {
      l = require_react_dom_server_legacy_browser_development();
      s = require_react_dom_server_browser_development();
    }
    exports.version = l.version;
    exports.renderToString = l.renderToString;
    exports.renderToStaticMarkup = l.renderToStaticMarkup;
    exports.renderToNodeStream = l.renderToNodeStream;
    exports.renderToStaticNodeStream = l.renderToStaticNodeStream;
    exports.renderToReadableStream = s.renderToReadableStream;
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module) {
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version2) {
      if (!version2) throw new Error('"version" cannot be null or undefined');
      if (version2 < 1 || version2 > 40) throw new Error('"version" should be in range from 1 to 40');
      return version2 * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
      return CODEWORDS_COUNT[version2];
    };
    exports.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f) {
      if (typeof f !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (let i = 0; i < length; i++) {
          this.putBit((num >>> length - i - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved) this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version2) {
      if (version2 === 1) return [];
      const posCount = Math.floor(version2 / 7) + 2;
      const size = getSymbolSize(version2);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i = 1; i < posCount - 1; i++) {
        positions[i] = positions[i - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version2) {
      const coords = [];
      const pos = exports.getRowColCoords(version2);
      const posLength = pos.length;
      for (let i = 0; i < posLength; i++) {
        for (let j = 0; j < posLength; j++) {
          if (i === 0 && j === 0 || // top-left
          i === 0 && j === posLength - 1 || // bottom-left
          i === posLength - 1 && j === 0) {
            continue;
          }
          coords.push([pos[i], pos[j]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version2) {
      const size = getSymbolSize(version2);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      const size = data.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];
      const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i, j) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i + j) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i + j) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i * j % 2 + i * j % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      const size = data.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col)) continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports.applyMask(p, data);
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x = 1;
      for (let i = 0; i < 255; i++) {
        EXP_TABLE[i] = x;
        LOG_TABLE[x] = i;
        x <<= 1;
        if (x & 256) {
          x ^= 285;
        }
      }
      for (let i = 255; i < 512; i++) {
        EXP_TABLE[i] = EXP_TABLE[i - 255];
      }
    })();
    exports.log = function log(n) {
      if (n < 1) throw new Error("log(" + n + ")");
      return LOG_TABLE[n];
    };
    exports.exp = function exp(n) {
      return EXP_TABLE[n];
    };
    exports.mul = function mul(x, y) {
      if (x === 0 || y === 0) return 0;
      return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var GF = require_galois_field();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i = 0; i < p1.length; i++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i + j] ^= GF.mul(p1[i], p2[j]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i = 0; i < divisor.length; i++) {
          result[i] ^= GF.mul(divisor[i], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0) offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i = 0; i < degree; i++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree) this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version2) {
      return !isNaN(version2) && version2 >= 1 && version2 <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version2) {
      if (!mode.ccBits) throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid version: " + version2);
      }
      if (version2 >= 1 && version2 < 10) return mode.ccBits[0];
      else if (version2 < 27) return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports.KANJI;
      else return exports.BYTE;
    };
    exports.toString = function toString(mode) {
      if (mode && mode.id) return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version2) {
      return Mode.getCharCountIndicator(mode, version2) + 4;
    }
    function getTotalBitsFromDataArray(segments, version2) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version2);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version2, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined") mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version2);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version2) {
      if (!VersionCheck.isValid(version2) || version2 < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d = version2 << 12;
      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
      }
      return version2 << 12 | d;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d = data << 10;
      while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
        d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
      }
      return (data << 10 | d) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i, group, value;
      for (i = 0; i + 3 <= this.data.length; i += 3) {
        group = this.data.substr(i, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i;
      if (remainingNum > 0) {
        group = this.data.substr(i);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i;
      for (i = 0; i + 2 <= this.data.length; i += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      if (typeof data === "string") {
        this.data = new TextEncoder().encode(data);
      } else {
        this.data = new Uint8Array(data);
      }
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i = 0, l = this.data.length; i < l; i++) {
        bitBuffer.put(this.data[i], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i;
      for (i = 0; i < this.data.length; i++) {
        let value = Utils.toSJIS(this.data[i]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version2) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i = 0; i < nodes.length; i++) {
        const nodeGroup = nodes[i];
        const currentNodeIds = [];
        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key = "" + i + j;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version2);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data, version2) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version2);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i = 1; i < path.length - 1; i++) {
        optimizedSegs.push(graph.table[path[i]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version2) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version2);
      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];
        for (let r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r) continue;
          for (let c = -1; c <= 7; c++) {
            if (col + c <= -1 || size <= col + c) continue;
            if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size = matrix.size;
      for (let r = 8; r < size - 8; r++) {
        const value = r % 2 === 0;
        matrix.set(r, 6, value, true);
        matrix.set(6, r, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version2) {
      const pos = AlignmentPattern.getPositions(version2);
      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];
        for (let r = -2; r <= 2; r++) {
          for (let c = -2; c <= 2; c++) {
            if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version2) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version2);
      let row, col, mod;
      for (let i = 0; i < 18; i++) {
        row = Math.floor(i / 3);
        col = i % 3 + size - 8 - 3;
        mod = (bits >> i & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i, mod;
      for (i = 0; i < 15; i++) {
        mod = (bits >> i & 1) === 1;
        if (i < 6) {
          matrix.set(i, 8, mod, true);
        } else if (i < 8) {
          matrix.set(i + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i, 8, mod, true);
        }
        if (i < 8) {
          matrix.set(8, size - i - 1, mod, true);
        } else if (i < 9) {
          matrix.set(8, 15 - i - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6) col--;
        while (true) {
          for (let c = 0; c < 2; c++) {
            if (!matrix.isReserved(row, col - c)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version2, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version2));
        data.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i = 0; i < remainingByte; i++) {
        buffer.put(i % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version2, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version2, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b = 0; b < ecTotalBlocks; b++) {
        const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b] = buffer.slice(offset, offset + dataSize);
        ecData[b] = rs.encode(dcData[b]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i, r;
      for (i = 0; i < maxDataSize; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i < dcData[r].length) {
            data[index++] = dcData[r][i];
          }
        }
      }
      for (i = 0; i < ecCount; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data[index++] = ecData[r][i];
        }
      }
      return data;
    }
    function createSymbol(data, version2, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version2;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version2) {
        version2 = bestVersion;
      } else if (version2 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version2, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version2);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version2);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version2);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version2 >= 7) {
        setupVersionInfo(modules, version2);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version2,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version2;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version2 = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version2, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
          return [c, c];
        }));
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i = 0; i < symbolSize; i++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i * symbolSize + j) * 4;
          let pxColor = opts.color.light;
          if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style) canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts) opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils2();
    function getColorAttrib(color2, attrib) {
      const alpha = color2.a / 255;
      const str = attrib + '="' + color2.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x, y) {
      let str = cmd + x;
      if (typeof y !== "undefined") str += " " + y;
      return str;
    }
    function qrToPath(data, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i = 0; i < data.length; i++) {
        const col = Math.floor(i % size);
        const row = Math.floor(i / size);
        if (!col && !newRow) newRow = true;
        if (data[i]) {
          lineLength++;
          if (!(i > 0 && col > 0 && data[i - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode2 = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text2, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text2;
          text2 = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text2;
            text2 = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text2 = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text2;
          text2 = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            const data = QRCode2.create(text2, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e) {
            reject(e);
          }
        });
      }
      try {
        const data = QRCode2.create(text2, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e) {
        cb(e);
      }
    }
    exports.create = QRCode2.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/@coinbase/onchainkit/dist/wallet/components/Wallet.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/Draggable/Draggable.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/Draggable/getBoundedPosition.js
function getBoundedPosition({
  draggableRef,
  position,
  minGapToEdge = 10
}) {
  var _a;
  const rect = (_a = draggableRef.current) == null ? void 0 : _a.getBoundingClientRect();
  if (!rect || typeof window === "undefined") {
    return position;
  }
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  const newX = Math.min(
    Math.max(minGapToEdge, position.x),
    viewportWidth - rect.width - minGapToEdge
  );
  const newY = Math.min(
    Math.max(minGapToEdge, position.y),
    viewportHeight - rect.height - minGapToEdge
  );
  return { x: newX, y: newY };
}

// node_modules/@coinbase/onchainkit/dist/internal/components/Draggable/useRepositionOnResize.js
var import_react = __toESM(require_react(), 1);
function useRespositionOnWindowResize(draggableRef, position, resetPosition) {
  const isElementInViewport = (0, import_react.useCallback)((rect) => {
    return rect.right <= window.innerWidth && rect.bottom <= window.innerHeight && rect.left >= 0 && rect.top >= 0;
  }, []);
  const repositionDraggable = (0, import_react.useCallback)(
    (rect, currentPosition) => {
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      let newX;
      let newY;
      if (rect.right > viewportWidth) {
        newX = viewportWidth - rect.width - 10;
      } else if (rect.left < 0) {
        newX = 10;
      } else {
        newX = currentPosition.x;
      }
      if (rect.bottom > viewportHeight) {
        newY = viewportHeight - rect.height - 10;
      } else if (rect.top < 0) {
        newY = 10;
      } else {
        newY = currentPosition.y;
      }
      return { x: newX, y: newY };
    },
    []
  );
  const handleWindowResize = (0, import_react.useCallback)(() => {
    if (!draggableRef.current) {
      return;
    }
    const el = draggableRef.current;
    const rect = el.getBoundingClientRect();
    const newPosition = repositionDraggable(rect, position);
    resetPosition(
      (currentPos) => isElementInViewport(rect) ? currentPos : newPosition
    );
  }, [
    draggableRef,
    position,
    repositionDraggable,
    resetPosition,
    isElementInViewport
  ]);
  (0, import_react.useEffect)(() => {
    window.addEventListener("resize", handleWindowResize);
    return () => window.removeEventListener("resize", handleWindowResize);
  }, [handleWindowResize]);
}

// node_modules/@coinbase/onchainkit/dist/internal/components/Draggable/Draggable.js
function Draggable({
  children,
  gridSize = 1,
  startingPosition = { x: 20, y: 20 },
  snapToGrid = false,
  disabled = false
}) {
  const [position, setPosition] = (0, import_react2.useState)(startingPosition);
  const [dragOffset, setDragOffset] = (0, import_react2.useState)({ x: 0, y: 0 });
  const [dragStartPosition, setDragStartPosition] = (0, import_react2.useState)({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = (0, import_react2.useState)(false);
  const draggableRef = (0, import_react2.useRef)(null);
  const calculateSnapToGrid = (0, import_react2.useCallback)(
    (positionValue) => {
      return Math.round(positionValue / gridSize) * gridSize;
    },
    [gridSize]
  );
  const handleDragStart = (0, import_react2.useCallback)(
    (e) => {
      if (disabled) {
        return;
      }
      setIsDragging(true);
      setDragStartPosition({ x: e.clientX, y: e.clientY });
      setDragOffset({
        x: e.clientX - position.x,
        y: e.clientY - position.y
      });
    },
    [position, disabled]
  );
  (0, import_react2.useEffect)(() => {
    if (!isDragging) {
      return;
    }
    const handleGlobalMove = (e) => {
      const newPosition = getBoundedPosition({
        draggableRef,
        position: {
          x: e.clientX - dragOffset.x,
          y: e.clientY - dragOffset.y
        }
      });
      setPosition(newPosition);
    };
    const handleGlobalEnd = (e) => {
      const moveDistance = Math.hypot(
        e.clientX - dragStartPosition.x,
        e.clientY - dragStartPosition.y
      );
      if (moveDistance > 2) {
        e.preventDefault();
        e.stopPropagation();
        const clickEvent = (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          document.removeEventListener("click", clickEvent, true);
        };
        document.addEventListener("click", clickEvent, true);
      }
      setPosition((prev) => ({
        x: snapToGrid ? calculateSnapToGrid(prev.x) : prev.x,
        y: snapToGrid ? calculateSnapToGrid(prev.y) : prev.y
      }));
      setIsDragging(false);
    };
    document.addEventListener("pointermove", handleGlobalMove);
    document.addEventListener("pointerup", handleGlobalEnd);
    return () => {
      document.removeEventListener("pointermove", handleGlobalMove);
      document.removeEventListener("pointerup", handleGlobalEnd);
    };
  }, [
    isDragging,
    dragOffset,
    snapToGrid,
    calculateSnapToGrid,
    dragStartPosition
  ]);
  useRespositionOnWindowResize(draggableRef, position, setPosition);
  return (0, import_jsx_runtime.jsx)(
    "div",
    {
      ref: draggableRef,
      "data-testid": "ockDraggable",
      className: cn(
        "fixed touch-none select-none",
        "cursor-grab active:cursor-grabbing"
      ),
      style: {
        left: `${position.x}px`,
        top: `${position.y}px`
      },
      onPointerDown: handleDragStart,
      children
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useOutsideClick.js
var import_react3 = __toESM(require_react(), 1);
function useOutsideClick(elRef, callback) {
  const handleClickOutside = (0, import_react3.useCallback)(
    (e) => {
      var _a;
      if (!elRef.current) {
        return;
      }
      const isOutsideClick = !elRef.current.contains(e.target);
      const eventPath = (_a = e.composedPath) == null ? void 0 : _a.call(e);
      const hasPortalOrigin = eventPath == null ? void 0 : eventPath.some(
        (el) => el instanceof HTMLElement && el.hasAttribute("data-portal-origin")
      );
      if (!hasPortalOrigin && isOutsideClick) {
        callback();
      }
    },
    [callback, elRef]
  );
  (0, import_react3.useEffect)(() => {
    document.addEventListener("click", handleClickOutside, { capture: true });
    return () => {
      document.removeEventListener("click", handleClickOutside, {
        capture: true
      });
    };
  }, [handleClickOutside]);
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/Wallet.js
var import_react74 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/utils/getDefaultDraggableStartingPosition.js
var MIN_GAP_TO_EDGE = 16;
var WALLET_ISLAND_SIZE = 56;
function getDefaultDraggableStartingPosition() {
  if (typeof window === "undefined") {
    return { x: 100, y: 100 };
  }
  return {
    x: window.innerWidth - WALLET_ISLAND_SIZE - MIN_GAP_TO_EDGE,
    y: window.innerHeight - WALLET_ISLAND_SIZE - MIN_GAP_TO_EDGE
  };
}

// node_modules/@coinbase/onchainkit/dist/wallet/utils/getWalletDraggableProps.js
function getWalletDraggableProps({
  draggable,
  draggableStartingPosition
}) {
  if (!draggable) {
    return { draggable };
  }
  return {
    draggable,
    draggableStartingPosition: draggableStartingPosition ?? getDefaultDraggableStartingPosition()
  };
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/ConnectWallet.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/components/ConnectButton.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function ConnectButton({
  className,
  connectWalletText,
  onClick,
  // Text will be deprecated in the future
  text: text$1
}) {
  return (0, import_jsx_runtime2.jsx)(
    "button",
    {
      type: "button",
      "data-testid": "ockConnectButton",
      className: cn(
        pressable.primary,
        border.radius,
        text.headline,
        color.inverse,
        "inline-flex min-w-[153px] items-center justify-center px-4 py-3",
        className
      ),
      onClick,
      children: connectWalletText ? connectWalletText : (0, import_jsx_runtime2.jsx)("span", { className: cn(color.inverse), children: text$1 })
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/ConnectWalletText.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
function ConnectWalletText({
  children,
  className
}) {
  return (0, import_jsx_runtime3.jsx)("span", { className: cn(text.headline, color.inverse, className), children });
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletModal.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/Dialog.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/DismissableLayer.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
function DismissableLayer({
  children,
  disableEscapeKey = false,
  disableOutsideClick = false,
  onDismiss,
  triggerRef,
  preventTriggerEvents = false
}) {
  const layerRef = (0, import_react4.useRef)(null);
  (0, import_react4.useEffect)(() => {
    if (disableOutsideClick && disableEscapeKey) {
      return;
    }
    const handleTriggerClick = (event) => {
      if (preventTriggerEvents) {
        event.preventDefault();
        event.stopPropagation();
      }
    };
    const isClickInsideLayer = (target) => {
      var _a;
      return (_a = layerRef.current) == null ? void 0 : _a.contains(target);
    };
    const handlePointerDownCapture = (event) => {
      var _a;
      if (disableOutsideClick) {
        return;
      }
      if (!(event.target instanceof Node)) {
        return;
      }
      const target = event.target;
      if ((_a = triggerRef == null ? void 0 : triggerRef.current) == null ? void 0 : _a.contains(target)) {
        handleTriggerClick(event);
        return;
      }
      if (!isClickInsideLayer(target)) {
        onDismiss == null ? void 0 : onDismiss();
      }
    };
    const handleKeyDown = (event) => {
      if (!disableEscapeKey && event.key === "Escape") {
        onDismiss == null ? void 0 : onDismiss();
      }
    };
    document.addEventListener("pointerdown", handlePointerDownCapture, true);
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener(
        "pointerdown",
        handlePointerDownCapture,
        true
      );
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [
    disableOutsideClick,
    disableEscapeKey,
    onDismiss,
    triggerRef,
    preventTriggerEvents
  ]);
  return (0, import_jsx_runtime4.jsx)("div", { "data-testid": "ockDismissableLayer", ref: layerRef, children });
}

// node_modules/@coinbase/onchainkit/dist/internal/components/FocusTrap.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var FOCUSABLE_ELEMENTS_SELECTOR = 'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])';
function FocusTrap({ active = true, children }) {
  const containerRef = (0, import_react5.useRef)(null);
  const previousFocusRef = (0, import_react5.useRef)(null);
  (0, import_react5.useEffect)(() => {
    if (!active) {
      return;
    }
    previousFocusRef.current = document.activeElement;
    if (containerRef.current) {
      const firstFocusable = containerRef.current.querySelector(
        FOCUSABLE_ELEMENTS_SELECTOR
      );
      firstFocusable == null ? void 0 : firstFocusable.focus();
    }
    return () => {
      var _a;
      (_a = previousFocusRef.current) == null ? void 0 : _a.focus();
    };
  }, [active]);
  const getFocusableElements = () => {
    var _a;
    return (_a = containerRef.current) == null ? void 0 : _a.querySelectorAll(
      FOCUSABLE_ELEMENTS_SELECTOR
    );
  };
  const handleTabNavigation = (event, elements) => {
    const firstElement = elements[0];
    const lastElement = elements[elements.length - 1];
    const isFirstElement = document.activeElement === firstElement;
    const isLastElement = document.activeElement === lastElement;
    if (event.shiftKey && isFirstElement) {
      event.preventDefault();
      lastElement.focus();
    } else if (!event.shiftKey && isLastElement) {
      event.preventDefault();
      firstElement.focus();
    }
  };
  const handleKeyDown = (event) => {
    if (!active || event.key !== "Tab") {
      return;
    }
    const focusableElements = getFocusableElements();
    if (!(focusableElements == null ? void 0 : focusableElements.length)) {
      return;
    }
    handleTabNavigation(event, focusableElements);
  };
  return (0, import_jsx_runtime5.jsx)(
    "div",
    {
      "data-testid": "ockFocusTrap",
      onKeyDown: handleKeyDown,
      ref: containerRef,
      children
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/internal/components/Dialog.js
function Dialog({
  children,
  isOpen,
  modal = true,
  onClose,
  "aria-label": ariaLabel,
  "aria-labelledby": ariaLabelledby,
  "aria-describedby": ariaDescribedby
}) {
  const componentTheme = useTheme();
  const dialogRef = (0, import_react6.useRef)(null);
  if (!isOpen) {
    return null;
  }
  const dialog = (0, import_jsx_runtime6.jsx)(
    "div",
    {
      className: cn(
        componentTheme,
        zIndex.modal,
        "fixed inset-0 flex items-center justify-center",
        "bg-black/50 transition-opacity duration-200",
        "fade-in animate-in duration-200"
      ),
      "data-portal-origin": "true",
      children: (0, import_jsx_runtime6.jsx)(FocusTrap, { active: isOpen, children: (0, import_jsx_runtime6.jsx)(DismissableLayer, { onDismiss: onClose, children: (0, import_jsx_runtime6.jsx)(
        "div",
        {
          "aria-describedby": ariaDescribedby,
          "aria-label": ariaLabel,
          "aria-labelledby": ariaLabelledby,
          "aria-modal": modal,
          className: "zoom-in-95 animate-in duration-200",
          "data-testid": "ockDialog",
          onClick: (e) => e.stopPropagation(),
          onKeyDown: (e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.stopPropagation();
            }
          },
          ref: dialogRef,
          role: "dialog",
          children
        }
      ) }) })
    }
  );
  return (0, import_react_dom.createPortal)(dialog, document.body);
}

// node_modules/@coinbase/onchainkit/dist/internal/svg/coinbaseWalletSvg.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var coinbaseWalletSvg = (0, import_jsx_runtime7.jsxs)(
  "svg",
  {
    width: "100%",
    height: "100%",
    viewBox: "0 0 146 146",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    role: "img",
    "aria-label": "Coinbase Wallet Logo",
    children: [
      (0, import_jsx_runtime7.jsx)("title", { children: "Coinbase Wallet Logo" }),
      (0, import_jsx_runtime7.jsx)("rect", { width: "146", height: "146", fill: "#0052FF" }),
      (0, import_jsx_runtime7.jsx)(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M21.9 73C21.9 102.053 45.1466 125.3 74.2 125.3C103.253 125.3 126.5 102.053 126.5 73C126.5 43.9466 103.253 20.7 74.2 20.7C45.1466 20.7 21.9 43.9466 21.9 73ZM60.5 54.75C58.5673 54.75 57 56.3173 57 58.25V87.75C57 89.6827 58.5673 91.25 60.5 91.25H87.9C89.8327 91.25 91.4 89.6827 91.4 87.75V58.25C91.4 56.3173 89.8327 54.75 87.9 54.75H60.5Z",
          fill: "white"
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/frameWalletSvg.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var frameWalletSvg = (0, import_jsx_runtime8.jsxs)(
  "svg",
  {
    width: "100%",
    height: "100%",
    viewBox: "0 0 307.5 306",
    xmlns: "http://www.w3.org/2000/svg",
    role: "img",
    "aria-labelledby": "frameWallet",
    children: [
      (0, import_jsx_runtime8.jsx)("title", { id: "frameWalletTitle", children: "Frame Wallet Logo" }),
      (0, import_jsx_runtime8.jsx)("rect", { width: "100%", height: "100%", fill: "#28272a" }),
      (0, import_jsx_runtime8.jsx)(
        "path",
        {
          fill: "#00d2be",
          transform: "translate(77, 76.5)",
          d: "M145.1,75.6V17.6c0-5.1-4.2-9.3-9.3-9.3h-58.1c-.6,0-1.1-.2-1.6-.6l-7-7c-.4-.4-1-.7-1.6-.7H9.3C4.2,0,0,4.1,0,9.3h0v58c0,.6.2,1.1.6,1.6l7,7c.4.4.7,1,.7,1.6v58c0,5.1,4.2,9.3,9.3,9.3h58.2c.6,0,1.1.2,1.6.6l7,7c.4.4,1,.6,1.6.6h58.2c5.1,0,9.3-4.1,9.3-9.3h0v-58c0-.6-.2-1.1-.6-1.6l-7-7c-.5-.4-.8-.9-.8-1.5ZM105.6,106.6h-57.7c-.7,0-1.3-.6-1.3-1.3v-57.6c0-.7.6-1.3,1.3-1.3h57.7c.7,0,1.3.6,1.3,1.3v57.6c.1.7-.5,1.3-1.3,1.3Z"
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/metamaskSvg.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var metamaskSvg = (0, import_jsx_runtime9.jsxs)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    xmlSpace: "preserve",
    viewBox: "0 0 204.8 192.4",
    width: "100%",
    height: "100%",
    role: "img",
    "aria-hidden": "true",
    children: [
      (0, import_jsx_runtime9.jsx)("title", { children: "MetaMask Logo" }),
      (0, import_jsx_runtime9.jsx)("style", { children: ".st1{fill:#f5841f}.st2{fill:#e27625}.st3{fill:#d7c1b3}.st4{fill:#2f343b}.st5{fill:#cc6228}.st7{fill:#763e1a}" }),
      (0, import_jsx_runtime9.jsx)(
        "path",
        {
          id: "MM_Head_background__x28_Do_not_edit_x29_",
          d: "m167.4 96.1 6.9-8.1-3-2.2 4.8-4.4-3.7-2.8 4.8-3.6-3.1-2.4 5-24.4-7.6-22.6m0 0-48.8 18.1H82L33.2 25.6l.3.2-.3-.2-7.6 22.6 5.1 24.4-3.2 2.4 4.9 3.6-3.7 2.8 4.8 4.4-3 2.2 6.9 8.1-10.5 32.4 9.7 33.1 34.1-9.4v-.1.1l6.6 5.4 13.5 9.2h23.1l13.5-9.2 6.6-5.4 34.2 9.4 9.8-33.1-10.6-32.4m-96.7 56",
          className: "st1"
        }
      ),
      (0, import_jsx_runtime9.jsxs)("g", { id: "Logos", children: [
        (0, import_jsx_runtime9.jsx)(
          "path",
          {
            d: "m171.5 25.6-59.9 44.1 11.1-26zM33.2 25.6l59.4 44.5L82 43.7zM150 127.9l-16 24.2 34.2 9.4 9.8-33.1zM26.9 128.4l9.7 33.1 34.1-9.4-15.9-24.2z",
            className: "st2"
          }
        ),
        (0, import_jsx_runtime9.jsx)(
          "path",
          {
            d: "m68.9 86.9-9.5 14.3 33.8 1.5-1.1-36.2zM135.9 86.9l-23.6-20.8-.7 36.6 33.8-1.5zM70.7 152.1l20.5-9.8-17.7-13.6zM113.6 142.3l20.4 9.8-2.8-23.4z",
            className: "st2"
          }
        ),
        (0, import_jsx_runtime9.jsx)(
          "path",
          {
            d: "m134 152.1-20.4-9.8 1.7 13.2-.2 5.6zM70.7 152.1l19 9-.1-5.6 1.6-13.2z",
            className: "st3"
          }
        ),
        (0, import_jsx_runtime9.jsx)(
          "path",
          {
            d: "M90 119.9 73.1 115l12-5.5zM114.7 119.9l5-10.4 12 5.5z",
            className: "st4"
          }
        ),
        (0, import_jsx_runtime9.jsx)(
          "path",
          {
            d: "m70.7 152.1 3-24.2-18.9.5zM131.1 127.9l2.9 24.2 16-23.7zM145.4 101.2l-33.8 1.5 3.1 17.2 5-10.4 12 5.5zM73.1 115l12-5.5 4.9 10.4 3.2-17.2-33.8-1.5z",
            className: "st5"
          }
        ),
        (0, import_jsx_runtime9.jsx)(
          "path",
          {
            d: "m59.4 101.2 14.1 27.5-.4-13.7zM131.7 115l-.5 13.7 14.2-27.5zM93.2 102.7 90 119.9l4 20.4.9-26.8zM111.6 102.7l-1.7 10.7.8 26.9 4-20.4z",
            className: "st2"
          }
        ),
        (0, import_jsx_runtime9.jsx)(
          "path",
          {
            d: "m114.7 119.9-4 20.4 2.9 2 17.6-13.6.5-13.7zM73.1 115l.4 13.7 17.7 13.6 2.8-2-4-20.4z",
            className: "st1"
          }
        ),
        (0, import_jsx_runtime9.jsx)(
          "path",
          {
            d: "m115.1 161.1.2-5.6-1.6-1.3H91l-1.4 1.3.1 5.6-19-9 6.6 5.4 13.5 9.3h23.1l13.5-9.3 6.6-5.4z",
            style: {
              fill: "#c0ad9e"
            }
          }
        ),
        (0, import_jsx_runtime9.jsx)(
          "path",
          {
            d: "m113.6 142.3-2.9-2H94l-2.8 2-1.6 13.2 1.4-1.3h22.7l1.6 1.3z",
            className: "st4"
          }
        ),
        (0, import_jsx_runtime9.jsx)(
          "path",
          {
            d: "m174.1 72.6 5-24.4-7.6-22.6-57.9 42.6 22.3 18.7 31.5 9.2 6.9-8.1-3-2.2 4.8-4.3-3.7-2.9 4.8-3.6zM25.6 48.2l5.1 24.4-3.2 2.4 4.8 3.7-3.7 2.8 4.8 4.3-3 2.2 7 8.1 31.5-9.2 22.3-18.7-58-42.6z",
            className: "st7"
          }
        ),
        (0, import_jsx_runtime9.jsx)(
          "path",
          {
            d: "m167.4 96.1-31.5-9.2 9.5 14.3-14.2 27.5 18.8-.3h28zM68.9 86.9l-31.5 9.2-10.5 32.3h27.9l18.7.3-14.1-27.5zM111.6 102.7l2-34.5 9.1-24.5H82l9.2 24.5 2 34.5.8 10.8v26.8h16.7l.1-26.8z",
            className: "st1"
          }
        )
      ] })
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/phantomSvg.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var phantomSvg = (0, import_jsx_runtime10.jsxs)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 146 146",
    width: "100%",
    height: "100%",
    role: "img",
    "aria-label": "Phantom Logo",
    children: [
      (0, import_jsx_runtime10.jsx)("title", { children: "Phantom Logo" }),
      (0, import_jsx_runtime10.jsxs)("g", { clipPath: "url(#clip0_phantom)", children: [
        (0, import_jsx_runtime10.jsx)("rect", { width: "146", height: "146", rx: "31.3", fill: "#AB9FF2" }),
        (0, import_jsx_runtime10.jsx)(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M62.92 94.85C57.19 103.66 47.58 114.75 34.79 114.75C28.76 114.75 22.95 112.28 22.95 101.45C22.95 73.97 60.51 31.37 95.38 31.37C115.19 31.37 123.11 45.13 123.11 60.77C123.11 80.81 110.11 103.74 97.15 103.74C93.05 103.74 91.06 101.45 91.06 97.91C91.06 96.98 91.21 95.98 91.52 94.85C87.11 102.41 78.57 109.41 70.6 109.41C64.75 109.41 61.83 105.85 61.83 100.63C61.83 98.77 62.22 96.82 62.92 94.85ZM110.03 60.23C110.03 64.75 107.36 67.03 104.37 67.03C101.31 67.03 98.65 64.75 98.65 60.23C98.65 55.66 101.31 53.38 104.37 53.38C107.36 53.38 110.03 55.66 110.03 60.23ZM92.96 60.23C92.96 64.75 90.29 67.03 87.3 67.03C84.24 67.03 81.58 64.75 81.58 60.23C81.58 55.66 84.24 53.38 87.3 53.38C90.29 53.38 92.96 55.66 92.96 60.23Z",
            fill: "#FFFDF8"
          }
        )
      ] }),
      (0, import_jsx_runtime10.jsx)("defs", { children: (0, import_jsx_runtime10.jsx)("clipPath", { id: "clip0_phantom", children: (0, import_jsx_runtime10.jsx)("rect", { width: "146", height: "146", fill: "white" }) }) })
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/rabbySvg.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var rabbySvg = (0, import_jsx_runtime11.jsxs)(
  "svg",
  {
    width: "100%",
    height: "100%",
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    role: "img",
    "aria-label": "Rabby Wallet Logo",
    children: [
      (0, import_jsx_runtime11.jsx)("title", { children: "Rabby Wallet Logo" }),
      (0, import_jsx_runtime11.jsx)("rect", { width: "12", height: "12", rx: "3", fill: "#EBEDFB" }),
      (0, import_jsx_runtime11.jsxs)("g", { transform: "translate(0, 0.5) scale(1.1)", children: [
        (0, import_jsx_runtime11.jsx)(
          "path",
          {
            d: "M9.5721 5.7499C9.8866 5.0840 8.1892 3.2154 6.6954 2.3823C5.7598 1.7563 4.7717 1.8401 4.5853 2.1245C4.1549 2.7226 6.0967 3.2520 7.3950 3.8558C7.1472 3.9764 6.8946 4.1838 6.7517 4.4371C6.2874 3.9280 5.2613 3.5014 4.1590 3.8558C3.4854 4.1008 2.7626 4.6852 2.5094 5.5135C2.4467 5.4869 2.3767 5.4710 2.2998 5.4710C2.0064 5.4710 1.7717 5.7096 1.7717 6.0073C1.7717 6.3050 2.0064 6.5436 2.2998 6.5436C2.3507 6.5436 2.5170 6.5076 2.5170 6.5076L4.7717 6.5245C3.9726 8.2040 3.2103 8.4080 3.2103 8.6630C3.2103 8.9180 3.9180 8.8361 4.2186 8.7263C5.7352 8.2146 7.0660 6.6879 7.2942 6.2246C8.3475 6.3688 9.2166 6.3847 9.5721 5.7499Z",
            fill: "#8697FF"
          }
        ),
        (0, import_jsx_runtime11.jsx)(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M7.3944 3.8557C7.3945 3.8557 7.3946 3.8558 7.3947 3.8558C7.4548 3.8352 7.4461 3.7506 7.4322 3.6805C7.3994 3.5201 6.7746 2.9261 6.2170 2.6612C5.5215 2.2965 4.9374 2.3152 4.8514 2.4833C4.9937 2.8066 5.7640 3.1063 6.5395 3.4180C6.8882 3.5549 7.2351 3.6939 7.3944 3.8557C7.3944 3.8558 7.3944 3.8558 7.3944 3.8557Z",
            fill: "#8697FF"
          }
        ),
        (0, import_jsx_runtime11.jsx)(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M6.2552 7.0712C6.0818 7.0112 5.8933 6.9557 5.6818 6.9061C5.9029 6.5393 5.9510 5.9690 5.7525 5.6028C5.4532 5.1042 5.0556 4.8282 4.2115 4.8282C3.7200 4.8282 2.4599 4.9821 2.4356 6.0102C2.4331 6.1179 2.4356 6.2153 2.4439 6.3080L4.7714 6.5241C4.4672 6.7734 4.1652 7.1284 3.9000 7.4078C4.2305 7.4836 4.4899 7.5487 4.6998 7.6068C4.8768 7.6612 5.0481 7.7126 5.2313 7.7649C5.5162 7.5397 5.8350 7.3024 6.2552 7.0712Z",
            fill: "#465EED"
          }
        ),
        (0, import_jsx_runtime11.jsx)(
          "path",
          {
            d: "M2.3571 6.1987C2.4479 6.9744 2.9092 7.2696 3.8618 7.3599C4.8144 7.4503 5.3088 7.3884 5.9936 7.4515C6.5898 7.5047 7.0868 7.7870 7.2760 7.6875C7.4406 7.5982 7.3425 7.2733 7.1116 7.0716C6.8062 6.7917 6.4008 6.6022 5.6997 6.5353C5.8437 6.1454 5.8044 5.5937 5.6040 5.2915C5.3096 4.8564 4.7516 4.6586 3.9000 4.7439C3.2649 4.8316 2.6828 5.2346 2.3571 6.1987Z",
            fill: "#6277F1"
          }
        )
      ] })
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/trustWalletSvg.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var trustWalletSvg = (0, import_jsx_runtime12.jsxs)(
  "svg",
  {
    width: "100%",
    height: "100%",
    viewBox: "0 0 2500 2500",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: cn("text-foreground"),
    "aria-labelledby": "trustWallet",
    children: [
      (0, import_jsx_runtime12.jsx)("title", { id: "trustWalletTitle", children: "Trust Wallet Logo" }),
      (0, import_jsx_runtime12.jsx)(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M84.1,426.3C-1,593.5-1,812.7-1,1250c0,438.4,0,656.5,85.1,823.7c75.1,147.1,195.2,266.2,341.3,341.3   C592.5,2500,811.7,2500,1249,2500c438.4,0,656.5,0,823.7-85.1c147.1-75.1,266.2-195.2,341.3-341.3   c85.1-167.1,85.1-386.3,85.1-823.7c0-438.4,0-656.5-85.1-823.7c-75.1-147.1-195.2-266.2-341.3-341.3C1905.5,0,1686.3,0,1249,0   C810.6,0,592.5,0,425.3,85.1C278.2,160.1,159.1,280.2,84.1,426.3z M1874.5,674.5c22,0,43,9,58,24c15,16,24,37,23,58   c-4,233.2-13,411.3-30,552.4c-16,141.1-41,246.2-78.1,330.3c-25,57-56,104.1-92.1,143.1c-49,53-105.1,91.1-166.1,127.1   c-26,16-53,31-82.1,47c-61,34-127.1,72.1-203.2,123.1c-27,18-63.1,18-90.1,0c-77.1-51-144.1-89.1-205.2-124.1c-14-8-27-15-40-23   c-71.1-41-136.1-81.1-192.2-138.1c-38-38-70.1-83.1-96.1-138.1c-35-73.1-59-161.1-77.1-274.2c-23-152.1-35-351.3-39-627.5   c0-21,8-43,23-58s36-24,58-24h34c104.1,0,332.3-10,530.4-164.1c29-23,70.1-23,100.1,0c198.2,154.1,426.3,164.1,530.4,164.1h34   V674.5z M1692.4,1588.3c25-52,47-125.1,63.1-229.2c19-124.1,31-293.2,36-523.4c-122.1-4-331.3-27-531.4-161.1   c-200.2,134.1-409.3,157.1-530.4,161.1c4,190.2,13,338.3,27,454.4c16,132.1,38,221.2,66.1,284.2c18,42,39,72.1,63.1,98.1   c32,36,73.1,65.1,129.1,98.1c23,14,49,28,77.1,44c50,28,106.1,60,170.1,100.1c62-40,118.1-71.1,167.1-99.1c15-8,29-16,42-24   c69.1-39,120.1-72.1,157.1-111.1c25-26,46-55,65.1-94.1L1692.4,1588.3z",
          fill: "#3375BB"
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletModal.js
var import_react7 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/utils/checkWalletAndRedirect.js
function isWalletInstalled(walletType) {
  var _a, _b, _c, _d;
  if (typeof window === "undefined") {
    return false;
  }
  if (!window.ethereum) {
    if (walletType === "phantom") {
      return !!((_b = (_a = window.phantom) == null ? void 0 : _a.ethereum) == null ? void 0 : _b.isPhantom);
    }
    return false;
  }
  switch (walletType) {
    case "phantom":
      return !!((_d = (_c = window.phantom) == null ? void 0 : _c.ethereum) == null ? void 0 : _d.isPhantom) || !!window.ethereum.isPhantom;
    case "rabby":
      return !!window.ethereum.isRabby;
    case "trust":
      return !!window.ethereum.isTrust || !!window.ethereum.isTrustWallet;
    case "frame":
      return !!window.ethereum.isFrame;
    default:
      return false;
  }
}
var WALLET_INSTALL_URLS = {
  phantom: "https://phantom.app/download",
  rabby: "https://rabby.io",
  trust: "https://trustwallet.com/download",
  frame: "https://frame.sh"
};
function redirectToWalletInstall(walletType) {
  const url = WALLET_INSTALL_URLS[walletType];
  if (!url) {
    return false;
  }
  window.open(url, "_blank", "noopener,noreferrer");
  return true;
}
function checkWalletAndRedirect(walletType) {
  const isInstalled = isWalletInstalled(walletType);
  if (!isInstalled) {
    redirectToWalletInstall(walletType);
  }
  return isInstalled;
}

// node_modules/@coinbase/onchainkit/dist/internal/svg/baseAccountSvg.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
function BaseAccountSvg() {
  var _a, _b;
  const preferredMode = usePreferredColorScheme();
  const config = useOnchainKit();
  const mode = (_b = (_a = config.config) == null ? void 0 : _a.appearance) == null ? void 0 : _b.mode;
  const isDarkMode = mode === "dark" || mode === "auto" && preferredMode === "dark";
  return (0, import_jsx_runtime13.jsxs)(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "16",
      height: "16",
      fill: "none",
      "aria-label": "Base Account logo",
      children: [
        (0, import_jsx_runtime13.jsx)("title", { children: "Base Account logo" }),
        (0, import_jsx_runtime13.jsx)(
          "path",
          {
            fill: isDarkMode ? "#FFF" : "#00F",
            d: "M0 2.014c0-.433 0-.65.082-.816A.8.8 0 0 1 .448.832C.615.75.831.75 1.264.75h13.472c.433 0 .65 0 .816.082a.8.8 0 0 1 .366.366c.082.167.082.383.082.816v13.472c0 .433 0 .65-.082.816a.8.8 0 0 1-.366.366c-.167.082-.383.082-.816.082H1.264c-.433 0-.65 0-.816-.082a.8.8 0 0 1-.366-.366C0 16.135 0 15.919 0 15.486V2.014Z"
          }
        )
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletModal.js
function WalletModal({
  className,
  isOpen,
  onClose,
  onError
}) {
  var _a, _b, _c, _d, _e, _f;
  const { connect } = useConnect();
  const { config } = useOnchainKit();
  const appLogo = ((_a = config == null ? void 0 : config.appearance) == null ? void 0 : _a.logo) ?? void 0;
  const appName = ((_b = config == null ? void 0 : config.appearance) == null ? void 0 : _b.name) ?? void 0;
  const privacyPolicyUrl = ((_c = config == null ? void 0 : config.wallet) == null ? void 0 : _c.privacyUrl) ?? void 0;
  const termsOfServiceUrl = ((_d = config == null ? void 0 : config.wallet) == null ? void 0 : _d.termsUrl) ?? void 0;
  const supportedWallets = ((_e = config == null ? void 0 : config.wallet) == null ? void 0 : _e.supportedWallets) ?? {
    rabby: false,
    trust: false,
    frame: false
  };
  const isSignUpEnabled = ((_f = config == null ? void 0 : config.wallet) == null ? void 0 : _f.signUpEnabled) ?? true;
  const handleBaseAccountConnection = (0, import_react7.useCallback)(() => {
    try {
      connect({
        connector: baseAccount({
          appName,
          appLogoUrl: appLogo
        })
      });
      onClose();
    } catch (error) {
      console.error("Base Account connection error:", error);
      if (onError) {
        onError(
          error instanceof Error ? error : new Error("Failed to connect wallet")
        );
      }
    }
  }, [appName, appLogo, connect, onClose, onError]);
  const handleCoinbaseWalletConnection = (0, import_react7.useCallback)(() => {
    try {
      const cbConnector = coinbaseWallet({
        preference: "all",
        appName,
        appLogoUrl: appLogo
      });
      connect({ connector: cbConnector });
      onClose();
    } catch (error) {
      console.error("Coinbase Wallet connection error:", error);
      if (onError) {
        onError(
          error instanceof Error ? error : new Error("Failed to connect wallet")
        );
      }
    }
  }, [appName, appLogo, connect, onClose, onError]);
  const handleMetaMaskConnection = (0, import_react7.useCallback)(() => {
    try {
      const metamaskConnector = metaMask({
        dappMetadata: {
          name: appName || "OnchainKit App",
          url: window.location.origin,
          iconUrl: appLogo
        }
      });
      connect({ connector: metamaskConnector });
      onClose();
    } catch (error) {
      console.error("MetaMask connection error:", error);
      onError == null ? void 0 : onError(
        error instanceof Error ? error : new Error("Failed to connect wallet")
      );
    }
  }, [connect, onClose, onError, appName, appLogo]);
  const handlePhantomConnection = (0, import_react7.useCallback)(() => {
    try {
      if (!checkWalletAndRedirect("phantom")) {
        onClose();
        return;
      }
      const phantomConnector = injected({
        target: "phantom"
      });
      connect({ connector: phantomConnector });
      onClose();
    } catch (error) {
      console.error("Phantom connection error:", error);
      onError == null ? void 0 : onError(
        error instanceof Error ? error : new Error("Failed to connect wallet")
      );
    }
  }, [connect, onClose, onError]);
  const handleRabbyConnection = (0, import_react7.useCallback)(() => {
    try {
      if (!checkWalletAndRedirect("rabby")) {
        onClose();
        return;
      }
      const rabbyConnector = injected({
        target: "rabby"
      });
      connect({ connector: rabbyConnector });
      onClose();
    } catch (error) {
      console.error("Rabby connection error:", error);
      onError == null ? void 0 : onError(
        error instanceof Error ? error : new Error("Failed to connect wallet")
      );
    }
  }, [connect, onClose, onError]);
  const handleTrustWalletConnection = (0, import_react7.useCallback)(() => {
    try {
      if (!checkWalletAndRedirect("trust")) {
        onClose();
        return;
      }
      const trustConnector = injected({
        target: "trust"
      });
      connect({ connector: trustConnector });
      onClose();
    } catch (error) {
      console.error("Trust Wallet connection error:", error);
      onError == null ? void 0 : onError(
        error instanceof Error ? error : new Error("Failed to connect wallet")
      );
      onClose();
    }
  }, [connect, onClose, onError]);
  const handleFrameWalletConnection = (0, import_react7.useCallback)(() => {
    var _a2;
    try {
      if (!((_a2 = window.ethereum) == null ? void 0 : _a2.isFrame)) {
        window.open("https://frame.sh/download", "_blank");
        onClose();
        return;
      }
      const frameConnector = injected();
      connect({ connector: frameConnector });
      onClose();
    } catch (error) {
      console.error("Frame Wallet connection error:", error);
      onError == null ? void 0 : onError(
        error instanceof Error ? error : new Error("Failed to connect wallet")
      );
      onClose();
    }
  }, [connect, onClose, onError]);
  const availableWallets = [
    {
      id: "base-account",
      name: "Base",
      icon: (0, import_jsx_runtime14.jsx)(BaseAccountSvg, {}),
      connector: handleBaseAccountConnection,
      enabled: true
    },
    {
      id: "coinbase",
      name: "Coinbase Wallet",
      icon: coinbaseWalletSvg,
      connector: handleCoinbaseWalletConnection,
      enabled: true
    },
    {
      id: "metamask",
      name: "MetaMask",
      icon: metamaskSvg,
      connector: handleMetaMaskConnection,
      enabled: true
    },
    {
      id: "phantom",
      name: "Phantom",
      icon: phantomSvg,
      connector: handlePhantomConnection,
      enabled: true
    },
    {
      id: "rabby",
      name: "Rabby",
      icon: rabbySvg,
      connector: handleRabbyConnection,
      enabled: supportedWallets.rabby === true
    },
    {
      id: "trust",
      name: "Trust Wallet",
      icon: trustWalletSvg,
      connector: handleTrustWalletConnection,
      enabled: supportedWallets.trust === true
    },
    {
      id: "frame",
      name: "Frame",
      icon: frameWalletSvg,
      connector: handleFrameWalletConnection,
      enabled: supportedWallets.frame === true
    }
  ].filter((wallet) => wallet.enabled);
  return (0, import_jsx_runtime14.jsx)(Dialog, { isOpen, onClose, "aria-label": "Connect Wallet", children: (0, import_jsx_runtime14.jsxs)(
    "div",
    {
      "data-testid": "ockModalOverlay",
      className: cn(
        border.lineDefault,
        border.radius,
        background.default,
        "w-[22rem] p-6 pb-4",
        "relative flex flex-col items-center gap-4",
        className
      ),
      children: [
        (0, import_jsx_runtime14.jsx)(
          "button",
          {
            type: "button",
            onClick: onClose,
            className: cn(
              pressable.default,
              border.radius,
              border.default,
              "absolute top-4 right-4",
              "flex items-center justify-center p-1",
              "transition-colors duration-200"
            ),
            "aria-label": "Close modal",
            children: (0, import_jsx_runtime14.jsx)("div", { className: cn("flex h-4 w-4 items-center justify-center"), children: (0, import_jsx_runtime14.jsx)(CloseSvg, {}) })
          }
        ),
        (appLogo || appName) && (0, import_jsx_runtime14.jsxs)("div", { className: "flex w-full flex-col items-center gap-2 py-3", children: [
          appLogo && (0, import_jsx_runtime14.jsx)("div", { className: cn(border.radius, "h-14 w-14 overflow-hidden"), children: (0, import_jsx_runtime14.jsx)(
            "img",
            {
              src: appLogo,
              alt: `${appName || "App"} icon`,
              className: "h-full w-full object-cover"
            }
          ) }),
          appName && (0, import_jsx_runtime14.jsx)(
            "h2",
            {
              className: cn(text.headline, color.foreground, "text-center"),
              children: appName
            }
          )
        ] }),
        (0, import_jsx_runtime14.jsxs)("div", { className: "flex w-full flex-col gap-3", children: [
          isSignUpEnabled && (0, import_jsx_runtime14.jsxs)(
            "button",
            {
              type: "button",
              onClick: handleCoinbaseWalletConnection,
              className: cn(
                border.radius,
                text.body,
                pressable.alternate,
                color.foreground,
                "flex items-center justify-between px-4 py-3 text-left"
              ),
              children: [
                "Sign up",
                (0, import_jsx_runtime14.jsx)("div", { className: "h-4 w-4", children: defaultAvatarSVG })
              ]
            }
          ),
          (0, import_jsx_runtime14.jsxs)("div", { className: "relative", children: [
            isSignUpEnabled && (0, import_jsx_runtime14.jsx)("div", { className: "absolute inset-0 flex items-center", children: (0, import_jsx_runtime14.jsx)(
              "div",
              {
                className: cn(border.lineDefault, "w-full border-[0.5px]")
              }
            ) }),
            (0, import_jsx_runtime14.jsx)("div", { className: "relative flex justify-center", children: (0, import_jsx_runtime14.jsx)(
              "span",
              {
                className: cn(
                  background.default,
                  color.foregroundMuted,
                  text.legal,
                  "px-2"
                ),
                children: isSignUpEnabled ? "or continue with an existing wallet" : "Connect your wallet"
              }
            ) })
          ] }),
          availableWallets.map((wallet) => (0, import_jsx_runtime14.jsxs)(
            "button",
            {
              type: "button",
              onClick: wallet.connector,
              className: cn(
                border.radius,
                background.default,
                text.body,
                pressable.alternate,
                color.foreground,
                "flex items-center justify-between px-4 py-3 text-left"
              ),
              children: [
                wallet.name,
                (0, import_jsx_runtime14.jsx)("div", { className: "-mr-0.5 flex h-4 w-4 items-center justify-center", children: wallet.icon })
              ]
            },
            wallet.id
          ))
        ] }),
        (0, import_jsx_runtime14.jsxs)(
          "div",
          {
            className: cn(
              color.foregroundMuted,
              text.legal,
              "flex flex-col items-center justify-center gap-1 px-4",
              "mt-4 text-center"
            ),
            children: [
              (0, import_jsx_runtime14.jsx)("span", { className: "font-normal text-[10px] leading-[13px]", children: "By connecting a wallet, you agree to our" }),
              (0, import_jsx_runtime14.jsxs)("span", { className: "font-normal text-[10px] leading-[13px]", children: [
                termsOfServiceUrl && (0, import_jsx_runtime14.jsx)(
                  "a",
                  {
                    href: termsOfServiceUrl,
                    className: cn(color.primary, "hover:underline"),
                    target: "_blank",
                    rel: "noopener noreferrer",
                    tabIndex: 0,
                    children: "Terms of Service"
                  }
                ),
                " ",
                termsOfServiceUrl && privacyPolicyUrl && "and",
                " ",
                privacyPolicyUrl && (0, import_jsx_runtime14.jsx)(
                  "a",
                  {
                    href: privacyPolicyUrl,
                    className: cn(color.primary, "hover:underline"),
                    target: "_blank",
                    rel: "noopener noreferrer",
                    tabIndex: 0,
                    children: "Privacy Policy"
                  }
                ),
                "."
              ] })
            ]
          }
        )
      ]
    }
  ) });
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletProvider.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useBreakpoints.js
var import_react8 = __toESM(require_react(), 1);
var BREAKPOINTS = {
  sm: "(max-width: 640px)",
  md: "(min-width: 641px) and (max-width: 768px)",
  lg: "(min-width: 769px) and (max-width: 1023px)",
  xl: "(min-width: 1024px) and (max-width: 1279px)",
  "2xl": "(min-width: 1280px)"
};
function useBreakpoints() {
  const [currentBreakpoint, setCurrentBreakpoint] = (0, import_react8.useState)(void 0);
  (0, import_react8.useEffect)(() => {
    const getCurrentBreakpoint = () => {
      const entries = Object.entries(BREAKPOINTS);
      for (const [key, query] of entries) {
        if (window.matchMedia(query).matches) {
          return key;
        }
      }
      return "md";
    };
    setCurrentBreakpoint(getCurrentBreakpoint());
    const handleResize = () => {
      setCurrentBreakpoint(getCurrentBreakpoint());
    };
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return currentBreakpoint;
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletProvider.js
var import_react9 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/utils/getAnimations.js
function getAnimations(isSubComponentClosing, showSubComponentAbove) {
  if (isSubComponentClosing) {
    return {
      container: showSubComponentAbove ? "fade-out slide-out-to-bottom-1.5 animate-out fill-mode-forwards ease-in-out" : "fade-out slide-out-to-top-1.5 animate-out fill-mode-forwards ease-in-out",
      content: ""
    };
  }
  return {
    container: showSubComponentAbove ? "fade-in slide-in-from-bottom-1.5 animate-in duration-300 ease-out" : "fade-in slide-in-from-top-1.5 animate-in duration-300 ease-out",
    content: showSubComponentAbove ? "fade-in slide-in-from-bottom-2.5 animate-in fill-mode-forwards duration-300 ease-out" : "fade-in slide-in-from-top-2.5 animate-in fill-mode-forwards duration-300 ease-out"
  };
}

// node_modules/@coinbase/onchainkit/dist/token/constants.js
var ethToken = {
  name: "ETH",
  address: "",
  symbol: "ETH",
  decimals: 18,
  image: "https://wallet-api-production.s3.amazonaws.com/uploads/tokens/eth_288.png",
  chainId: base.id
};
var ethSepoliaToken = {
  name: "ETH",
  address: "",
  symbol: "ETH",
  decimals: 18,
  image: "https://wallet-api-production.s3.amazonaws.com/uploads/tokens/eth_288.png",
  chainId: baseSepolia.id
};
var usdcToken = {
  name: "USDC",
  address: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
  symbol: "USDC",
  decimals: 6,
  image: "https://d3r81g40ycuhqg.cloudfront.net/wallet/wais/44/2b/442b80bd16af0c0d9b22e03a16753823fe826e5bfd457292b55fa0ba8c1ba213-ZWUzYjJmZGUtMDYxNy00NDcyLTg0NjQtMWI4OGEwYjBiODE2",
  chainId: base.id
};
var usdcSepoliaToken = {
  name: "USDC",
  address: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
  symbol: "USDC",
  decimals: 6,
  image: "https://d3r81g40ycuhqg.cloudfront.net/wallet/wais/44/2b/442b80bd16af0c0d9b22e03a16753823fe826e5bfd457292b55fa0ba8c1ba213-ZWUzYjJmZGUtMDYxNy00NDcyLTg0NjQtMWI4OGEwYjBiODE2",
  chainId: baseSepolia.id
};
var degenToken = {
  name: "DEGEN",
  address: "0x4ed4E862860beD51a9570b96d89aF5E1B0Efefed",
  symbol: "DEGEN",
  decimals: 18,
  image: "https://d3r81g40ycuhqg.cloudfront.net/wallet/wais/3b/bf/3bbf118b5e6dc2f9e7fc607a6e7526647b4ba8f0bea87125f971446d57b296d2-MDNmNjY0MmEtNGFiZi00N2I0LWIwMTItMDUyMzg2ZDZhMWNm",
  chainId: base.id
};
var daiToken = {
  name: "DAI",
  address: "0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb",
  symbol: "DAI",
  decimals: 18,
  image: "https://d3r81g40ycuhqg.cloudfront.net/wallet/wais/92/13/9213e31b84c98a693f4c624580fdbe6e4c1cb550efbba15aa9ea68fd25ffb90c-ZTE1NmNjMGUtZGVkYi00ZDliLWI2N2QtNTY2ZWRjMmYwZmMw",
  chainId: base.id
};
var wethToken = {
  name: "WETH",
  address: "0x4200000000000000000000000000000000000006",
  symbol: "WETH",
  decimals: 18,
  image: "https://d3r81g40ycuhqg.cloudfront.net/wallet/wais/47/bc/47bc3593c2dec7c846b66b7ba5f6fa6bd69ec34f8ebb931f2a43072e5aaac7a8-YmUwNmRjZDUtMjczYy00NDFiLWJhZDUtMzgwNjFmYWM0Njkx",
  chainId: base.id
};
var lbtcToken = {
  name: "LBTC",
  address: "0xecAc9C5F704e954931349Da37F60E39f515c11c1",
  symbol: "LBTC",
  decimals: 8,
  image: "https://d3r81g40ycuhqg.cloudfront.net/wallet/wais/a3/40/a340085995bc54eddbcb66bab87833a7089edd1513847c39fc1799cab9207db4-Zjk2YzQ2MmQtMTY2OS00YWQyLWFkMGQtMjQ3OGYzNzljMWY2",
  chainId: base.id
};
var cbbtcToken = {
  name: "cbBTC",
  address: "0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf",
  symbol: "cbBTC",
  decimals: 8,
  image: "https://go.wallet.coinbase.com/static/CBBTCMedium.png",
  chainId: base.id
};
var eUsdToken = {
  name: "eUSD",
  address: "0xCfA3Ef56d303AE4fAabA0592388F19d7C3399FB4",
  symbol: "eUSD",
  decimals: 18,
  image: "https://d3r81g40ycuhqg.cloudfront.net/wallet/wais/bf/a4/bfa445583916854508ae5d88f9cca19cd5a0910d8c4d7cd9385eb40a597017d7-MDFhM2E0YmQtZGU3NS00Yzk3LWFlMzAtMzA1Y2UyYzU2ZGEy",
  chainId: base.id
};
var eurcToken = {
  name: "EURC",
  address: "0x60a3E35Cc302bFA44Cb288Bc5a4F316Fdb1adb42",
  symbol: "EURC",
  decimals: 6,
  image: "https://d3r81g40ycuhqg.cloudfront.net/wallet/wais/54/f4/54f4216472dd25b1ffb5caf32cc0d81f645c84be166cd713f759a80f05a1418f-M2YxNTczYTItNjk3YS00N2FiLThkZjktYzBiYzExZTk1ZTFj",
  chainId: base.id
};

// node_modules/@coinbase/onchainkit/dist/wallet/constants.js
var CB_SW_PROXY_BYTECODE = "0x363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3";
var CB_SW_V1_IMPLEMENTATION_ADDRESS = "0x000100abaad02f1cfC8Bbe32bD5a564817339E72";
var ERC_1967_PROXY_IMPLEMENTATION_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
var CB_SW_FACTORY_ADDRESS = "0x0BA5Ed0c6AA8c49038F819E587E2633c4A9F428a";
var WALLET_ADVANCED_MAX_HEIGHT = 400;
var WALLET_ADVANCED_MAX_WIDTH = 352;
var WALLET_ADVANCED_DEFAULT_SWAPPABLE_TOKENS = [
  ethToken,
  usdcToken
];

// node_modules/@coinbase/onchainkit/dist/wallet/utils/getWalletSubComponentPosition.js
function calculateSubComponentPosition(connectRect) {
  if (typeof window === "undefined") {
    return {
      showAbove: false,
      alignRight: false
    };
  }
  const spaceAvailableBelow = window.innerHeight - connectRect.bottom;
  const spaceAvailableRight = window.innerWidth - connectRect.left;
  return {
    showAbove: spaceAvailableBelow < WALLET_ADVANCED_MAX_HEIGHT,
    alignRight: spaceAvailableRight < WALLET_ADVANCED_MAX_WIDTH
  };
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletProvider.js
var emptyContext = {};
var WalletContext = (0, import_react9.createContext)(emptyContext);
function WalletProvider({ children, isSponsored }) {
  const { chain } = useOnchainKit();
  const [isConnectModalOpen, setIsConnectModalOpen] = (0, import_react9.useState)(false);
  const [isSubComponentOpen, setIsSubComponentOpen] = (0, import_react9.useState)(false);
  const [isSubComponentClosing, setIsSubComponentClosing] = (0, import_react9.useState)(false);
  const [showSubComponentAbove, setShowSubComponentAbove] = (0, import_react9.useState)(false);
  const [alignSubComponentRight, setAlignSubComponentRight] = (0, import_react9.useState)(false);
  const connectRef = (0, import_react9.useRef)(null);
  const { address } = useAccount();
  const breakpoint = useBreakpoints();
  const [activeFeature, setActiveFeature] = (0, import_react9.useState)(null);
  const [isActiveFeatureClosing, setIsActiveFeatureClosing] = (0, import_react9.useState)(false);
  const animations = (0, import_react9.useMemo)(() => {
    return getAnimations(isSubComponentClosing, showSubComponentAbove);
  }, [isSubComponentClosing, showSubComponentAbove]);
  const handleClose = (0, import_react9.useCallback)(() => {
    if (!isSubComponentOpen) {
      return;
    }
    setIsSubComponentClosing(true);
  }, [isSubComponentOpen]);
  (0, import_react9.useEffect)(() => {
    if (isSubComponentOpen && (connectRef == null ? void 0 : connectRef.current)) {
      const connectRect = connectRef.current.getBoundingClientRect();
      const position = calculateSubComponentPosition(connectRect);
      setShowSubComponentAbove(position.showAbove);
      setAlignSubComponentRight(position.alignRight);
    }
  }, [isSubComponentOpen]);
  const value = (0, import_react9.useMemo)(() => {
    return {
      address,
      chain,
      breakpoint,
      isConnectModalOpen,
      setIsConnectModalOpen,
      isSubComponentOpen,
      setIsSubComponentOpen,
      isSubComponentClosing,
      setIsSubComponentClosing,
      handleClose,
      connectRef,
      showSubComponentAbove,
      alignSubComponentRight,
      activeFeature,
      setActiveFeature,
      isActiveFeatureClosing,
      setIsActiveFeatureClosing,
      animations,
      isSponsored
    };
  }, [
    address,
    chain,
    breakpoint,
    isConnectModalOpen,
    isSubComponentOpen,
    isSubComponentClosing,
    handleClose,
    showSubComponentAbove,
    alignSubComponentRight,
    activeFeature,
    isActiveFeatureClosing,
    animations,
    isSponsored
  ]);
  return (0, import_jsx_runtime15.jsx)(WalletContext.Provider, { value, children });
}
function useWalletContext() {
  return (0, import_react9.useContext)(WalletContext);
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/ConnectWallet.js
var connectWalletDefaultChildren = (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [
  (0, import_jsx_runtime16.jsx)(Avatar, { className: "h-6 w-6" }),
  (0, import_jsx_runtime16.jsx)(Name, {})
] });
function ConnectWallet({
  children,
  className,
  // In a few version we will officially deprecate this prop,
  // but for now we will keep it for backward compatibility.
  text: text$1 = "Connect Wallet",
  onConnect,
  disconnectedLabel
}) {
  var _a, _b;
  const { config = { wallet: { display: void 0 } } } = useOnchainKit();
  const {
    setIsConnectModalOpen,
    isSubComponentOpen,
    setIsSubComponentOpen,
    handleClose
  } = useWalletContext();
  const {
    address: accountAddress,
    status,
    connector: accountConnector
  } = useAccount();
  const { connectors, connect, status: connectStatus } = useConnect();
  const { sendAnalytics } = useAnalytics();
  const [hasClickedConnect, setHasClickedConnect] = (0, import_react10.useState)(false);
  const [isModalOpen, setIsModalOpen] = (0, import_react10.useState)(false);
  const { connectWalletText } = (0, import_react10.useMemo)(() => {
    const childrenArray = import_react10.Children.toArray(children);
    return {
      connectWalletText: childrenArray.find(findComponent(ConnectWalletText))
    };
  }, [children]);
  const childrenWithoutConnectWalletText = (0, import_react10.useMemo)(() => {
    return import_react10.Children.map(children, (child) => {
      if ((0, import_react10.isValidElement)(child) && child.type === ConnectWalletText) {
        return null;
      }
      return child;
    });
  }, [children]);
  const connector = accountConnector || connectors[0];
  const isLoading = connectStatus === "pending" || status === "connecting";
  const handleToggle = (0, import_react10.useCallback)(() => {
    if (isSubComponentOpen) {
      handleClose == null ? void 0 : handleClose();
    } else {
      setIsSubComponentOpen(true);
    }
  }, [isSubComponentOpen, handleClose, setIsSubComponentOpen]);
  const handleCloseConnectModal = (0, import_react10.useCallback)(() => {
    setIsModalOpen(false);
    setIsConnectModalOpen == null ? void 0 : setIsConnectModalOpen(false);
  }, [setIsConnectModalOpen]);
  const handleOpenConnectModal = (0, import_react10.useCallback)(() => {
    setIsModalOpen(true);
    setIsConnectModalOpen == null ? void 0 : setIsConnectModalOpen(true);
    setHasClickedConnect(true);
  }, [setIsConnectModalOpen]);
  const handleAnalyticsInitiated = (0, import_react10.useCallback)(
    (component) => {
      sendAnalytics(WalletEvent.ConnectInitiated, {
        component
      });
    },
    [sendAnalytics]
  );
  const handleAnalyticsSuccess = (0, import_react10.useCallback)(
    (walletAddress) => {
      const walletProvider = connector == null ? void 0 : connector.name;
      sendAnalytics(WalletEvent.ConnectSuccess, {
        address: walletAddress ?? "",
        walletProvider
      });
    },
    [sendAnalytics, connector]
  );
  const handleAnalyticsError = (0, import_react10.useCallback)(
    (errorMessage, component) => {
      const walletProvider = connector == null ? void 0 : connector.name;
      sendAnalytics(WalletEvent.ConnectError, {
        error: errorMessage,
        metadata: {
          connector: walletProvider,
          component
        }
      });
    },
    [sendAnalytics, connector]
  );
  (0, import_react10.useEffect)(() => {
    if (hasClickedConnect && status === "connected" && onConnect) {
      onConnect();
      setHasClickedConnect(false);
    }
  }, [status, hasClickedConnect, onConnect]);
  (0, import_react10.useEffect)(() => {
    if (status === "connected" && accountAddress && connector) {
      handleAnalyticsSuccess(accountAddress);
    }
  }, [status, accountAddress, connector, handleAnalyticsSuccess]);
  const handleConnectClick = (0, import_react10.useCallback)(() => {
    var _a2;
    if (((_a2 = config == null ? void 0 : config.wallet) == null ? void 0 : _a2.display) === "modal") {
      handleOpenConnectModal();
      setHasClickedConnect(true);
      handleAnalyticsInitiated("WalletModal");
      return;
    }
    handleAnalyticsInitiated("ConnectWallet");
    connect(
      { connector },
      {
        onSuccess: () => {
          onConnect == null ? void 0 : onConnect();
          handleAnalyticsSuccess(accountAddress);
        },
        onError: (error) => {
          handleAnalyticsError(error.message, "ConnectWallet");
        }
      }
    );
  }, [
    (_a = config == null ? void 0 : config.wallet) == null ? void 0 : _a.display,
    accountAddress,
    connect,
    connector,
    handleAnalyticsError,
    handleAnalyticsInitiated,
    handleAnalyticsSuccess,
    handleOpenConnectModal,
    onConnect
  ]);
  if (status === "disconnected") {
    return (0, import_jsx_runtime16.jsxs)("div", { className: "flex", "data-testid": "ockConnectWallet_Container", children: [
      (0, import_jsx_runtime16.jsx)(
        ConnectButton,
        {
          className,
          connectWalletText: connectWalletText || disconnectedLabel,
          onClick: handleConnectClick,
          text: text$1
        }
      ),
      ((_b = config == null ? void 0 : config.wallet) == null ? void 0 : _b.display) === "modal" && (0, import_jsx_runtime16.jsx)(WalletModal, { isOpen: isModalOpen, onClose: handleCloseConnectModal })
    ] });
  }
  if (isLoading) {
    return (0, import_jsx_runtime16.jsx)("div", { className: "flex", "data-testid": "ockConnectWallet_Container", children: (0, import_jsx_runtime16.jsx)(
      "button",
      {
        type: "button",
        "data-testid": "ockConnectAccountButtonInner",
        className: cn(
          pressable.primary,
          text.headline,
          color.inverse,
          "inline-flex min-w-[153px] items-center justify-center rounded-xl px-4 py-3",
          pressable.disabled,
          className
        ),
        disabled: true,
        children: (0, import_jsx_runtime16.jsx)(Spinner, {})
      }
    ) });
  }
  return (0, import_jsx_runtime16.jsx)(IdentityProvider, { address: accountAddress, children: (0, import_jsx_runtime16.jsx)("div", { className: "flex gap-4", "data-testid": "ockConnectWallet_Container", children: (0, import_jsx_runtime16.jsx)(
    "button",
    {
      type: "button",
      "data-testid": "ockConnectWallet_Connected",
      className: cn(
        pressable.secondary,
        border.radius,
        color.foreground,
        "px-4 py-3",
        isSubComponentOpen && "ock-bg-secondary-active hover:ock-bg-secondary-active",
        className
      ),
      onClick: handleToggle,
      children: (0, import_jsx_runtime16.jsx)("div", { className: "flex items-center justify-center gap-2", children: childrenWithoutConnectWalletText || connectWalletDefaultChildren })
    }
  ) }) });
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvanced.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedAddressDetails.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/core/network/definitions/wallet.js
var CDP_GET_PORTFOLIO_TOKEN_BALANCES = "cdp_getTokensForAddresses";
var CDP_GET_PRICE_QUOTE = "cdp_getPriceQuote";

// node_modules/@coinbase/onchainkit/dist/core/network/getRPCUrl.js
var getRPCUrl = () => {
  if (!ONCHAIN_KIT_CONFIG.rpcUrl && !ONCHAIN_KIT_CONFIG.apiKey) {
    throw new Error(
      "API Key Unset: You can use the Coinbase Developer Platform RPC by providing an API key in `OnchainKitProvider` or by manually calling `setOnchainKitConfig`: https://portal.cdp.coinbase.com/products/onchainkit"
    );
  }
  return ONCHAIN_KIT_CONFIG.rpcUrl || `https://api.developer.coinbase.com/rpc/v1/${ONCHAIN_KIT_CONFIG.chain.name.replace(" ", "-").toLowerCase()}/${ONCHAIN_KIT_CONFIG.apiKey}`;
};

// node_modules/@coinbase/onchainkit/dist/core/network/request.js
function buildRequestBody(method, params) {
  return {
    id: 1,
    jsonrpc: JSON_RPC_VERSION,
    method,
    params
  };
}
async function buildRequestHeaders(context) {
  var _a;
  const headers = {
    ...JSON_HEADERS
  };
  const clientMeta = await clientMetaManager.getClientMeta().catch(() => null);
  if (clientMeta) {
    headers["OnchainKit-Client-Fid"] = ((_a = clientMeta.clientFid) == null ? void 0 : _a.toString()) ?? "";
    headers["OnchainKit-Mode"] = clientMeta.mode;
  }
  if (context) {
    if (!Object.values(RequestContext).includes(context)) {
      return {
        ...headers,
        [CONTEXT_HEADER]: RequestContext.API
      };
    }
    return {
      ...headers,
      [CONTEXT_HEADER]: context
    };
  }
  return headers;
}
async function sendRequest(method, params, _context) {
  try {
    const body = buildRequestBody(method, params);
    const url = getRPCUrl();
    const response = await fetch(url, {
      body: JSON.stringify(body),
      headers: await buildRequestHeaders(_context),
      method: POST_METHOD
    });
    const data = await response.json();
    return data;
  } catch (error) {
    console.log(
      `sendRequest: error sending request: ${error.message}`
    );
    throw error;
  }
}

// node_modules/@coinbase/onchainkit/dist/api/getPortfolios.js
async function getPortfolios(params, _context = RequestContext.API) {
  const { addresses } = params;
  try {
    const res = await sendRequest(
      CDP_GET_PORTFOLIO_TOKEN_BALANCES,
      [{ addresses }],
      _context
    );
    if (res.error) {
      return {
        code: `${res.error.code}`,
        error: "Error fetching portfolio token balances",
        message: res.error.message
      };
    }
    return res.result;
  } catch (error) {
    return {
      code: "uncaught-portfolio",
      error: "Something went wrong",
      message: `Error fetching portfolio token balances: ${error}`
    };
  }
}

// node_modules/@coinbase/onchainkit/dist/internal/utils/isApiResponseError.js
function isApiError(response) {
  return response !== null && typeof response === "object" && "error" in response;
}

// node_modules/@coinbase/onchainkit/dist/wallet/hooks/usePortfolio.js
function usePortfolio({ address, enabled = true }, _context = RequestContext.Hook) {
  return useQuery({
    queryKey: ["usePortfolio", address],
    queryFn: async () => {
      const response = await getPortfolios(
        {
          addresses: [address]
          // Safe to coerce to Address because useQuery's enabled flag will prevent the query from running if address is undefined
        },
        _context
      );
      if (isApiError(response)) {
        throw new Error(response.message);
      }
      if (response.portfolios.length === 0) {
        return {
          address,
          portfolioBalanceUsd: 0,
          tokenBalances: []
        };
      }
      return response.portfolios[0];
    },
    retry: false,
    enabled: !!address && enabled,
    refetchOnWindowFocus: true,
    // refresh on window focus
    staleTime: 1e3 * 60 * 5,
    // refresh on mount every 5 minutes
    refetchOnMount: true,
    refetchInterval: 1e3 * 60 * 15,
    // refresh in background every 15 minutes
    refetchIntervalInBackground: true
  });
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedAddressDetails.js
function WalletAdvancedAddressDetails({
  classNames
}) {
  const { address, chain, animations } = useWalletContext();
  const [copyText, setCopyText] = (0, import_react11.useState)("Copy");
  const handleCopyAddress = (0, import_react11.useCallback)(async () => {
    try {
      await navigator.clipboard.writeText(String(address));
      setCopyText("Copied");
      setTimeout(() => setCopyText("Copy"), 2e3);
    } catch (err) {
      console.error("Failed to copy address:", err);
      setCopyText("Failed to copy");
      setTimeout(() => setCopyText("Copy"), 2e3);
    }
  }, [address]);
  if (!address || !chain) {
    return (0, import_jsx_runtime17.jsx)("div", { className: "mt-1 h-28 w-10 px-4 py-3" });
  }
  return (0, import_jsx_runtime17.jsxs)(
    "div",
    {
      "data-testid": "ockWalletAdvanced_AddressDetails",
      className: cn(
        "mt-2 flex w-88 flex-col items-center justify-center px-4 py-3",
        color.foreground,
        text.body,
        animations.content,
        classNames == null ? void 0 : classNames.container
      ),
      children: [
        (0, import_jsx_runtime17.jsx)(
          Avatar,
          {
            address,
            chain,
            className: cn("pointer-events-none h-10 w-10", classNames == null ? void 0 : classNames.avatar)
          }
        ),
        (0, import_jsx_runtime17.jsxs)("div", { className: "group relative mt-2 text-base", children: [
          (0, import_jsx_runtime17.jsx)(
            "button",
            {
              type: "button",
              onClick: handleCopyAddress,
              "data-testid": "ockWalletAdvanced_NameButton",
              children: (0, import_jsx_runtime17.jsx)(
                Name,
                {
                  address,
                  chain,
                  className: cn(
                    "hover:text-[var(--ock-text-foreground-muted)] active:text-[var(--ock-text-primary)]",
                    classNames == null ? void 0 : classNames.nameButton
                  )
                }
              )
            }
          ),
          (0, import_jsx_runtime17.jsx)(
            "button",
            {
              type: "button",
              onClick: handleCopyAddress,
              className: cn(
                pressable.alternate,
                text.legal,
                color.foreground,
                border.default,
                border.radius,
                zIndex.tooltip,
                "absolute top-full right-0 mt-0.5 px-1.5 py-0.5 opacity-0 transition-opacity group-hover:opacity-100"
              ),
              "aria-live": "polite",
              "data-testid": "ockWalletAdvanced_NameTooltip",
              children: copyText
            }
          )
        ] }),
        (0, import_jsx_runtime17.jsx)(AddressBalanceInFiat, { className: classNames == null ? void 0 : classNames.fiatBalance })
      ]
    }
  );
}
function AddressBalanceInFiat({ className }) {
  const { address } = useAccount();
  const { data: portfolioData, isFetching: isFetchingPortfolioData } = usePortfolio({ address }, RequestContext.Wallet);
  const portfolioFiatValue = portfolioData == null ? void 0 : portfolioData.portfolioBalanceInUsd;
  const formattedValueInFiat = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD"
  }).format(Number(portfolioFiatValue));
  if (isFetchingPortfolioData) {
    return (0, import_jsx_runtime17.jsx)("div", { className: "mt-1 h-8 w-full", children: (0, import_jsx_runtime17.jsx)(Spinner, {}) });
  }
  if (portfolioFiatValue === null || portfolioFiatValue === void 0) {
    return null;
  }
  return (0, import_jsx_runtime17.jsx)(
    "div",
    {
      className: cn(text.title1, "mt-1 font-normal", className),
      "data-testid": "ockWalletAdvanced_AddressBalance",
      children: formattedValueInFiat
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedTokenHoldings.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/token/components/TokenImage.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/token/utils/getTokenImageColor.js
function hashStringToNumber(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
  }
  return hash;
}
function numberToRgb(hash) {
  const h = Math.abs(hash) % 360;
  const s = Math.abs(hash >> 8) % 31 + 50;
  const l = Math.abs(hash >> 16) % 21 + 40;
  return `hsl(${h}, ${s}%, ${l}%)`;
}
function getTokenImageColor(str) {
  const hash = hashStringToNumber(`${str}`);
  return numberToRgb(hash);
}

// node_modules/@coinbase/onchainkit/dist/token/components/TokenImage.js
function TokenImage({ className, size = 24, token }) {
  const { image, name } = token;
  const styles = (0, import_react12.useMemo)(() => {
    return {
      image: {
        width: `${size}px`,
        height: `${size}px`,
        minWidth: `${size}px`,
        minHeight: `${size}px`
      },
      placeholderImage: {
        background: getTokenImageColor(name),
        width: `${size}px`,
        height: `${size}px`,
        minWidth: `${size}px`,
        minHeight: `${size}px`
      }
    };
  }, [size, name]);
  if (!image) {
    return (0, import_jsx_runtime18.jsx)(
      "div",
      {
        className: cn("overflow-hidden rounded-full", className),
        "data-testid": "ockTokenImage_NoImage",
        style: styles.image,
        children: (0, import_jsx_runtime18.jsx)("div", { style: styles.placeholderImage })
      }
    );
  }
  return (0, import_jsx_runtime18.jsx)(
    "img",
    {
      className: cn("overflow-hidden rounded-[50%]", className),
      alt: "token-image",
      "data-testid": "ockTokenImage_Image",
      style: styles.image,
      src: image
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/token/components/TokenRow.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/token/utils/formatAmount.js
function formatAmount(amount, options = {}) {
  if (amount === void 0) {
    return "";
  }
  const { locale, minimumFractionDigits, maximumFractionDigits } = options;
  return Number(amount).toLocaleString(locale, {
    minimumFractionDigits,
    maximumFractionDigits
  });
}

// node_modules/@coinbase/onchainkit/dist/token/components/TokenRow.js
var TokenRow = (0, import_react13.memo)(function TokenRow2({
  className,
  token,
  amount,
  onClick,
  hideImage,
  hideSymbol
}) {
  const componentTheme = useTheme();
  return (0, import_jsx_runtime19.jsxs)(
    "button",
    {
      "data-testid": "ockTokenRow_Container",
      type: "button",
      className: cn(
        componentTheme,
        pressable.default,
        "flex w-full items-center justify-between px-2 py-1",
        className
      ),
      onClick: () => onClick == null ? void 0 : onClick(token),
      children: [
        (0, import_jsx_runtime19.jsxs)("span", { className: "flex max-w-full items-center gap-3", children: [
          !hideImage && (0, import_jsx_runtime19.jsx)(TokenImage, { token, size: 28 }),
          (0, import_jsx_runtime19.jsxs)("span", { className: "flex min-w-0 flex-col items-start", children: [
            (0, import_jsx_runtime19.jsx)(
              "span",
              {
                className: cn(
                  text.headline,
                  "max-w-full overflow-hidden text-ellipsis whitespace-nowrap text-left"
                ),
                children: token.name.trim()
              }
            ),
            !hideSymbol && (0, import_jsx_runtime19.jsx)("span", { className: cn(text.body, color.foregroundMuted), children: token.symbol })
          ] })
        ] }),
        (0, import_jsx_runtime19.jsx)(
          "span",
          {
            "data-testid": "ockTokenRow_Amount",
            className: cn(text.body, color.foregroundMuted),
            children: formatAmount(amount, {
              minimumFractionDigits: 2,
              maximumFractionDigits: Number(amount) < 1 ? 5 : 2
            })
          }
        )
      ]
    }
  );
});

// node_modules/@coinbase/onchainkit/dist/internal/components/TextInput.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useDebounce.js
var import_react14 = __toESM(require_react(), 1);
var useDebounce = (callback, delay) => {
  const callbackRef = (0, import_react14.useRef)(callback);
  (0, import_react14.useLayoutEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, import_react14.useMemo)(() => {
    let timer;
    const debounce = (func, delayMs, ...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        func(...args);
      }, delayMs);
    };
    return (...args) => {
      return debounce(callbackRef.current, delay, ...args);
    };
  }, [delay]);
};

// node_modules/@coinbase/onchainkit/dist/internal/components/TextInput.js
var TextInput = (0, import_react15.forwardRef)(
  ({
    "aria-label": ariaLabel,
    className,
    delayMs = 0,
    disabled = false,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    setValue,
    inputMode,
    value,
    inputValidator = () => true
  }, ref) => {
    const handleDebounce = useDebounce((value2) => {
      onChange(value2);
    }, delayMs);
    const handleChange = (0, import_react15.useCallback)(
      (evt) => {
        const value2 = evt.target.value;
        if (inputValidator(value2)) {
          setValue == null ? void 0 : setValue(value2);
          if (delayMs > 0) {
            handleDebounce(value2);
          } else {
            onChange(value2);
          }
        }
      },
      [onChange, handleDebounce, delayMs, setValue, inputValidator]
    );
    return (0, import_jsx_runtime20.jsx)(
      "input",
      {
        "aria-label": ariaLabel,
        "data-testid": "ockTextInput_Input",
        ref,
        type: "text",
        className,
        inputMode,
        placeholder,
        value,
        onBlur,
        onChange: handleChange,
        onFocus,
        disabled,
        autoComplete: "off",
        "data-1p-ignore": true
      }
    );
  }
);
TextInput.displayName = "TextInput";

// node_modules/@coinbase/onchainkit/dist/internal/svg/searchIconSvg.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var searchIconSvg = (0, import_jsx_runtime21.jsx)(
  "svg",
  {
    role: "img",
    "aria-label": "ock-searchIconSvg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime21.jsx)(
      "path",
      {
        d: "M16 14.23L11.89 10.12C12.59 9.09 13 7.84 13 6.5C13 2.91 10.09 0 6.5 0C2.91 0 0 2.91 0 6.5C0 10.09 2.91 13 6.5 13C7.84 13 9.09 12.59 10.13 11.89L14.23 16L16 14.23ZM6.5 10.5C4.29 10.5 2.5 8.71 2.5 6.5C2.5 4.29 4.29 2.5 6.5 2.5C8.71 2.5 10.5 4.29 10.5 6.5C10.5 8.71 8.71 10.5 6.5 10.5Z",
        className: icon.foreground
      }
    )
  }
);

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedTokenHoldings.js
var import_react_dom2 = __toESM(require_react_dom(), 1);

// node_modules/@coinbase/onchainkit/dist/token/components/TokenSelectButton.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/svg/caretDownSvg.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var caretDownSvg = (0, import_jsx_runtime22.jsx)(
  "svg",
  {
    "data-testid": "ock-caretDownSvg",
    role: "img",
    "aria-label": "ock-caretDownSvg",
    width: "16",
    height: "17",
    viewBox: "0 0 16 17",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime22.jsx)(
      "path",
      {
        d: "M12.95 4.85999L8.00001 9.80999L3.05001 4.85999L1.64001 6.27999L8.00001 12.64L14.36 6.27999L12.95 4.85999Z",
        className: icon.foreground
      }
    )
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/caretUpSvg.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var caretUpSvg = (0, import_jsx_runtime23.jsx)(
  "svg",
  {
    "data-testid": "ock-caretUpSvg",
    role: "img",
    "aria-label": "ock-caretUpSvg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime23.jsx)(
      "path",
      {
        d: "M3.05329 10.9866L7.99996 6.03997L12.9466 10.9866L14.1266 9.80663L7.99996 3.67997L1.87329 9.80663L3.05329 10.9866Z",
        className: icon.foreground
      }
    )
  }
);

// node_modules/@coinbase/onchainkit/dist/token/components/TokenSelectButton.js
var TokenSelectButton = (0, import_react16.forwardRef)(function TokenSelectButton2({ onClick, token, isOpen, className }, ref) {
  return (0, import_jsx_runtime24.jsxs)(
    "button",
    {
      type: "button",
      "data-testid": "ockTokenSelectButton_Button",
      className: cn(
        pressable.default,
        pressable.shadow,
        border.radius,
        border.lineDefault,
        "flex w-fit items-center gap-2 px-3 py-1",
        className
      ),
      onClick,
      ref,
      children: [
        token ? (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [
          (0, import_jsx_runtime24.jsx)("div", { className: "w-4", children: (0, import_jsx_runtime24.jsx)(TokenImage, { token, size: 16 }) }),
          (0, import_jsx_runtime24.jsx)(
            "span",
            {
              className: cn(text.headline, color.foreground),
              "data-testid": "ockTokenSelectButton_Symbol",
              children: token.symbol
            }
          )
        ] }) : (0, import_jsx_runtime24.jsx)("span", { className: text.headline, children: "Select token" }),
        (0, import_jsx_runtime24.jsxs)("div", { className: "relative flex items-center justify-center", children: [
          (0, import_jsx_runtime24.jsx)("div", { className: "absolute top-0 left-0 h-4 w-4" }),
          isOpen ? caretUpSvg : caretDownSvg
        ] })
      ]
    }
  );
});

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedTokenHoldings.js
function WalletAdvancedTokenHoldings({
  classNames
}) {
  const { address } = useAccount();
  const { animations } = useWalletContext();
  const { data: portfolioData, isFetching: isFetchingPortfolioData } = usePortfolio({ address }, RequestContext.Wallet);
  const tokenBalances = portfolioData == null ? void 0 : portfolioData.tokenBalances;
  if (isFetchingPortfolioData || !tokenBalances || tokenBalances.length === 0) {
    return (0, import_jsx_runtime25.jsx)(
      "div",
      {
        "data-testid": "ockWalletAdvanced_LoadingPlaceholder",
        className: "mx-auto my-2 h-44 w-80 px-4 py-3"
      }
    );
  }
  return (0, import_jsx_runtime25.jsx)(
    "div",
    {
      className: cn(
        "flex flex-col items-center gap-4",
        "my-2 h-44 max-h-44",
        "scrollbar-hidden w-88 overflow-y-auto px-4 py-3",
        animations.content,
        classNames == null ? void 0 : classNames.container
      ),
      "data-testid": "ockWalletAdvanced_TokenHoldings",
      children: tokenBalances.map((tokenBalance, index) => (0, import_jsx_runtime25.jsx)(
        TokenDetails,
        {
          token: {
            address: tokenBalance.address,
            chainId: tokenBalance.chainId,
            decimals: tokenBalance.decimals,
            image: tokenBalance.image,
            name: tokenBalance.name,
            symbol: tokenBalance.symbol
          },
          balance: Number(
            formatUnits(
              BigInt(tokenBalance.cryptoBalance),
              tokenBalance.decimals
            )
          ),
          valueInFiat: Number(tokenBalance.fiatBalance),
          classNames: classNames == null ? void 0 : classNames.tokenDetails
        },
        `${tokenBalance.address}-${index}`
      ))
    }
  );
}
function TokenDetails({
  token,
  balance,
  valueInFiat,
  classNames,
  tokenImageSize = 32
}) {
  var _a;
  const formattedBalance = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 2,
    maximumFractionDigits: 5
  }).format(balance);
  const formattedValueInFiat = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD"
  }).format(valueInFiat);
  return (0, import_jsx_runtime25.jsxs)(
    "div",
    {
      className: cn(
        "flex w-full flex-row items-center justify-between",
        classNames == null ? void 0 : classNames.container
      ),
      children: [
        (0, import_jsx_runtime25.jsxs)(
          "div",
          {
            "data-testid": "ockWalletAdvanced_TokenDetails_TokenImage",
            className: cn(
              "flex flex-row items-center gap-2",
              classNames == null ? void 0 : classNames.tokenImage
            ),
            children: [
              (0, import_jsx_runtime25.jsx)(TokenImage, { token, size: tokenImageSize }),
              (0, import_jsx_runtime25.jsxs)("div", { className: "flex flex-col", children: [
                (0, import_jsx_runtime25.jsx)(
                  "span",
                  {
                    className: cn(
                      text.label1,
                      color.foreground,
                      "max-w-52 overflow-hidden text-ellipsis whitespace-nowrap text-left",
                      classNames == null ? void 0 : classNames.tokenName
                    ),
                    children: (_a = token.name) == null ? void 0 : _a.trim()
                  }
                ),
                (0, import_jsx_runtime25.jsx)(
                  "span",
                  {
                    className: cn(
                      text.legal,
                      color.foregroundMuted,
                      classNames == null ? void 0 : classNames.tokenBalance
                    ),
                    children: `${formattedBalance} ${token.symbol}`
                  }
                )
              ] })
            ]
          }
        ),
        (0, import_jsx_runtime25.jsx)(
          "span",
          {
            className: cn(
              text.label2,
              color.foregroundMuted,
              classNames == null ? void 0 : classNames.fiatValue
            ),
            children: formattedValueInFiat
          }
        )
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedTransactionActions.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/Skeleton.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
function Skeleton({ className }) {
  return (0, import_jsx_runtime26.jsx)(
    "div",
    {
      className: cn(
        "animate-pulse bg-opacity-50",
        background.alternate,
        border.radius,
        className
      ),
      "data-testid": "ockSkeleton"
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/internal/svg/addForegroundSvg.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var addSvgForeground = (0, import_jsx_runtime27.jsxs)(
  "svg",
  {
    "data-testid": "ock-addSvg",
    role: "img",
    "aria-label": "ock-addSvg",
    width: "13",
    height: "12",
    viewBox: "0 0 13 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime27.jsx)("title", { children: "Add" }),
      (0, import_jsx_runtime27.jsx)(
        "path",
        {
          d: "M7.125 0H5.875V5.37501L0.5 5.37501L0.5 6.62501H5.875V12H7.125V6.62501H12.5V5.37501H7.125V0Z",
          className: icon.foreground
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/arrowUpRightSvg.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var arrowUpRightSvg = (0, import_jsx_runtime28.jsxs)(
  "svg",
  {
    width: "12",
    height: "12",
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime28.jsx)("title", { children: "Arrow Up Right" }),
      (0, import_jsx_runtime28.jsx)(
        "path",
        {
          d: "M2.44196 2.25H8.93304L1 10.183L1.88388 11.0669L9.81695 3.13386V9.625H11.067V1H2.44196V2.25Z",
          className: icon.foreground
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/toggleSvg.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var toggleSvg = (0, import_jsx_runtime29.jsxs)(
  "svg",
  {
    role: "img",
    "aria-label": "ock-toggleSvg",
    width: "16",
    height: "17",
    viewBox: "0 0 16 17",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "data-testid": "ock-toggleSvg",
    children: [
      (0, import_jsx_runtime29.jsx)("g", { clipPath: "url(#clip0_2077_4627)", children: (0, import_jsx_runtime29.jsx)(
        "path",
        {
          d: "M14.5659 4.93434L13.4345 6.06571L11.8002 4.43139L11.8002 10.75L10.2002 10.75L10.2002 4.43139L8.56592 6.06571L7.43455 4.93434L11.0002 1.36865L14.5659 4.93434ZM8.56592 12.0657L5.00023 15.6314L1.43455 12.0657L2.56592 10.9343L4.20023 12.5687L4.20023 6.25002L5.80023 6.25002L5.80023 12.5687L7.43455 10.9343L8.56592 12.0657Z",
          className: icon.foreground
        }
      ) }),
      (0, import_jsx_runtime29.jsx)("defs", { children: (0, import_jsx_runtime29.jsx)("clipPath", { id: "clip0_2077_4627", children: (0, import_jsx_runtime29.jsx)(
        "rect",
        {
          width: "16",
          height: "16",
          fill: "white",
          transform: "translate(0 0.5)"
        }
      ) }) })
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedTransactionActions.js
var import_react18 = __toESM(require_react(), 1);
function WalletAdvancedTransactionActions({
  classNames
}) {
  const { address, chain, setActiveFeature, animations } = useWalletContext();
  const { projectId } = useOnchainKit();
  const { sendAnalytics } = useAnalytics();
  const { isFetching: isFetchingPortfolioData } = usePortfolio(
    { address },
    RequestContext.Wallet
  );
  const handleAnalyticsOptionSelected = (0, import_react18.useCallback)(
    (option) => {
      sendAnalytics(WalletEvent.OptionSelected, {
        option
      });
    },
    [sendAnalytics]
  );
  const handleBuy = (0, import_react18.useCallback)(() => {
    handleAnalyticsOptionSelected(WalletOption.Buy);
    if (!projectId || !address || !(chain == null ? void 0 : chain.name)) {
      return;
    }
    const url = new URL("https://pay.coinbase.com/buy/select-asset");
    const params = new URLSearchParams({
      appId: projectId,
      destinationWallets: JSON.stringify([
        {
          address,
          blockchains: [chain.name.toLowerCase()]
        }
      ]),
      defaultAsset: "USDC",
      defaultPaymentMethod: "CRYPTO_ACCOUNT",
      presetFiatAmount: "25"
    });
    window.open(
      `${url}?${params}`,
      "popup",
      "width=400,height=600,scrollbars=yes"
    );
  }, [address, chain == null ? void 0 : chain.name, projectId, handleAnalyticsOptionSelected]);
  const handleSend = (0, import_react18.useCallback)(() => {
    handleAnalyticsOptionSelected(WalletOption.Send);
    setActiveFeature("send");
  }, [handleAnalyticsOptionSelected, setActiveFeature]);
  const handleSwap = (0, import_react18.useCallback)(() => {
    handleAnalyticsOptionSelected(WalletOption.Swap);
    setActiveFeature("swap");
  }, [setActiveFeature, handleAnalyticsOptionSelected]);
  if (isFetchingPortfolioData) {
    return (0, import_jsx_runtime30.jsx)(Skeleton, { className: "mx-auto my-3 h-16 w-80 px-4 py-3" });
  }
  return (0, import_jsx_runtime30.jsxs)(
    "div",
    {
      "data-testid": "ockWalletAdvanced_TransactionActions",
      className: cn(
        "my-3 flex w-88 flex-row justify-between gap-2 px-4 py-3",
        animations.content,
        classNames == null ? void 0 : classNames.container
      ),
      children: [
        (0, import_jsx_runtime30.jsx)(
          WalletAdvancedTransactionAction,
          {
            icon: addSvgForeground,
            label: "Buy",
            action: handleBuy,
            classNames: classNames == null ? void 0 : classNames.leftAction
          }
        ),
        (0, import_jsx_runtime30.jsx)(
          WalletAdvancedTransactionAction,
          {
            icon: arrowUpRightSvg,
            label: "Send",
            action: handleSend,
            classNames: classNames == null ? void 0 : classNames.middleAction
          }
        ),
        (0, import_jsx_runtime30.jsx)(
          WalletAdvancedTransactionAction,
          {
            icon: toggleSvg,
            label: "Swap",
            action: handleSwap,
            classNames: classNames == null ? void 0 : classNames.rightAction
          }
        )
      ]
    }
  );
}
function WalletAdvancedTransactionAction({
  icon: icon2,
  label,
  action,
  classNames
}) {
  return (0, import_jsx_runtime30.jsxs)(
    "button",
    {
      type: "button",
      className: cn(
        "flex flex-col items-center justify-center gap-2 pt-2.5 pb-2",
        "h-16 flex-1",
        border.radius,
        pressable.alternate,
        classNames == null ? void 0 : classNames.container
      ),
      onClick: action,
      "aria-label": label,
      children: [
        (0, import_jsx_runtime30.jsx)(
          "span",
          {
            className: cn(
              "flex h-4 w-4 flex-col items-center justify-center",
              classNames == null ? void 0 : classNames.icon
            ),
            children: icon2
          }
        ),
        (0, import_jsx_runtime30.jsx)(
          "span",
          {
            className: cn(
              text.label2,
              color.foreground,
              "flex flex-col justify-center",
              classNames == null ? void 0 : classNames.label
            ),
            children: label
          }
        )
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedWalletActions.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/PressableIcon.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
function PressableIcon({
  children,
  className,
  onClick,
  ariaLabel
}) {
  return (0, import_jsx_runtime31.jsx)(
    "button",
    {
      type: "button",
      onClick,
      "data-testid": "ockPressableIconButton",
      "aria-label": ariaLabel,
      className: cn(
        pressable.default,
        border.radiusInner,
        border.default,
        "flex items-center justify-center",
        className
      ),
      children
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/internal/svg/baseScanSvg.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var baseScanSvg = (0, import_jsx_runtime32.jsxs)(
  "svg",
  {
    width: "100%",
    height: "100%",
    viewBox: "0 0 155 155",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: icon.foreground,
    children: [
      (0, import_jsx_runtime32.jsx)("title", { children: "BaseScan" }),
      (0, import_jsx_runtime32.jsxs)("g", { clipPath: "url(#clip0_13027_2497)", children: [
        (0, import_jsx_runtime32.jsx)(
          "mask",
          {
            id: "mask0_13027_2497",
            maskUnits: "userSpaceOnUse",
            x: "0",
            y: "0",
            width: "155",
            height: "155",
            children: (0, import_jsx_runtime32.jsx)("path", { d: "M155 0H0V155H155V0Z", fill: "white" })
          }
        ),
        (0, import_jsx_runtime32.jsxs)("g", { mask: "url(#mask0_13027_2497)", children: [
          (0, import_jsx_runtime32.jsx)(
            "path",
            {
              d: "M32.6921 73.9892C32.6923 73.1255 32.8626 72.2709 33.1934 71.4736C33.5243 70.6763 34.009 69.9526 34.6198 69.344C35.2306 68.7349 35.9555 68.2524 36.7528 67.9249C37.5501 67.5974 38.4041 67.4309 39.2658 67.4352L50.165 67.4708C51.9029 67.4708 53.5694 68.1625 54.7982 69.3935C56.0269 70.6244 56.7173 72.2938 56.7173 74.035V115.321C57.9442 114.956 59.5201 114.567 61.2447 114.161C62.4425 113.879 63.51 113.2 64.2735 112.234C65.0377 111.268 65.4532 110.071 65.4532 108.838V57.6245C65.4532 55.8834 66.1432 54.2137 67.3723 52.9825C68.6009 51.7513 70.2673 51.0594 72.0054 51.059H82.926C84.6642 51.0594 86.3306 51.7513 87.5591 52.9825C88.7883 54.2137 89.4782 55.8834 89.4782 57.6245V105.156C89.4782 105.156 92.2127 104.048 94.8761 102.921C95.8652 102.502 96.7096 101.801 97.3036 100.904C97.8977 100.007 98.2143 98.955 98.2155 97.8785V41.2141C98.2155 39.4734 98.9055 37.804 100.134 36.573C101.363 35.342 103.029 34.6503 104.767 34.65H115.687C117.425 34.65 119.092 35.3415 120.32 36.5726C121.549 37.8036 122.239 39.4732 122.239 41.2141V87.8759C131.708 81.0016 141.303 72.7341 148.917 62.793C150.021 61.3498 150.752 59.6554 151.044 57.8606C151.336 56.0659 151.18 54.2266 150.59 52.5069C147.066 42.3477 141.463 33.0375 134.141 25.172C126.819 17.3065 117.938 11.059 108.067 6.82926C98.1968 2.59956 87.5531 0.480761 76.8183 0.608476C66.0835 0.736197 55.4931 3.10763 45.7254 7.57097C35.9578 12.0344 27.2278 18.4914 20.0941 26.5289C12.9603 34.5663 7.58002 44.0072 4.29747 54.2474C1.01488 64.4878 -0.0977017 75.3016 1.03092 85.9972C2.15954 96.6928 5.50451 107.035 10.8518 116.361C11.7833 117.97 13.1537 119.279 14.8021 120.135C16.4504 120.99 18.3083 121.356 20.1573 121.191C22.223 121.01 24.7949 120.752 27.8528 120.391C29.1839 120.24 30.4129 119.604 31.3056 118.603C32.1982 117.602 32.6923 116.307 32.6933 114.965V73.9892",
              fill: "white"
            }
          ),
          (0, import_jsx_runtime32.jsx)(
            "path",
            {
              d: "M32.6921 73.9892C32.6923 73.1255 32.8626 72.2709 33.1934 71.4736C33.5243 70.6763 34.009 69.9526 34.6198 69.344C35.2306 68.7349 35.9555 68.2524 36.7528 67.9249C37.5501 67.5974 38.4041 67.4309 39.2658 67.4352L50.165 67.4708C51.9029 67.4708 53.5694 68.1625 54.7982 69.3935C56.0269 70.6244 56.7173 72.2938 56.7173 74.035V115.321C57.9442 114.956 59.5201 114.567 61.2447 114.161C62.4425 113.879 63.51 113.2 64.2735 112.234C65.0377 111.268 65.4532 110.071 65.4532 108.838V57.6245C65.4532 55.8834 66.1432 54.2137 67.3723 52.9825C68.6009 51.7513 70.2673 51.0594 72.0054 51.059H82.926C84.6642 51.0594 86.3306 51.7513 87.5591 52.9825C88.7883 54.2137 89.4782 55.8834 89.4782 57.6245V105.156C89.4782 105.156 92.2127 104.048 94.8761 102.921C95.8652 102.502 96.7096 101.801 97.3036 100.904C97.8977 100.007 98.2143 98.955 98.2155 97.8785V41.2141C98.2155 39.4734 98.9055 37.804 100.134 36.573C101.363 35.342 103.029 34.6503 104.767 34.65H115.687C117.425 34.65 119.092 35.3415 120.32 36.5726C121.549 37.8036 122.239 39.4732 122.239 41.2141V87.8759C131.708 81.0016 141.303 72.7341 148.917 62.793C150.021 61.3498 150.752 59.6554 151.044 57.8606C151.336 56.0659 151.18 54.2266 150.59 52.5069C147.066 42.3477 141.463 33.0375 134.141 25.172C126.819 17.3065 117.938 11.059 108.067 6.82926C98.1968 2.59956 87.5531 0.480761 76.8183 0.608476C66.0835 0.736197 55.4931 3.10763 45.7254 7.57097C35.9578 12.0344 27.2278 18.4914 20.0941 26.5289C12.9603 34.5663 7.58002 44.0072 4.29747 54.2474C1.01488 64.4878 -0.0977017 75.3016 1.03092 85.9972C2.15954 96.6928 5.50451 107.035 10.8518 116.361C11.7833 117.97 13.1537 119.279 14.8021 120.135C16.4504 120.99 18.3083 121.356 20.1573 121.191C22.223 121.01 24.7949 120.752 27.8528 120.391C29.1839 120.24 30.4129 119.604 31.3056 118.603C32.1982 117.602 32.6923 116.307 32.6933 114.965V73.9892",
              stroke: "white"
            }
          ),
          (0, import_jsx_runtime32.jsx)(
            "path",
            {
              d: "M32.4531 140.209C43.9644 148.599 57.5682 153.635 71.7594 154.759C85.9501 155.884 100.175 153.054 112.86 146.581C125.545 140.109 136.195 130.248 143.632 118.088C151.07 105.927 155.004 91.9428 155 77.6816C155 75.9024 154.918 74.1419 154.8 72.3911C126.608 114.514 74.5543 134.207 32.4557 140.203",
              fill: "#C0D0DB"
            }
          )
        ] })
      ] }),
      (0, import_jsx_runtime32.jsx)("defs", { children: (0, import_jsx_runtime32.jsx)("clipPath", { id: "clip0_13027_2497", children: (0, import_jsx_runtime32.jsx)("rect", { width: "155", height: "155", fill: "white" }) }) })
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/disconnectSvg.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var disconnectSvg = (0, import_jsx_runtime33.jsxs)(
  "svg",
  {
    role: "img",
    "aria-label": "ock-disconnect-svg",
    width: "100%",
    height: "100%",
    viewBox: "0 0 16 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime33.jsx)("title", { children: "Disconnect" }),
      (0, import_jsx_runtime33.jsx)(
        "path",
        {
          d: "M11.0668 0.91803L11.0668 2.93852L2.02049 2.93852L2.02049 15.0615L11.0668 15.0615L11.0668 17.082L-7.06549e-07 17.082L0 0.918029L11.0668 0.91803Z",
          className: icon.foreground
        }
      ),
      (0, import_jsx_runtime33.jsx)(
        "path",
        {
          d: "M12.3273 12.8963L16.0002 9.02606L12.346 4.95902L10.843 6.30941L12.3623 8.00032L5.53321 8.00032L5.53321 10.0208L12.2706 10.0208L10.8617 11.5054L12.3273 12.8963Z",
          className: icon.foreground
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/qrIconSvg.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var qrIconSvg = (0, import_jsx_runtime34.jsxs)(
  "svg",
  {
    width: "100%",
    height: "100%",
    viewBox: "0 0 28 28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime34.jsx)("title", { children: "QR Code" }),
      (0, import_jsx_runtime34.jsx)("rect", { width: "28", height: "28", rx: "8", className: background.default }),
      (0, import_jsx_runtime34.jsx)("path", { d: "M10 10H11.5V11.5H10V10Z", className: icon.foreground }),
      (0, import_jsx_runtime34.jsx)(
        "path",
        {
          d: "M8 13.5H13.5V8H8V13.5ZM9.25 9.25H12.25V12.25H9.25V9.25Z",
          className: icon.foreground
        }
      ),
      (0, import_jsx_runtime34.jsx)("path", { d: "M18 10H16.5V11.5H18V10Z", className: icon.foreground }),
      (0, import_jsx_runtime34.jsx)(
        "path",
        {
          d: "M14.5 8V13.5H20V8H14.5ZM18.75 12.25H15.75V9.25H18.75V12.25Z",
          className: icon.foreground
        }
      ),
      (0, import_jsx_runtime34.jsx)("path", { d: "M10 16.5H11.5V18H10V16.5Z", className: icon.foreground }),
      (0, import_jsx_runtime34.jsx)(
        "path",
        {
          d: "M8 20H13.5V14.5H8V20ZM9.25 15.75H12.25V18.75H9.25V15.75Z",
          className: icon.foreground
        }
      ),
      (0, import_jsx_runtime34.jsx)(
        "path",
        {
          d: "M18 16.75H18.75V14.5H20V18H16.75V15.75H15.75V20H14.5V14.5H18V16.75Z",
          className: icon.foreground
        }
      ),
      (0, import_jsx_runtime34.jsx)("path", { d: "M18 18.75H16.75V20H18V18.75Z", className: icon.foreground }),
      (0, import_jsx_runtime34.jsx)("path", { d: "M18.75 18.75H20V20H18.75V18.75Z", className: icon.foreground })
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/refreshSvg.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var refreshSvg = (0, import_jsx_runtime35.jsxs)(
  "svg",
  {
    width: "100%",
    height: "100%",
    viewBox: "0 0 32 32",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime35.jsx)("title", { children: "Refresh" }),
      (0, import_jsx_runtime35.jsx)(
        "path",
        {
          d: "M15.9852 5.32694C10.0942 5.32694 5.31852 10.1026 5.31852 15.9936C5.31852 21.8846 10.0942 26.6603 15.9852 26.6603C21.4247 26.6603 25.9132 22.5887 26.5693 17.3269H29.2527C28.5837 24.0647 22.899 29.3269 15.9852 29.3269C8.62139 29.3269 2.65186 23.3574 2.65186 15.9936C2.65186 8.62982 8.62139 2.66028 15.9852 2.66028C20.3471 2.66028 24.2197 4.7548 26.6523 7.99294L29.3184 5.3269V13.3269H21.3184L24.7428 9.90246C22.8156 7.13675 19.6117 5.32694 15.9852 5.32694Z",
          className: icon.foreground
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedWalletActions.js
var import_react19 = __toESM(require_react(), 1);
function WalletAdvancedWalletActions({
  classNames
}) {
  const { address } = useAccount();
  const { handleClose, setActiveFeature, animations } = useWalletContext();
  const { disconnect, connectors } = useDisconnect();
  const { sendAnalytics } = useAnalytics();
  const { refetch: refetchPortfolioData } = usePortfolio(
    { address },
    RequestContext.Wallet
  );
  const handleAnalyticsOptionSelected = (0, import_react19.useCallback)(
    (option) => {
      sendAnalytics(WalletEvent.OptionSelected, {
        option
      });
    },
    [sendAnalytics]
  );
  const handleAnalyticsDisconnect = (0, import_react19.useCallback)(
    (walletProvider) => {
      sendAnalytics(WalletEvent.Disconnect, {
        component: "WalletAdvanced",
        walletProvider
      });
    },
    [sendAnalytics]
  );
  const handleTransactions = (0, import_react19.useCallback)(() => {
    handleAnalyticsOptionSelected(WalletOption.Explorer);
    window.open(`https://basescan.org/address/${address}`, "_blank");
  }, [address, handleAnalyticsOptionSelected]);
  const handleDisconnect = (0, import_react19.useCallback)(() => {
    var _a;
    const walletProvider = ((_a = connectors[0]) == null ? void 0 : _a.name) || "unknown";
    handleAnalyticsDisconnect(walletProvider);
    handleClose();
    for (const connector of connectors) {
      disconnect({ connector });
    }
  }, [disconnect, connectors, handleClose, handleAnalyticsDisconnect]);
  const handleQr = (0, import_react19.useCallback)(() => {
    handleAnalyticsOptionSelected(WalletOption.QR);
    setActiveFeature("qr");
  }, [setActiveFeature, handleAnalyticsOptionSelected]);
  const handleRefreshPortfolioData = (0, import_react19.useCallback)(async () => {
    handleAnalyticsOptionSelected(WalletOption.Refresh);
    await refetchPortfolioData();
  }, [refetchPortfolioData, handleAnalyticsOptionSelected]);
  return (0, import_jsx_runtime36.jsxs)(
    "div",
    {
      "data-testid": "ockWalletAdvanced_WalletActions",
      className: cn(
        "flex w-88 items-center justify-between px-4 py-3",
        animations.content,
        classNames == null ? void 0 : classNames.container
      ),
      children: [
        (0, import_jsx_runtime36.jsxs)("div", { className: "flex items-center", children: [
          (0, import_jsx_runtime36.jsx)(
            PressableIcon,
            {
              ariaLabel: "Open transaction history",
              onClick: handleTransactions,
              children: (0, import_jsx_runtime36.jsx)(
                "div",
                {
                  "data-testid": "ockWalletAdvanced_TransactionsButton",
                  className: cn("h-7 w-7 scale-110 p-2", classNames == null ? void 0 : classNames.baseScanIcon),
                  children: baseScanSvg
                }
              )
            }
          ),
          (0, import_jsx_runtime36.jsx)(PressableIcon, { ariaLabel: "Show QR code", onClick: handleQr, children: (0, import_jsx_runtime36.jsx)(
            "div",
            {
              "data-testid": "ockWalletAdvanced_QrButton",
              className: cn("h-7 w-7 scale-110", classNames == null ? void 0 : classNames.qrIcon),
              children: qrIconSvg
            }
          ) })
        ] }),
        (0, import_jsx_runtime36.jsxs)("div", { className: "flex items-center", children: [
          (0, import_jsx_runtime36.jsx)(PressableIcon, { ariaLabel: "Disconnect wallet", onClick: handleDisconnect, children: (0, import_jsx_runtime36.jsx)(
            "div",
            {
              "data-testid": "ockWalletAdvanced_DisconnectButton",
              className: cn("h-7 w-7 scale-110 p-2", classNames == null ? void 0 : classNames.disconnectIcon),
              children: disconnectSvg
            }
          ) }),
          (0, import_jsx_runtime36.jsx)(
            PressableIcon,
            {
              ariaLabel: "Refresh portfolio data",
              onClick: handleRefreshPortfolioData,
              children: (0, import_jsx_runtime36.jsx)(
                "div",
                {
                  "data-testid": "ockWalletAdvanced_RefreshButton",
                  className: cn("h-7 w-7 scale-110 p-2", classNames == null ? void 0 : classNames.refreshIcon),
                  children: refreshSvg
                }
              )
            }
          )
        ] })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletDropdownContent.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/BottomSheet.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
function BottomSheet({
  children,
  className,
  isOpen,
  onClose,
  triggerRef,
  "aria-label": ariaLabel,
  "aria-labelledby": ariaLabelledby,
  "aria-describedby": ariaDescribedby
}) {
  const componentTheme = useTheme();
  if (!isOpen) {
    return null;
  }
  const bottomSheet = (0, import_jsx_runtime37.jsx)("div", { "data-portal-origin": "true", children: (0, import_jsx_runtime37.jsx)(FocusTrap, { active: isOpen, children: (0, import_jsx_runtime37.jsx)(
    DismissableLayer,
    {
      onDismiss: onClose,
      triggerRef,
      preventTriggerEvents: !!triggerRef,
      children: (0, import_jsx_runtime37.jsx)(
        "div",
        {
          "aria-describedby": ariaDescribedby,
          "aria-label": ariaLabel,
          "aria-labelledby": ariaLabelledby,
          "data-testid": "ockBottomSheet",
          role: "dialog",
          className: cn(
            componentTheme,
            background.default,
            zIndex.modal,
            "fixed right-0 bottom-0 left-0",
            "transform rounded-t-3xl p-2 transition-transform",
            "fade-in slide-in-from-bottom-1/2 animate-in",
            className
          ),
          children
        }
      )
    }
  ) }) });
  return (0, import_react_dom3.createPortal)(bottomSheet, document.body);
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletDropdownContent.js
var import_react71 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedQrReceive.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/CopyButton.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);
function CopyButton({
  label,
  copyValue,
  onSuccess,
  onError,
  className,
  "aria-label": ariaLabel
}) {
  const handleCopy = (0, import_react20.useCallback)(
    () => copyToClipboard({ copyValue, onSuccess, onError }),
    [copyValue, onSuccess, onError]
  );
  return (0, import_jsx_runtime38.jsx)(
    "button",
    {
      type: "button",
      "data-testid": "ockCopyButton",
      className,
      onClick: handleCopy,
      onKeyDown: handleCopy,
      "aria-label": ariaLabel,
      children: label
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/internal/components/QrCode/QrCodeSvg.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/QrCode/gradientConstants.js
var QR_CODE_SIZE = 237;
var QR_LOGO_SIZE = 50;
var QR_LOGO_RADIUS = 10;
var QR_LOGO_BACKGROUND_COLOR = "#ffffff";
var GRADIENT_START_COORDINATES = { x: 0, y: 0 };
var GRADIENT_END_COORDINATES = { x: 1, y: 0 };
var ockThemeToLinearGradientColorMap = {
  default: "blue",
  base: "baseBlue",
  cyberpunk: "pink",
  hacker: "black"
};
var ockThemeToRadialGradientColorMap = {
  default: "default",
  base: "blue",
  cyberpunk: "magenta",
  hacker: "black"
};
var linearGradientStops = {
  blue: {
    startColor: "#266EFF",
    endColor: "#45E1E5"
  },
  pink: {
    startColor: "#EE5A67",
    endColor: "#CE46BD"
  },
  black: {
    startColor: "#a1a1aa",
    endColor: "#27272a"
  },
  baseBlue: {
    startColor: "#0052ff",
    endColor: "#b2cbff"
  }
};
var presetGradients = {
  default: [
    ["#0F27FF", "39.06%"],
    ["#6100FF", "76.56%"],
    ["#201F1D", "100%"]
  ],
  blue: [
    ["#0F6FFF", "39.06%"],
    ["#0F27FF", "76.56%"],
    ["#201F1D", "100%"]
  ],
  magenta: [
    ["#CF00F1", "36.46%"],
    ["#7900F1", "68.58%"],
    ["#201F1D", "100%"]
  ],
  black: [
    ["#d4d4d8", "36.46%"],
    ["#201F1D", "68.58%"],
    ["#201F1D", "100%"]
  ]
};

// node_modules/@coinbase/onchainkit/dist/internal/components/QrCode/useCorners.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/QrCode/useDotsPath.js
var import_react21 = __toESM(require_react(), 1);
var squareMask = [
  [1, 1, 1, 1, 1, 1, 1],
  [1, 0, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 0, 0, 1],
  [1, 0, 0, 0, 0, 0, 1],
  [1, 1, 1, 1, 1, 1, 1]
];
var dotMask = [
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 1, 1, 1, 0, 0],
  [0, 0, 1, 1, 1, 0, 0],
  [0, 0, 1, 1, 1, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0]
];
function getDistance(x1, y1, x2, y2) {
  return Math.sqrt((y2 - y1) ** 2 + (x2 - x1) ** 2);
}
function shouldSkipMaskedCell(i, j, matrixLength) {
  var _a, _b, _c, _d, _e, _f;
  return Boolean(
    ((_a = squareMask[i]) == null ? void 0 : _a[j]) || ((_b = squareMask[i - matrixLength + CORNER_SIZE]) == null ? void 0 : _b[j]) || ((_c = squareMask[i]) == null ? void 0 : _c[j - matrixLength + CORNER_SIZE]) || ((_d = dotMask[i]) == null ? void 0 : _d[j]) || ((_e = dotMask[i - matrixLength + CORNER_SIZE]) == null ? void 0 : _e[j]) || ((_f = dotMask[i]) == null ? void 0 : _f[j - matrixLength + CORNER_SIZE])
  );
}
function shouldSkipLogoArea(i, j, {
  hasLogo,
  logoSize,
  logoMargin,
  logoBorderRadius,
  matrixLength,
  dotSize
}) {
  if (!hasLogo) {
    return false;
  }
  const logoAndMarginTotalSize = logoSize + logoMargin * 2;
  const logoSizeInDots = logoAndMarginTotalSize / dotSize;
  const midpoint = Math.floor(matrixLength / 2);
  const isRoundLogo = logoBorderRadius >= logoSize / 2;
  if (isRoundLogo) {
    const logoRadiusInDots = logoSizeInDots / 2;
    const distFromMiddleInDots = getDistance(j, i, midpoint, midpoint);
    return distFromMiddleInDots - 0.5 <= logoRadiusInDots;
  }
  const numDotsOffCenterToHide = Math.ceil(logoSizeInDots / 2);
  return i <= midpoint + numDotsOffCenterToHide && i >= midpoint - numDotsOffCenterToHide && j <= midpoint + numDotsOffCenterToHide && j >= midpoint - numDotsOffCenterToHide;
}
function getDotPath(centerX, centerY, radius) {
  return `
    M ${centerX - radius} ${centerY}
    A ${radius} ${radius} 0 1 1 ${centerX + radius} ${centerY}
    A ${radius} ${radius} 0 1 1 ${centerX - radius} ${centerY}`;
}
var CORNER_SIZE = 7;
function useDotsPath({
  matrix,
  size,
  logoSize,
  logoMargin,
  logoBorderRadius,
  hasLogo
}) {
  const dotsPath = (0, import_react21.useMemo)(() => {
    const cellSize = size / matrix.length;
    let path = "";
    const matrixLength = matrix.length;
    const dotSize = size / matrixLength;
    matrix.forEach((row, i) => {
      row.forEach((column, j) => {
        if (shouldSkipMaskedCell(i, j, matrixLength) || shouldSkipLogoArea(i, j, {
          hasLogo,
          logoSize,
          logoMargin,
          logoBorderRadius,
          matrixLength,
          dotSize
        })) {
          return;
        }
        if (column) {
          const centerX = cellSize * j + cellSize / 2;
          const centerY = cellSize * i + cellSize / 2;
          path += getDotPath(centerX, centerY, cellSize / 2);
        }
      });
    });
    return path;
  }, [hasLogo, logoBorderRadius, logoMargin, logoSize, matrix, size]);
  return dotsPath;
}

// node_modules/@coinbase/onchainkit/dist/internal/components/QrCode/useCorners.js
function useCorners(size, matrixLength, backgroundColor, fillColor, uid) {
  const dotSize = size / matrixLength;
  const rectSize = dotSize * CORNER_SIZE;
  const circleRadius = dotSize * 2;
  const circleStrokeWidth = dotSize + 1;
  const corners = (0, import_react22.useMemo)(
    () => (0, import_jsx_runtime39.jsxs)("g", { children: [
      (0, import_jsx_runtime39.jsx)(
        "rect",
        {
          x: 0,
          y: 0,
          rx: 9.5,
          ry: 9.5,
          width: rectSize,
          height: rectSize,
          fill: fillColor,
          id: `Corner-top-left-${uid}`
        }
      ),
      (0, import_jsx_runtime39.jsx)(
        "rect",
        {
          x: 0,
          y: size - rectSize,
          rx: 9.5,
          ry: 9.5,
          width: rectSize,
          height: rectSize,
          fill: fillColor,
          id: `Corner-bottom-left-${uid}`
        }
      ),
      (0, import_jsx_runtime39.jsx)(
        "rect",
        {
          x: size - rectSize,
          y: 0,
          rx: 9.5,
          ry: 9.5,
          width: rectSize,
          height: rectSize,
          fill: fillColor,
          id: `Corner-top-right-${uid}`
        }
      ),
      (0, import_jsx_runtime39.jsx)(
        "circle",
        {
          cx: rectSize / 2,
          cy: rectSize / 2,
          r: circleRadius,
          stroke: backgroundColor,
          strokeWidth: circleStrokeWidth,
          fill: "none"
        }
      ),
      (0, import_jsx_runtime39.jsx)(
        "circle",
        {
          cx: rectSize / 2,
          cy: size - rectSize / 2,
          r: circleRadius,
          stroke: backgroundColor,
          strokeWidth: circleStrokeWidth,
          fill: "none"
        }
      ),
      (0, import_jsx_runtime39.jsx)(
        "circle",
        {
          cx: size - rectSize / 2,
          cy: rectSize / 2,
          r: circleRadius,
          stroke: backgroundColor,
          strokeWidth: circleStrokeWidth,
          fill: "none"
        }
      )
    ] }),
    [
      backgroundColor,
      circleRadius,
      circleStrokeWidth,
      fillColor,
      rectSize,
      size,
      uid
    ]
  );
  return corners;
}

// node_modules/@coinbase/onchainkit/dist/internal/components/QrCode/useLogo.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);
var import_server = __toESM(require_server_browser(), 1);
var defaultSvgString = import_server.default.renderToString(coinbaseWalletSvg);
var defaultSvgDataUri = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(
  defaultSvgString
)}`;
function useLogo({
  size,
  logo = defaultSvgDataUri,
  logoSize,
  logoBackgroundColor,
  logoMargin,
  logoBorderRadius
}) {
  const svgLogo = (0, import_react23.useMemo)(() => {
    const transformedLogo = import_react23.default.isValidElement(logo) ? `data:image/svg+xml;charset=utf-8,${encodeURIComponent(
      import_server.default.renderToString(logo)
    )}` : logo;
    const logoPosition = (size - logoSize - logoMargin * 2) / 2;
    const logoBackgroundSize = logoSize + logoMargin * 2;
    return (0, import_jsx_runtime40.jsxs)("g", { transform: `translate(${logoPosition}, ${logoPosition})`, children: [
      (0, import_jsx_runtime40.jsx)("defs", { children: (0, import_jsx_runtime40.jsx)("clipPath", { id: "clip-logo", children: (0, import_jsx_runtime40.jsx)(
        "rect",
        {
          width: logoSize,
          height: logoSize,
          rx: logoBorderRadius,
          ry: logoBorderRadius
        }
      ) }) }),
      (0, import_jsx_runtime40.jsx)("g", { children: (0, import_jsx_runtime40.jsx)(
        "rect",
        {
          width: logoBackgroundSize,
          height: logoBackgroundSize,
          rx: logoBorderRadius,
          ry: logoBorderRadius,
          fill: logoBackgroundColor
        }
      ) }),
      (0, import_jsx_runtime40.jsx)("g", { transform: `translate(${logoMargin}, ${logoMargin})`, children: (0, import_jsx_runtime40.jsx)(
        "image",
        {
          "data-testid": "qr-code-logo",
          width: logoSize,
          height: logoSize,
          preserveAspectRatio: "xMidYMid slice",
          href: String(transformedLogo),
          clipPath: "url(#clip-logo)"
        }
      ) })
    ] });
  }, [logo, logoBackgroundColor, logoBorderRadius, logoMargin, logoSize, size]);
  return svgLogo;
}

// node_modules/@coinbase/onchainkit/dist/internal/components/QrCode/useMatrix.js
var import_qrcode = __toESM(require_browser(), 1);
var import_react24 = __toESM(require_react(), 1);
function useMatrix(errorCorrectionLevel, value) {
  const matrix = (0, import_react24.useMemo)(() => {
    if (!value) {
      return [];
    }
    const transformedValue = `ethereum:${value}`;
    const arr = Array.from(
      import_qrcode.default.create(transformedValue, { errorCorrectionLevel }).modules.data
    );
    const sqrt = Math.sqrt(arr.length);
    return arr.reduce((rows, key, index) => {
      if (index % sqrt === 0) {
        rows.push([key]);
      } else {
        rows[rows.length - 1].push(key);
      }
      return rows;
    }, []);
  }, [errorCorrectionLevel, value]);
  return matrix;
}

// node_modules/@coinbase/onchainkit/dist/internal/components/QrCode/QrCodeSvg.js
function coordinateAsPercentage(coordinate) {
  return `${coordinate * 100}%`;
}
function QrCodeSvg({
  value,
  size = QR_CODE_SIZE,
  backgroundColor = "#ffffff",
  logo,
  logoSize = QR_LOGO_SIZE,
  logoBackgroundColor = QR_LOGO_BACKGROUND_COLOR,
  logoMargin = 5,
  logoBorderRadius = QR_LOGO_RADIUS,
  quietZone = 12,
  quietZoneBorderRadius = 10,
  ecl = "Q",
  gradientType = "radial"
}) {
  const gradientRadius = size * 0.55;
  const gradientCenterPoint = size / 2;
  const uid = (0, import_react25.useId)();
  const theme = useTheme();
  const themeName = theme.split("-")[0];
  const isRadialGradient = gradientType === "radial";
  const fillColor = isRadialGradient ? `url(#radialGrad-${uid})` : "#000000";
  const bgColor = isRadialGradient ? backgroundColor : `url(#linearGrad-${uid})`;
  const linearGradientColor = ockThemeToLinearGradientColorMap[themeName] ?? ockThemeToLinearGradientColorMap.default;
  const linearColors = [
    linearGradientStops[linearGradientColor].startColor,
    linearGradientStops[linearGradientColor].endColor
  ];
  const radialGradientColor = ockThemeToRadialGradientColorMap[themeName] ?? ockThemeToRadialGradientColorMap.default;
  const presetGradientForColor = presetGradients[radialGradientColor];
  const matrix = useMatrix(ecl, value);
  const corners = useCorners(size, matrix.length, bgColor, fillColor, uid);
  const { x: x1, y: y1 } = GRADIENT_START_COORDINATES;
  const { x: x2, y: y2 } = GRADIENT_END_COORDINATES;
  const viewBox = (0, import_react25.useMemo)(() => {
    return [
      -quietZone,
      -quietZone,
      size + quietZone * 2,
      size + quietZone * 2
    ].join(" ");
  }, [quietZone, size]);
  const svgLogo = useLogo({
    size,
    logo,
    logoSize,
    logoBackgroundColor,
    logoMargin,
    logoBorderRadius
  });
  const path = useDotsPath({
    matrix,
    size,
    logoSize,
    logoMargin,
    logoBorderRadius,
    hasLogo: !!logo
  });
  if (!path || !value) {
    return null;
  }
  return (0, import_jsx_runtime41.jsxs)("svg", { viewBox, width: size, height: size, children: [
    (0, import_jsx_runtime41.jsx)("title", { children: "QR Code" }),
    (0, import_jsx_runtime41.jsx)("defs", { children: isRadialGradient ? (0, import_jsx_runtime41.jsx)(
      "radialGradient",
      {
        id: `radialGrad-${uid}`,
        "data-testid": "radialGrad",
        rx: gradientRadius,
        ry: gradientRadius,
        cx: gradientCenterPoint,
        cy: gradientCenterPoint,
        gradientUnits: "userSpaceOnUse",
        children: presetGradientForColor.map(([gradientColor, offset]) => (0, import_jsx_runtime41.jsx)(
          "stop",
          {
            offset,
            stopColor: gradientColor,
            stopOpacity: 1
          },
          `${gradientColor}${offset}`
        ))
      }
    ) : (0, import_jsx_runtime41.jsxs)(
      "linearGradient",
      {
        id: `linearGrad-${uid}`,
        "data-testid": "linearGrad",
        x1: coordinateAsPercentage(x1),
        y1: coordinateAsPercentage(y1),
        x2: coordinateAsPercentage(x2),
        y2: coordinateAsPercentage(y2),
        gradientUnits: "userSpaceOnUse",
        children: [
          (0, import_jsx_runtime41.jsx)("stop", { offset: "0", stopColor: linearColors[0] }),
          (0, import_jsx_runtime41.jsx)("stop", { offset: "1", stopColor: linearColors[1] })
        ]
      }
    ) }),
    (0, import_jsx_runtime41.jsx)("g", { children: (0, import_jsx_runtime41.jsx)(
      "rect",
      {
        rx: quietZoneBorderRadius,
        ry: quietZoneBorderRadius,
        x: -quietZone,
        y: -quietZone,
        width: size + quietZone * 2,
        height: size + quietZone * 2,
        fill: backgroundColor,
        stroke: bgColor,
        strokeWidth: 2
      }
    ) }),
    (0, import_jsx_runtime41.jsxs)("g", { children: [
      (0, import_jsx_runtime41.jsx)(
        "path",
        {
          d: path,
          fill: fillColor,
          strokeLinecap: "butt",
          stroke: fillColor,
          strokeWidth: 0,
          opacity: 0.6
        }
      ),
      corners,
      svgLogo
    ] })
  ] });
}

// node_modules/@coinbase/onchainkit/dist/internal/svg/backArrowSvg.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var backArrowSvg = (0, import_jsx_runtime42.jsxs)(
  "svg",
  {
    width: "12",
    height: "13",
    viewBox: "0 0 12 13",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime42.jsx)("title", { children: "Back Arrow" }),
      (0, import_jsx_runtime42.jsx)(
        "path",
        {
          d: "M5.54479 12.077L6.46623 11.2323L2.42062 6.81894H11.9999V5.56894H2.50874L6.88374 1.19394L5.99985 0.310059L0.134766 6.17515L5.54479 12.077Z",
          className: icon.foreground
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/copySvg.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var copySvg = (0, import_jsx_runtime43.jsxs)(
  "svg",
  {
    width: "12",
    height: "12",
    viewBox: "0 0 12 12",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime43.jsx)("title", { children: "Copy" }),
      (0, import_jsx_runtime43.jsx)(
        "path",
        {
          d: "M0.666016 0H9.33268V9.33333H0.666016V0ZM1.99935 1.33333V8H7.99935V1.33333H1.99935Z",
          className: icon.foreground
        }
      ),
      (0, import_jsx_runtime43.jsx)(
        "path",
        {
          d: "M10.666 3.33333H11.9993V12H4.66602V10.6667H10.666V3.33333Z",
          className: icon.foreground
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedQrReceive.js
var import_react26 = __toESM(require_react(), 1);
function WalletAdvancedQrReceive({
  classNames
}) {
  const {
    address,
    setActiveFeature,
    isActiveFeatureClosing,
    setIsActiveFeatureClosing
  } = useWalletContext();
  const [copyText, setCopyText] = (0, import_react26.useState)("Copy");
  const [copyButtonText, setCopyButtonText] = (0, import_react26.useState)("Copy address");
  const handleCloseQr = (0, import_react26.useCallback)(() => {
    setIsActiveFeatureClosing(true);
  }, [setIsActiveFeatureClosing]);
  const handleAnimationEnd = (0, import_react26.useCallback)(() => {
    if (isActiveFeatureClosing) {
      setActiveFeature(null);
      setIsActiveFeatureClosing(false);
    }
  }, [isActiveFeatureClosing, setActiveFeature, setIsActiveFeatureClosing]);
  const resetAffordanceText = (0, import_react26.useCallback)(() => {
    setTimeout(() => {
      setCopyText("Copy");
      setCopyButtonText("Copy address");
    }, 2e3);
  }, []);
  const handleCopyButtonSuccess = (0, import_react26.useCallback)(() => {
    setCopyButtonText("Address copied");
    resetAffordanceText();
  }, [resetAffordanceText]);
  const handleCopyButtonError = (0, import_react26.useCallback)(() => {
    setCopyButtonText("Failed to copy address");
    resetAffordanceText();
  }, [resetAffordanceText]);
  const handleCopyIconSuccess = (0, import_react26.useCallback)(() => {
    setCopyText("Copied");
    resetAffordanceText();
  }, [resetAffordanceText]);
  const handleCopyIconError = (0, import_react26.useCallback)(() => {
    setCopyText("Failed to copy");
    resetAffordanceText();
  }, [resetAffordanceText]);
  return (0, import_jsx_runtime44.jsxs)(
    "div",
    {
      "data-testid": "ockWalletAdvancedQrReceive",
      className: cn(
        border.radius,
        color.foreground,
        text.headline,
        "flex flex-col items-center justify-between",
        "h-120 w-88 px-4 pt-3 pb-4",
        isActiveFeatureClosing ? "fade-out slide-out-to-left-5 animate-out fill-mode-forwards ease-in-out" : "fade-in slide-in-from-left-5 linear animate-in duration-150",
        classNames == null ? void 0 : classNames.container
      ),
      onAnimationEnd: handleAnimationEnd,
      children: [
        (0, import_jsx_runtime44.jsxs)(
          "div",
          {
            className: cn(
              "flex h-[34px] w-full flex-row items-center justify-between",
              classNames == null ? void 0 : classNames.header
            ),
            children: [
              (0, import_jsx_runtime44.jsx)(PressableIcon, { ariaLabel: "Back button", onClick: handleCloseQr, children: (0, import_jsx_runtime44.jsx)("div", { className: "p-2", children: backArrowSvg }) }),
              (0, import_jsx_runtime44.jsx)("span", { children: "Scan to receive" }),
              (0, import_jsx_runtime44.jsxs)("div", { className: "group relative", children: [
                (0, import_jsx_runtime44.jsx)(
                  CopyButton,
                  {
                    label: copySvg,
                    copyValue: address ?? "",
                    onSuccess: handleCopyIconSuccess,
                    onError: handleCopyIconError,
                    className: cn(
                      pressable.default,
                      border.radiusInner,
                      border.default,
                      "flex items-center justify-center p-2"
                    ),
                    "aria-label": "Copy your address by clicking the icon"
                  }
                ),
                (0, import_jsx_runtime44.jsx)(
                  CopyButton,
                  {
                    label: copyText,
                    copyValue: address ?? "",
                    onSuccess: handleCopyIconSuccess,
                    onError: handleCopyIconError,
                    className: cn(
                      pressable.alternate,
                      text.legal,
                      color.foreground,
                      border.default,
                      border.radius,
                      zIndex.dropdown,
                      "absolute top-full right-0 mt-0.5 px-1.5 py-0.5 opacity-0 transition-opacity group-hover:opacity-100"
                    ),
                    "aria-label": "Copy your address by clicking the tooltip"
                  }
                )
              ] })
            ]
          }
        ),
        (0, import_jsx_runtime44.jsx)(QrCodeSvg, { value: address }),
        (0, import_jsx_runtime44.jsx)(
          CopyButton,
          {
            copyValue: address ?? "",
            label: copyButtonText,
            className: cn(
              border.radius,
              pressable.alternate,
              "w-full p-3",
              classNames == null ? void 0 : classNames.copyButton
            ),
            onSuccess: handleCopyButtonSuccess,
            onError: handleCopyButtonError,
            "aria-label": "Copy your address by clicking the button"
          }
        )
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedSwap.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/swap/components/Swap.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapAmountInput.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react35 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/utils/isValidAmount.js
function isValidAmount(value) {
  if (value === "") {
    return true;
  }
  const regex = /^[0-9]*\.?[0-9]*$/;
  return regex.test(value);
}

// node_modules/@coinbase/onchainkit/dist/token/components/TokenChip.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
function TokenChip({
  token,
  onClick,
  className,
  isPressable = true
}) {
  const componentTheme = useTheme();
  return (0, import_jsx_runtime45.jsxs)(
    "button",
    {
      type: "button",
      "data-testid": "ockTokenChip_Button",
      className: cn(
        componentTheme,
        isPressable ? [pressable.secondary, pressable.shadow] : [background.secondary, "cursor-default"],
        "flex w-fit shrink-0 items-center gap-2 rounded-lg py-1 pr-3 pl-1 ",
        className
      ),
      onClick: () => onClick == null ? void 0 : onClick(token),
      children: [
        (0, import_jsx_runtime45.jsx)(TokenImage, { token, size: 24 }),
        (0, import_jsx_runtime45.jsx)("span", { className: text.headline, children: token.symbol })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/token/components/TokenSelectDropdown.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_react28 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/DropdownMenu.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/utils/getHorizontalPosition.js
function getHorizontalPosition({
  align,
  contentRect,
  triggerRect
}) {
  if (!triggerRect || !contentRect) {
    return 0;
  }
  switch (align) {
    case "start":
      return triggerRect.left;
    case "center":
      return triggerRect.left + (triggerRect.width - contentRect.width) / 2;
    case "end":
      return triggerRect.right - contentRect.width;
  }
}

// node_modules/@coinbase/onchainkit/dist/internal/components/DropdownMenu.js
var import_react27 = __toESM(require_react(), 1);
var import_react_dom4 = __toESM(require_react_dom(), 1);
function DropdownMenu({
  align = "start",
  children,
  isOpen,
  offset = 8,
  onClose,
  trigger,
  "aria-label": ariaLabel
}) {
  const componentTheme = useTheme();
  const contentRef = (0, import_react27.useRef)(null);
  const updatePosition = (0, import_react27.useCallback)(() => {
    if (!(trigger == null ? void 0 : trigger.current) || !contentRef.current) {
      return;
    }
    const triggerRect = trigger.current.getBoundingClientRect();
    const menuRect = contentRef.current.getBoundingClientRect();
    if (!triggerRect || !menuRect) {
      return;
    }
    const left = getHorizontalPosition({
      triggerRect,
      contentRect: menuRect,
      align
    });
    contentRef.current.style.top = `${triggerRect.bottom + offset}px`;
    contentRef.current.style.left = `${left}px`;
  }, [trigger, offset, align]);
  (0, import_react27.useEffect)(() => {
    if (!isOpen) {
      return;
    }
    updatePosition();
    window.addEventListener("resize", updatePosition);
    window.addEventListener("scroll", updatePosition);
    return () => {
      window.removeEventListener("resize", updatePosition);
      window.removeEventListener("scroll", updatePosition);
    };
  }, [isOpen, updatePosition]);
  if (!isOpen) {
    return null;
  }
  const dropdownMenu = (0, import_jsx_runtime46.jsx)(
    "div",
    {
      className: cn(
        componentTheme,
        zIndex.dropdown,
        "pointer-events-none fixed"
      ),
      "data-portal-origin": "true",
      children: (0, import_jsx_runtime46.jsx)(FocusTrap, { active: isOpen, children: (0, import_jsx_runtime46.jsx)(DismissableLayer, { onDismiss: onClose, triggerRef: trigger, children: (0, import_jsx_runtime46.jsx)(
        "div",
        {
          ref: contentRef,
          className: cn("pointer-events-auto fixed"),
          role: "listbox",
          "data-testid": "ockDropdownMenu",
          "aria-label": ariaLabel,
          children
        }
      ) }) })
    }
  );
  return (0, import_react_dom4.createPortal)(dropdownMenu, document.body);
}

// node_modules/@coinbase/onchainkit/dist/token/components/TokenSelectDropdown.js
function TokenSelectDropdown({
  options,
  setToken,
  token
}) {
  const [isOpen, setIsOpen] = (0, import_react28.useState)(false);
  const buttonRef = (0, import_react28.useRef)(null);
  const closeDropdown = (0, import_react28.useCallback)(() => {
    setIsOpen(false);
  }, []);
  const toggleDropdown = (0, import_react28.useCallback)(() => {
    setIsOpen((prev) => !prev);
  }, []);
  return (0, import_jsx_runtime47.jsxs)("div", { className: "relative max-w-fit shrink-0", children: [
    (0, import_jsx_runtime47.jsx)(
      TokenSelectButton,
      {
        ref: buttonRef,
        onClick: toggleDropdown,
        isOpen,
        token
      }
    ),
    (0, import_jsx_runtime47.jsx)(
      DropdownMenu,
      {
        trigger: buttonRef,
        isOpen,
        onClose: closeDropdown,
        align: "end",
        children: (0, import_jsx_runtime47.jsx)(
          "div",
          {
            "data-testid": "ockTokenSelectDropdown_List",
            className: cn(
              border.radius,
              color.foreground,
              "flex max-h-80 w-[200px] flex-col overflow-y-hidden",
              "ock-scrollbar"
            ),
            children: (0, import_jsx_runtime47.jsx)("div", { className: "overflow-y-auto", children: options.map((token2) => (0, import_jsx_runtime47.jsx)(
              TokenRow,
              {
                className: cn(background.inverse, "px-4 py-2"),
                token: token2,
                onClick: () => {
                  setToken(token2);
                  setIsOpen(false);
                }
              },
              token2.name + token2.address
            )) })
          }
        )
      }
    )
  ] });
}

// node_modules/@coinbase/onchainkit/dist/swap/utils/formatAmount.js
function formatAmount2(num) {
  if (!/\d+\.?\d*e[+-]*\d+/i.test(num)) {
    return num;
  }
  const [coefficient, exponent] = num.toLowerCase().split("e");
  const exp = Number.parseInt(exponent);
  const [intPart, decPart = ""] = coefficient.split(".");
  const fullNumber = intPart + decPart;
  const newPosition = intPart.length + exp;
  if (newPosition <= 0) {
    return `0.${"0".repeat(Math.abs(newPosition))}${fullNumber}`;
  }
  if (newPosition >= fullNumber.length) {
    return fullNumber + "0".repeat(newPosition - fullNumber.length);
  }
  return `${fullNumber.slice(0, newPosition)}.${fullNumber.slice(newPosition)}`;
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapProvider.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react34 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/core/network/definitions/swap.js
var CDP_GET_SWAP_QUOTE = "cdp_getSwapQuote";
var CDP_GET_SWAP_TRADE = "cdp_getSwapTrade";

// node_modules/@coinbase/onchainkit/dist/swap/utils/fromReadableAmount.js
function fromReadableAmount(amount, decimals) {
  const [wholePart, fractionalPart = ""] = amount.split(".");
  const paddedFractionalPart = fractionalPart.padEnd(decimals, "0");
  const trimmedFractionalPart = paddedFractionalPart.slice(0, decimals);
  return (BigInt(wholePart + trimmedFractionalPart) * BigInt(10) ** BigInt(decimals - trimmedFractionalPart.length)).toString();
}

// node_modules/@coinbase/onchainkit/dist/swap/utils/toReadableAmount.js
function toReadableAmount(amount, decimals) {
  if (amount.includes(".")) {
    const [wholePart2, fractionalPart2] = amount.split(".");
    const paddedFractionalPart = fractionalPart2.padEnd(decimals, "0");
    const combinedAmount = wholePart2 + paddedFractionalPart;
    return combinedAmount;
  }
  const bigIntAmount = BigInt(amount);
  const divisor = BigInt(10) ** BigInt(decimals);
  const wholePart = (bigIntAmount / divisor).toString();
  const fractionalPart = (bigIntAmount % divisor).toString().padStart(decimals, "0");
  const trimmedFractionalPart = fractionalPart.replace(/0+$/, "");
  return trimmedFractionalPart ? `${wholePart}.${trimmedFractionalPart}` : wholePart;
}

// node_modules/@coinbase/onchainkit/dist/swap/utils/formatDecimals.js
function formatDecimals(amount, inputInDecimals = true, decimals = 18) {
  let result;
  if (inputInDecimals) {
    result = toReadableAmount(amount, decimals);
  } else {
    result = fromReadableAmount(amount, decimals);
  }
  return result;
}

// node_modules/@coinbase/onchainkit/dist/api/utils/getAPIParamsForToken.js
function getAPIParamsForToken(params) {
  const { from, to, amount, amountReference, isAmountInDecimals } = params;
  const { fromAddress } = params;
  const decimals = amountReference === "from" ? from.decimals : to.decimals;
  if (typeof amount !== "string" || amount.trim() === "") {
    return {
      code: "INVALID_INPUT",
      error: "Invalid input: amount must be a non-empty string",
      message: ""
    };
  }
  if (!Number.isInteger(decimals) || decimals < 0) {
    return {
      code: "INVALID_INPUT",
      error: "Invalid input: decimals must be a non-negative integer",
      message: ""
    };
  }
  if (!/^(?:0|[1-9]\d*|\.\d+)(?:\.\d*)?$/.test(amount)) {
    return {
      code: "INVALID_INPUT",
      error: "Invalid input: amount must be a non-negative number string",
      message: ""
    };
  }
  return {
    fromAddress,
    from: from.address || "ETH",
    to: to.address || "ETH",
    amount: isAmountInDecimals ? amount : formatDecimals(amount, false, decimals),
    amountReference: amountReference || "from"
  };
}

// node_modules/@coinbase/onchainkit/dist/api/utils/getSwapTransaction.js
function getSwapTransaction(rawTx, chainId) {
  const { data, gas, to, value } = rawTx;
  return {
    chainId: Number(chainId),
    data,
    gas: BigInt(gas),
    to,
    value: BigInt(value)
  };
}

// node_modules/@coinbase/onchainkit/dist/api/buildSwapTransaction.js
async function buildSwapTransaction(params, _context = RequestContext.API) {
  var _a;
  const defaultParams = {
    amountReference: "from",
    isAmountInDecimals: false
  };
  let apiParams = getAPIParamsForToken({
    ...defaultParams,
    ...params
  });
  if ("error" in apiParams) {
    return apiParams;
  }
  if (params.useAggregator && params.amountReference === "to") {
    console.error(SwapMessage.UNSUPPORTED_AMOUNT_REFERENCE);
    return {
      code: UNSUPPORTED_AMOUNT_REFERENCE_ERROR_CODE,
      error: SwapMessage.UNSUPPORTED_AMOUNT_REFERENCE,
      message: ""
    };
  }
  if (!params.useAggregator) {
    apiParams = {
      v2Enabled: true,
      ...apiParams
    };
  }
  if (params.maxSlippage) {
    let slippagePercentage = params.maxSlippage;
    if (params.useAggregator) {
      slippagePercentage = (Number(params.maxSlippage) * 10).toString();
    }
    apiParams = {
      slippagePercentage,
      ...apiParams
    };
  }
  try {
    const res = await sendRequest(
      CDP_GET_SWAP_TRADE,
      [apiParams],
      _context
    );
    if (res.error) {
      return {
        code: getSwapErrorCode("swap", (_a = res.error) == null ? void 0 : _a.code),
        error: res.error.message,
        message: ""
      };
    }
    const trade = res.result;
    return {
      approveTransaction: trade.approveTx ? getSwapTransaction(trade.approveTx, trade.chainId) : void 0,
      fee: trade.fee,
      quote: trade.quote,
      transaction: getSwapTransaction(trade.tx, trade.chainId),
      warning: trade.quote.warning
    };
  } catch {
    return {
      code: getSwapErrorCode("uncaught-swap"),
      error: "Something went wrong",
      message: ""
    };
  }
}

// node_modules/@coinbase/onchainkit/dist/api/getSwapQuote.js
async function getSwapQuote(params, _context = RequestContext.API) {
  var _a;
  const defaultParams = {
    amountReference: "from",
    isAmountInDecimals: false
  };
  let apiParams = getAPIParamsForToken({
    ...defaultParams,
    ...params
  });
  if ("error" in apiParams) {
    return apiParams;
  }
  if (params.useAggregator && params.amountReference === "to") {
    console.error(SwapMessage.UNSUPPORTED_AMOUNT_REFERENCE);
    return {
      code: UNSUPPORTED_AMOUNT_REFERENCE_ERROR_CODE,
      error: SwapMessage.UNSUPPORTED_AMOUNT_REFERENCE,
      message: ""
    };
  }
  if (!params.useAggregator) {
    apiParams = {
      v2Enabled: true,
      ...apiParams
    };
  }
  if (params.maxSlippage) {
    let slippagePercentage = params.maxSlippage;
    if (params.useAggregator) {
      slippagePercentage = (Number(params.maxSlippage) * 10).toString();
    }
    apiParams = {
      slippagePercentage,
      ...apiParams
    };
  }
  try {
    const res = await sendRequest(
      CDP_GET_SWAP_QUOTE,
      [apiParams],
      _context
    );
    if (res.error) {
      return {
        code: getSwapErrorCode("quote", (_a = res.error) == null ? void 0 : _a.code),
        error: res.error.message,
        message: ""
      };
    }
    return res.result;
  } catch {
    return {
      code: getSwapErrorCode("uncaught-quote"),
      error: "Something went wrong",
      message: ""
    };
  }
}

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useLifecycleStatus.js
var import_react29 = __toESM(require_react(), 1);
function useLifecycleStatus(initialState) {
  const [lifecycleStatus, setLifecycleStatus] = (0, import_react29.useState)(initialState);
  const updateLifecycleStatus = (0, import_react29.useCallback)(
    (newStatus) => {
      setLifecycleStatus((prevStatus) => {
        const persistedStatusData = prevStatus.statusName === "error" ? (
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          (({ error, code, message, ...statusData }) => statusData)(
            prevStatus.statusData
          )
        ) : prevStatus.statusData;
        return {
          statusName: newStatus.statusName,
          statusData: {
            ...persistedStatusData,
            ...newStatus.statusData
          }
        };
      });
    },
    []
  );
  return [lifecycleStatus, updateLifecycleStatus];
}

// node_modules/@coinbase/onchainkit/dist/internal/utils/formatTokenAmount.js
function formatTokenAmount(amount, decimals) {
  const numberAmount = Number(amount) / 10 ** decimals;
  return numberAmount.toString();
}

// node_modules/@coinbase/onchainkit/dist/swap/hooks/useAwaitCalls.js
var import_react30 = __toESM(require_react(), 1);
function useAwaitCalls({
  accountConfig,
  lifecycleStatus,
  updateLifecycleStatus
}) {
  var _a;
  const callsId = lifecycleStatus.statusName === "transactionApproved" ? (_a = lifecycleStatus.statusData) == null ? void 0 : _a.callsId : void 0;
  const { data } = useCallsStatus({
    id: callsId || "",
    query: {
      refetchInterval: (query) => {
        var _a2;
        return normalizeStatus((_a2 = query.state.data) == null ? void 0 : _a2.status) === "success" ? false : 1e3;
      },
      enabled: callsId !== void 0
    }
  });
  return (0, import_react30.useCallback)(async () => {
    if (normalizeStatus(data == null ? void 0 : data.status) === "success" && (data == null ? void 0 : data.receipts)) {
      const transactionReceipt = await waitForTransactionReceipt(
        accountConfig,
        {
          confirmations: 1,
          hash: data.receipts[data.receipts.length - 1].transactionHash
        }
      );
      updateLifecycleStatus({
        statusName: "success",
        statusData: {
          transactionReceipt
        }
      });
    }
  }, [accountConfig, data, updateLifecycleStatus]);
}

// node_modules/@coinbase/onchainkit/dist/swap/hooks/useFromTo.js
var import_react32 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/hooks/useGetTokenBalance.js
var import_react31 = __toESM(require_react(), 1);
function useGetTokenBalance(address, token) {
  const tokenBalanceResponse = useReadContract({
    abi: erc20Abi,
    address: token == null ? void 0 : token.address,
    functionName: "balanceOf",
    args: address ? [address] : [],
    query: {
      enabled: !!(token == null ? void 0 : token.address) && !!address
    }
  });
  return (0, import_react31.useMemo)(() => {
    var _a;
    let error;
    if (tokenBalanceResponse == null ? void 0 : tokenBalanceResponse.error) {
      error = {
        code: getSwapErrorCode("balance"),
        error: (_a = tokenBalanceResponse == null ? void 0 : tokenBalanceResponse.error) == null ? void 0 : _a.shortMessage,
        message: ""
      };
    }
    if ((tokenBalanceResponse == null ? void 0 : tokenBalanceResponse.data) !== 0n && !(tokenBalanceResponse == null ? void 0 : tokenBalanceResponse.data) || !token) {
      return {
        convertedBalance: "",
        status: tokenBalanceResponse.status,
        error,
        roundedBalance: "",
        response: tokenBalanceResponse,
        refetch: tokenBalanceResponse.refetch
      };
    }
    const convertedBalance = formatUnits(
      tokenBalanceResponse == null ? void 0 : tokenBalanceResponse.data,
      token == null ? void 0 : token.decimals
    );
    return {
      convertedBalance,
      status: tokenBalanceResponse.status,
      error,
      response: tokenBalanceResponse,
      roundedBalance: getRoundedAmount(convertedBalance, 8),
      refetch: tokenBalanceResponse.refetch
    };
  }, [token, tokenBalanceResponse]);
}

// node_modules/@coinbase/onchainkit/dist/swap/hooks/useSwapBalances.js
function useSwapBalances({
  address,
  fromToken,
  toToken
}) {
  const {
    convertedBalance: convertedEthBalance,
    error: ethBalanceError,
    response: ethBalanceResponse
  } = useGetETHBalance(address);
  const {
    convertedBalance: convertedFromBalance,
    error: fromBalanceError,
    response: _fromTokenResponse
  } = useGetTokenBalance(address, fromToken);
  const {
    convertedBalance: convertedToBalance,
    error: toBalanceError,
    response: _toTokenResponse
  } = useGetTokenBalance(address, toToken);
  const isFromNativeToken = (fromToken == null ? void 0 : fromToken.symbol) === "ETH";
  const isToNativeToken = (toToken == null ? void 0 : toToken.symbol) === "ETH";
  const fromBalanceString = isFromNativeToken ? convertedEthBalance : convertedFromBalance;
  const fromTokenBalanceError = isFromNativeToken ? ethBalanceError : fromBalanceError;
  const toBalanceString = isToNativeToken ? convertedEthBalance : convertedToBalance;
  const toTokenBalanceError = isToNativeToken ? ethBalanceError : toBalanceError;
  const fromTokenResponse = isFromNativeToken ? ethBalanceResponse : _fromTokenResponse;
  const toTokenResponse = isToNativeToken ? ethBalanceResponse : _toTokenResponse;
  return useValue({
    fromBalanceString,
    fromTokenBalanceError,
    fromTokenResponse,
    toBalanceString,
    toTokenBalanceError,
    toTokenResponse
  });
}

// node_modules/@coinbase/onchainkit/dist/swap/hooks/useFromTo.js
var useFromTo = (address) => {
  const [fromAmount, setFromAmount] = (0, import_react32.useState)("");
  const [fromAmountUSD, setFromAmountUSD] = (0, import_react32.useState)("");
  const [fromToken, setFromToken] = (0, import_react32.useState)();
  const [toAmount, setToAmount] = (0, import_react32.useState)("");
  const [toAmountUSD, setToAmountUSD] = (0, import_react32.useState)("");
  const [toToken, setToToken] = (0, import_react32.useState)();
  const [toLoading, setToLoading] = (0, import_react32.useState)(false);
  const [fromLoading, setFromLoading] = (0, import_react32.useState)(false);
  const {
    fromBalanceString,
    fromTokenBalanceError,
    toBalanceString,
    toTokenBalanceError,
    fromTokenResponse,
    toTokenResponse
  } = useSwapBalances({ address, fromToken, toToken });
  const from = useValue({
    balance: fromBalanceString,
    balanceResponse: fromTokenResponse,
    amount: fromAmount,
    setAmount: setFromAmount,
    amountUSD: fromAmountUSD,
    setAmountUSD: setFromAmountUSD,
    token: fromToken,
    setToken: setFromToken,
    loading: fromLoading,
    setLoading: setFromLoading,
    error: fromTokenBalanceError
  });
  const to = useValue({
    balance: toBalanceString,
    balanceResponse: toTokenResponse,
    amount: toAmount,
    amountUSD: toAmountUSD,
    setAmountUSD: setToAmountUSD,
    setAmount: setToAmount,
    token: toToken,
    setToken: setToToken,
    loading: toLoading,
    setLoading: setToLoading,
    error: toTokenBalanceError
  });
  return { from, to };
};

// node_modules/@coinbase/onchainkit/dist/swap/hooks/useResetInputs.js
var import_react33 = __toESM(require_react(), 1);
var useResetInputs = ({ from, to }) => {
  return (0, import_react33.useCallback)(async () => {
    var _a, _b;
    await Promise.all([
      (_a = from.balanceResponse) == null ? void 0 : _a.refetch(),
      (_b = to.balanceResponse) == null ? void 0 : _b.refetch(),
      from.setAmount(""),
      from.setAmountUSD(""),
      to.setAmount(""),
      to.setAmountUSD("")
    ]);
  }, [from, to]);
};

// node_modules/@coinbase/onchainkit/dist/swap/utils/isSwapError.js
function isSwapError(response) {
  return response !== null && typeof response === "object" && "error" in response;
}

// node_modules/@coinbase/onchainkit/dist/swap/utils/sendSingleTransactions.js
async function sendSingleTransactions({
  config,
  sendTransactionAsync,
  transactions,
  updateLifecycleStatus
}) {
  let transactionReceipt;
  for (const { transaction, transactionType } of transactions) {
    updateLifecycleStatus({
      statusName: "transactionPending"
    });
    const txHash = await sendTransactionAsync(transaction);
    updateLifecycleStatus({
      statusName: "transactionApproved",
      statusData: { transactionHash: txHash, transactionType }
    });
    transactionReceipt = await waitForTransactionReceipt(config, {
      hash: txHash,
      confirmations: 1
    });
  }
  if (transactionReceipt) {
    updateLifecycleStatus({
      statusName: "success",
      statusData: {
        transactionReceipt
      }
    });
  }
}

// node_modules/@coinbase/onchainkit/dist/swap/utils/sendSwapTransactions.js
async function sendSwapTransactions({
  config,
  isSponsored,
  paymaster,
  sendCallsAsync,
  sendTransactionAsync,
  updateLifecycleStatus,
  walletCapabilities,
  transactions
}) {
  var _a;
  if ((_a = walletCapabilities[Capabilities.AtomicBatch]) == null ? void 0 : _a.supported) {
    updateLifecycleStatus({
      statusName: "transactionPending"
    });
    const data = await sendCallsAsync({
      calls: transactions.map(({ transaction }) => transaction),
      capabilities: isSponsored ? {
        paymasterService: {
          url: paymaster
        }
      } : {}
    });
    updateLifecycleStatus({
      statusName: "transactionApproved",
      statusData: {
        callsId: normalizeTransactionId(data),
        transactionType: "Batched"
      }
    });
  } else {
    await sendSingleTransactions({
      config,
      sendTransactionAsync,
      transactions,
      updateLifecycleStatus
    });
  }
}

// node_modules/@coinbase/onchainkit/dist/swap/utils/processSwapTransaction.js
async function processSwapTransaction({
  chainId,
  config,
  isSponsored,
  paymaster,
  sendCallsAsync,
  sendTransactionAsync,
  swapTransaction,
  switchChainAsync,
  updateLifecycleStatus,
  useAggregator,
  walletCapabilities
}) {
  const { transaction, approveTransaction, quote } = swapTransaction;
  const transactions = [];
  if (approveTransaction == null ? void 0 : approveTransaction.data) {
    transactions.push({
      transaction: {
        to: approveTransaction.to,
        value: approveTransaction.value,
        data: approveTransaction.data
      },
      transactionType: "ERC20"
    });
    if (!useAggregator) {
      const permit2ContractAbi = parseAbi([
        "function approve(address token, address spender, uint160 amount, uint48 expiration) external"
      ]);
      const data = encodeFunctionData({
        abi: permit2ContractAbi,
        functionName: "approve",
        args: [
          quote.from.address,
          UNIVERSALROUTER_CONTRACT_ADDRESS,
          BigInt(quote.fromAmount),
          2e13
          // The deadline where the approval is no longer valid - see https://docs.uniswap.org/contracts/permit2/reference/allowance-transfer
        ]
      });
      transactions.push({
        transaction: {
          to: PERMIT2_CONTRACT_ADDRESS,
          value: 0n,
          data
        },
        transactionType: "Permit2"
      });
    }
  }
  transactions.push({
    transaction: {
      to: transaction.to,
      value: transaction.value,
      data: transaction.data
    },
    transactionType: "Swap"
  });
  if (chainId !== base.id) {
    await switchChainAsync({ chainId: base.id });
  }
  await sendSwapTransactions({
    config,
    isSponsored,
    paymaster,
    sendCallsAsync,
    sendTransactionAsync,
    transactions,
    updateLifecycleStatus,
    walletCapabilities
  });
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapProvider.js
var emptyContext2 = {};
var SwapContext = (0, import_react34.createContext)(emptyContext2);
function useSwapContext() {
  const context = (0, import_react34.useContext)(SwapContext);
  if (context === emptyContext2) {
    throw new Error("useSwapContext must be used within a Swap component");
  }
  return context;
}
function SwapProvider({
  children,
  config = {
    maxSlippage: FALLBACK_DEFAULT_MAX_SLIPPAGE
  },
  experimental,
  isSponsored,
  onError,
  onStatus,
  onSuccess
}) {
  var _a, _b;
  const { config: { paymaster } = { paymaster: void 0 } } = useOnchainKit();
  const { address, chainId } = useAccount();
  const { switchChainAsync } = useSwitchChain();
  const { useAggregator } = experimental;
  const accountConfig = useConfig();
  const walletCapabilities = useCapabilitiesSafe({
    chainId: base.id
  });
  const [lifecycleStatus, updateLifecycleStatus] = useLifecycleStatus({
    statusName: "init",
    statusData: {
      isMissingRequiredField: true,
      maxSlippage: config.maxSlippage
    }
  });
  const [isToastVisible, setIsToastVisible] = (0, import_react34.useState)(false);
  const [transactionHash, setTransactionHash] = (0, import_react34.useState)("");
  const [hasHandledSuccess, setHasHandledSuccess] = (0, import_react34.useState)(false);
  const { from, to } = useFromTo(address);
  const { sendTransactionAsync } = useSendTransaction();
  const { sendCallsAsync } = useSendCalls();
  const resetInputs = useResetInputs({ from, to });
  const awaitCallsStatus = useAwaitCalls({
    accountConfig,
    lifecycleStatus,
    updateLifecycleStatus
  });
  const { sendAnalytics } = useAnalytics();
  (0, import_react34.useEffect)(() => {
    var _a2, _b2, _c, _d;
    if (lifecycleStatus.statusName === "error") {
      onError == null ? void 0 : onError(lifecycleStatus.statusData);
      sendAnalytics(SwapEvent.SwapFailure, {
        error: lifecycleStatus.statusData.error,
        metadata: lifecycleStatus.statusData
      });
    }
    if (lifecycleStatus.statusName === "success") {
      onSuccess == null ? void 0 : onSuccess(lifecycleStatus.statusData.transactionReceipt);
      setTransactionHash(
        (_a2 = lifecycleStatus.statusData) == null ? void 0 : _a2.transactionReceipt.transactionHash
      );
      setHasHandledSuccess(true);
      setIsToastVisible(true);
      sendAnalytics(SwapEvent.SwapSuccess, {
        paymaster: !!paymaster,
        transactionHash: (_b2 = lifecycleStatus.statusData.transactionReceipt) == null ? void 0 : _b2.transactionHash,
        address: address || "",
        amount: Number(from.amount),
        from: ((_c = from.token) == null ? void 0 : _c.symbol) || "",
        to: ((_d = to.token) == null ? void 0 : _d.symbol) || ""
      });
    }
    onStatus == null ? void 0 : onStatus(lifecycleStatus);
  }, [
    onError,
    onStatus,
    onSuccess,
    lifecycleStatus,
    lifecycleStatus.statusData,
    // Keep statusData, so that the effect runs when it changes
    lifecycleStatus.statusName,
    // Keep statusName, so that the effect runs when it changes
    sendAnalytics,
    paymaster,
    from.amount,
    (_a = from.token) == null ? void 0 : _a.symbol,
    (_b = to.token) == null ? void 0 : _b.symbol,
    address
  ]);
  (0, import_react34.useEffect)(() => {
    if (lifecycleStatus.statusName === "init" && hasHandledSuccess) {
      setHasHandledSuccess(false);
      resetInputs();
    }
  }, [hasHandledSuccess, lifecycleStatus.statusName, resetInputs]);
  (0, import_react34.useEffect)(() => {
    if (lifecycleStatus.statusName === "transactionApproved" && lifecycleStatus.statusData.transactionType === "Batched") {
      awaitCallsStatus();
    }
  }, [
    awaitCallsStatus,
    lifecycleStatus,
    lifecycleStatus.statusData,
    lifecycleStatus.statusName
  ]);
  (0, import_react34.useEffect)(() => {
    if (lifecycleStatus.statusName === "success" && hasHandledSuccess) {
      updateLifecycleStatus({
        statusName: "init",
        statusData: {
          isMissingRequiredField: true,
          maxSlippage: config.maxSlippage
        }
      });
    }
  }, [
    config.maxSlippage,
    hasHandledSuccess,
    lifecycleStatus.statusName,
    updateLifecycleStatus
  ]);
  const handleToggle = (0, import_react34.useCallback)(() => {
    var _a2, _b2;
    from.setAmount(to.amount);
    to.setAmount(from.amount);
    (_a2 = from.setToken) == null ? void 0 : _a2.call(from, to.token);
    (_b2 = to.setToken) == null ? void 0 : _b2.call(to, from.token);
    updateLifecycleStatus({
      statusName: "amountChange",
      statusData: {
        amountFrom: from.amount,
        amountTo: to.amount,
        tokenFrom: from.token,
        tokenTo: to.token,
        // token is missing
        isMissingRequiredField: !from.token || !to.token || !from.amount || !to.amount
      }
    });
  }, [from, to, updateLifecycleStatus]);
  const handleAmountChange = (0, import_react34.useCallback)(
    async (type, amount, sToken, dToken) => {
      const source = type === "from" ? from : to;
      const destination = type === "from" ? to : from;
      source.token = sToken ?? source.token;
      destination.token = dToken ?? destination.token;
      if (source.token === void 0 || destination.token === void 0) {
        updateLifecycleStatus({
          statusName: "amountChange",
          statusData: {
            amountFrom: from.amount,
            amountTo: to.amount,
            tokenFrom: from.token,
            tokenTo: to.token,
            // token is missing
            isMissingRequiredField: true
          }
        });
        return;
      }
      if (amount === "" || amount === "." || Number.parseFloat(amount) === 0) {
        destination.setAmount("");
        destination.setAmountUSD("");
        source.setAmountUSD("");
        return;
      }
      destination.setLoading(true);
      updateLifecycleStatus({
        statusName: "amountChange",
        statusData: {
          // when fetching quote, the previous
          // amount is irrelevant
          amountFrom: type === "from" ? amount : "",
          amountTo: type === "to" ? amount : "",
          tokenFrom: from.token,
          tokenTo: to.token,
          // when fetching quote, the destination
          // amount is missing
          isMissingRequiredField: true
        }
      });
      try {
        const maxSlippage = lifecycleStatus.statusData.maxSlippage;
        const response = await getSwapQuote(
          {
            amount,
            amountReference: "from",
            from: source.token,
            maxSlippage: String(maxSlippage),
            to: destination.token,
            useAggregator
          },
          RequestContext.Swap
        );
        if (isSwapError(response)) {
          updateLifecycleStatus({
            statusName: "error",
            statusData: {
              code: response.code,
              error: response.error,
              message: ""
            }
          });
          return;
        }
        const formattedAmount = formatTokenAmount(
          response.toAmount,
          response.to.decimals
        );
        destination.setAmountUSD(response.toAmountUSD);
        destination.setAmount(formattedAmount);
        source.setAmountUSD(response.fromAmountUSD);
        updateLifecycleStatus({
          statusName: "amountChange",
          statusData: {
            amountFrom: type === "from" ? amount : formattedAmount,
            amountTo: type === "to" ? amount : formattedAmount,
            tokenFrom: from.token,
            tokenTo: to.token,
            // if quote was fetched successfully, we
            // have all required fields
            isMissingRequiredField: !formattedAmount
          }
        });
      } catch (err) {
        updateLifecycleStatus({
          statusName: "error",
          statusData: {
            code: "TmSPc01",
            // Transaction module SwapProvider component 01 error
            error: JSON.stringify(err),
            message: ""
          }
        });
      } finally {
        destination.setLoading(false);
      }
    },
    [from, to, lifecycleStatus, updateLifecycleStatus, useAggregator]
  );
  const handleSubmit = (0, import_react34.useCallback)(async () => {
    if (!address || !from.token || !to.token || !from.amount) {
      return;
    }
    try {
      sendAnalytics(SwapEvent.SwapInitiated, {
        amount: Number(from.amount)
      });
      const maxSlippage = lifecycleStatus.statusData.maxSlippage;
      const response = await buildSwapTransaction(
        {
          amount: from.amount,
          fromAddress: address,
          from: from.token,
          maxSlippage: String(maxSlippage),
          to: to.token,
          useAggregator
        },
        RequestContext.Swap
      );
      if (isSwapError(response)) {
        updateLifecycleStatus({
          statusName: "error",
          statusData: {
            code: response.code,
            error: response.error,
            message: response.message
          }
        });
        return;
      }
      await processSwapTransaction({
        chainId,
        config: accountConfig,
        isSponsored,
        paymaster: paymaster || "",
        sendCallsAsync,
        sendTransactionAsync,
        swapTransaction: response,
        switchChainAsync,
        updateLifecycleStatus,
        useAggregator,
        walletCapabilities
      });
    } catch (err) {
      const errorMessage = isUserRejectedRequestError(err) ? "Request denied." : GENERIC_ERROR_MESSAGE;
      updateLifecycleStatus({
        statusName: "error",
        statusData: {
          code: "TmSPc02",
          // Transaction module SwapProvider component 02 error
          error: JSON.stringify(err),
          message: errorMessage
        }
      });
    }
  }, [
    accountConfig,
    address,
    chainId,
    from.amount,
    from.token,
    isSponsored,
    lifecycleStatus,
    paymaster,
    sendCallsAsync,
    sendTransactionAsync,
    switchChainAsync,
    to.token,
    updateLifecycleStatus,
    useAggregator,
    walletCapabilities,
    sendAnalytics
  ]);
  const value = useValue({
    address,
    config,
    from,
    handleAmountChange,
    handleToggle,
    handleSubmit,
    lifecycleStatus,
    updateLifecycleStatus,
    to,
    isToastVisible,
    setIsToastVisible,
    setTransactionHash,
    transactionHash
  });
  return (0, import_jsx_runtime48.jsx)(SwapContext.Provider, { value, children });
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapAmountInput.js
function SwapAmountInput({
  className,
  delayMs = 1e3,
  label,
  token,
  type,
  swappableTokens
}) {
  const { address, to, from, handleAmountChange } = useSwapContext();
  const { sendAnalytics } = useAnalytics();
  const source = useValue(type === "from" ? from : to);
  const destination = useValue(type === "from" ? to : from);
  const { setToken, setAmount, balance, amount, amountUSD } = source;
  (0, import_react35.useEffect)(() => {
    if (token) {
      setToken == null ? void 0 : setToken(token);
    }
  }, [token, setToken]);
  const handleMaxButtonClick = (0, import_react35.useCallback)(() => {
    if (!balance) {
      return;
    }
    setAmount(balance);
    handleAmountChange(type, balance);
  }, [balance, setAmount, handleAmountChange, type]);
  const handleChange = (0, import_react35.useCallback)(
    (amount2) => {
      handleAmountChange(type, amount2);
    },
    [handleAmountChange, type]
  );
  const handleAnalyticsTokenSelected = (0, import_react35.useCallback)(
    (token2) => {
      sendAnalytics(SwapEvent.TokenSelected, {
        token: token2.symbol
      });
    },
    [sendAnalytics]
  );
  const handleSetToken = (0, import_react35.useCallback)(
    (token2) => {
      setToken == null ? void 0 : setToken(token2);
      handleAmountChange(type, amount, token2);
      handleAnalyticsTokenSelected(token2);
    },
    [amount, setToken, handleAmountChange, handleAnalyticsTokenSelected, type]
  );
  const sourceTokenOptions = (0, import_react35.useMemo)(() => {
    return (swappableTokens == null ? void 0 : swappableTokens.filter(
      ({ symbol }) => {
        var _a;
        return symbol !== ((_a = destination.token) == null ? void 0 : _a.symbol);
      }
    )) ?? [];
  }, [swappableTokens, destination.token]);
  const hasInsufficientBalance = type === "from" && Number(balance) < Number(amount);
  const formatUSD = (amount2) => {
    if (!amount2 || amount2 === "0") {
      return null;
    }
    const roundedAmount = Number(getRoundedAmount(amount2, 2));
    return `~$${roundedAmount.toFixed(2)}`;
  };
  return (0, import_jsx_runtime49.jsxs)(
    "div",
    {
      className: cn(
        background.secondary,
        border.radius,
        "my-0.5 box-border flex h-[148px] w-full flex-col items-start p-4",
        className
      ),
      "data-testid": "ockSwapAmountInput_Container",
      children: [
        (0, import_jsx_runtime49.jsx)(
          "div",
          {
            className: cn(
              text.label2,
              color.foregroundMuted,
              "flex w-full items-center justify-between"
            ),
            children: label
          }
        ),
        (0, import_jsx_runtime49.jsxs)("div", { className: "flex w-full items-center justify-between", children: [
          (0, import_jsx_runtime49.jsx)(
            TextInput,
            {
              className: cn(
                "mr-2 w-full border-[none] bg-transparent font-display text-[2.5rem]",
                "leading-none outline-none",
                hasInsufficientBalance && address ? color.error : color.foreground
              ),
              placeholder: "0.0",
              delayMs,
              value: formatAmount2(amount),
              setValue: setAmount,
              disabled: source.loading,
              onChange: handleChange,
              inputValidator: isValidAmount
            }
          ),
          sourceTokenOptions.length > 0 ? (0, import_jsx_runtime49.jsx)(
            TokenSelectDropdown,
            {
              token: source.token,
              setToken: handleSetToken,
              options: sourceTokenOptions
            }
          ) : source.token && (0, import_jsx_runtime49.jsx)(TokenChip, { className: pressable.inverse, token: source.token })
        ] }),
        (0, import_jsx_runtime49.jsxs)("div", { className: "mt-4 flex w-full items-center justify-between", children: [
          (0, import_jsx_runtime49.jsx)("div", { className: cn(text.label2, color.foregroundMuted), children: formatUSD(amountUSD) }),
          (0, import_jsx_runtime49.jsxs)(
            "div",
            {
              className: cn(
                text.label2,
                color.foregroundMuted,
                "flex grow items-center justify-end"
              ),
              children: [
                balance && (0, import_jsx_runtime49.jsx)("span", { children: `Balance: ${getRoundedAmount(balance, 8)}` }),
                type === "from" && address && (0, import_jsx_runtime49.jsx)(
                  "button",
                  {
                    type: "button",
                    className: cn(
                      text.label1,
                      color.primary,
                      "flex cursor-pointer items-center justify-center px-2 py-1"
                    ),
                    "data-testid": "ockSwapAmountInput_MaxButton",
                    onClick: handleMaxButtonClick,
                    children: "Max"
                  }
                )
              ]
            }
          )
        ] })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapButton.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
function SwapButton({
  className,
  label = "Swap",
  disabled = false
}) {
  var _a, _b;
  const {
    address,
    to,
    from,
    lifecycleStatus: { statusName },
    handleSubmit
  } = useSwapContext();
  const isLoading = to.loading || from.loading || statusName === "transactionPending" || statusName === "transactionApproved";
  const isDisabled = !from.amount || !from.token || !to.amount || !to.token || disabled || isLoading;
  const isSwapInvalid = ((_a = to.token) == null ? void 0 : _a.address) === ((_b = from.token) == null ? void 0 : _b.address);
  if (!isDisabled && !address) {
    return (0, import_jsx_runtime50.jsx)(ConnectWallet, { className: cn("mt-4 w-full", className) });
  }
  return (0, import_jsx_runtime50.jsx)(
    "button",
    {
      type: "button",
      className: cn(
        background.primary,
        border.radius,
        "w-full rounded-xl",
        "mt-4 px-4 py-3",
        isDisabled && pressable.disabled,
        text.headline,
        className
      ),
      onClick: () => handleSubmit(),
      disabled: isDisabled || isSwapInvalid,
      "data-testid": "ockSwapButton_Button",
      children: isLoading ? (0, import_jsx_runtime50.jsx)(Spinner, {}) : (0, import_jsx_runtime50.jsx)("span", { className: cn(text.headline, color.inverse), children: label })
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapMessage.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/swap/utils/getErrorMessage.js
function getErrorMessage(error) {
  if (error.code === TOO_MANY_REQUESTS_ERROR_CODE) {
    return SwapMessage.TOO_MANY_REQUESTS;
  }
  if (error.code === LOW_LIQUIDITY_ERROR_CODE) {
    return SwapMessage.LOW_LIQUIDITY;
  }
  if (error.code === USER_REJECTED_ERROR_CODE) {
    return SwapMessage.USER_REJECTED;
  }
  return error.message;
}

// node_modules/@coinbase/onchainkit/dist/swap/utils/getSwapMessage.js
function getSwapMessage({
  address,
  from,
  lifecycleStatus,
  to
}) {
  if (lifecycleStatus.statusName === "error") {
    return getErrorMessage(lifecycleStatus.statusData);
  }
  if (from.error || to.error) {
    return SwapMessage.BALANCE_ERROR;
  }
  if (address && Number(from.balance) < Number(from.amount)) {
    return SwapMessage.INSUFFICIENT_BALANCE;
  }
  if (lifecycleStatus.statusName === "transactionPending") {
    return SwapMessage.CONFIRM_IN_WALLET;
  }
  if (lifecycleStatus.statusName === "transactionApproved") {
    return SwapMessage.SWAP_IN_PROGRESS;
  }
  if (to.loading || from.loading) {
    return SwapMessage.FETCHING_QUOTE;
  }
  if (lifecycleStatus.statusData.isMissingRequiredField) {
    return SwapMessage.INCOMPLETE_FIELD;
  }
  return "";
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapMessage.js
function SwapMessage2({ className }) {
  const { address, to, from, lifecycleStatus } = useSwapContext();
  const message = getSwapMessage({
    address,
    from,
    lifecycleStatus,
    to
  });
  return (0, import_jsx_runtime51.jsx)(
    "div",
    {
      className: cn(
        "flex h-7 pt-2",
        text.label2,
        color.foregroundMuted,
        className
      ),
      "data-testid": "ockSwapMessage_Message",
      children: message
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapSettings.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/Popover.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);
function getInitialPosition(triggerRect, contentRect, position, offset) {
  let top = 0;
  let left = 0;
  switch (position) {
    case "top":
      top = triggerRect.top - contentRect.height - offset;
      break;
    case "bottom":
      top = triggerRect.bottom + offset;
      break;
    case "left":
      left = triggerRect.left - contentRect.width - offset;
      break;
    case "right":
      left = triggerRect.right + offset;
      break;
  }
  return { top, left };
}
function adjustAlignment(triggerRect, contentRect, initialPosition, align, position) {
  const { top: initialTop, left: initialLeft } = initialPosition;
  let top = initialTop;
  let left = initialLeft;
  const isVerticalPosition = position === "top" || position === "bottom";
  switch (align) {
    case "start":
      if (isVerticalPosition) {
        left = triggerRect.left;
      } else {
        top = triggerRect.top;
      }
      break;
    case "center":
      if (isVerticalPosition) {
        left = triggerRect.left + (triggerRect.width - contentRect.width) / 2;
      } else {
        top = triggerRect.top + (triggerRect.height - contentRect.height) / 2;
      }
      break;
    case "end":
      if (isVerticalPosition) {
        left = triggerRect.right - contentRect.width;
      } else {
        top = triggerRect.bottom - contentRect.height;
      }
      break;
  }
  return { top, left };
}
function Popover({
  children,
  anchor,
  isOpen,
  onClose,
  position = "bottom",
  align = "center",
  offset = 8,
  trigger,
  "aria-label": ariaLabel,
  "aria-labelledby": ariaLabelledby,
  "aria-describedby": ariaDescribedby
}) {
  const contentRef = (0, import_react36.useRef)(null);
  const componentTheme = useTheme();
  const updatePosition = (0, import_react36.useCallback)(() => {
    var _a;
    if (!anchor || !contentRef.current) {
      return;
    }
    const triggerRect = anchor.getBoundingClientRect();
    const contentRect = (_a = contentRef.current) == null ? void 0 : _a.getBoundingClientRect();
    if (!triggerRect || !contentRect) {
      return;
    }
    const initialPosition = getInitialPosition(
      triggerRect,
      contentRect,
      position,
      offset
    );
    const finalPosition = adjustAlignment(
      triggerRect,
      contentRect,
      initialPosition,
      align,
      position
    );
    contentRef.current.style.top = `${finalPosition.top}px`;
    contentRef.current.style.left = `${finalPosition.left}px`;
  }, [anchor, position, offset, align]);
  (0, import_react36.useEffect)(() => {
    if (!isOpen) {
      return;
    }
    updatePosition();
    window.addEventListener("resize", updatePosition);
    window.addEventListener("scroll", updatePosition);
    return () => {
      window.removeEventListener("resize", updatePosition);
      window.removeEventListener("scroll", updatePosition);
    };
  }, [isOpen, updatePosition]);
  if (!isOpen) {
    return null;
  }
  const popover = (0, import_jsx_runtime52.jsx)(
    "div",
    {
      className: cn(
        componentTheme,
        zIndex.dropdown,
        "pointer-events-none fixed"
      ),
      "data-portal-origin": "true",
      children: (0, import_jsx_runtime52.jsx)(FocusTrap, { active: isOpen, children: (0, import_jsx_runtime52.jsx)(DismissableLayer, { onDismiss: onClose, triggerRef: trigger, children: (0, import_jsx_runtime52.jsx)(
        "div",
        {
          "aria-label": ariaLabel,
          "aria-labelledby": ariaLabelledby,
          "aria-describedby": ariaDescribedby,
          className: cn("pointer-events-auto fixed"),
          "data-testid": "ockPopover",
          ref: contentRef,
          role: "dialog",
          children
        }
      ) }) })
    }
  );
  return (0, import_react_dom5.createPortal)(popover, document.body);
}

// node_modules/@coinbase/onchainkit/dist/internal/svg/applePaySvg.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var applePaySvg = (0, import_jsx_runtime53.jsxs)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 -29.75 165.5 165.5",
    preserveAspectRatio: "xMidYMid meet",
    id: "Artwork",
    "data-testid": "ock-applePaySvg",
    width: "24",
    height: "24",
    children: [
      (0, import_jsx_runtime53.jsx)("title", { children: "Apple Pay" }),
      (0, import_jsx_runtime53.jsx)(
        "path",
        {
          id: "XMLID_4_",
          d: "M150.7 0h-139c-1 0-2.1.1-3.1.3-1 .2-2 .5-3 1-.9.4-1.8 1.1-2.5 1.8S1.7 4.7 1.3 5.6c-.5.9-.8 1.9-1 3-.2 1-.2 2.1-.3 3.1v82.5c0 1 .1 2.1.3 3.1.2 1 .5 2 1 3 .5.9 1.1 1.8 1.8 2.5s1.6 1.4 2.5 1.8c.9.5 1.9.8 3 1 1 .2 2.1.2 3.1.3h142.1c1 0 2.1-.1 3.1-.3 1-.2 2-.5 3-1 .9-.5 1.8-1.1 2.5-1.8s1.4-1.6 1.8-2.5c.5-.9.8-1.9 1-3 .2-1 .2-2.1.3-3.1v-1.4-78-1.7-1.4c0-1-.1-2.1-.3-3.1-.2-1-.5-2-1-3-.5-.9-1.1-1.8-1.8-2.5s-1.6-1.4-2.5-1.8c-.9-.5-1.9-.8-3-1-1-.2-2.1-.2-3.1-.3H150.7z"
        }
      ),
      (0, import_jsx_runtime53.jsx)(
        "path",
        {
          id: "XMLID_3_",
          fill: "#fff",
          d: "M150.7 3.5H153.8c.8 0 1.7.1 2.6.2.8.1 1.4.3 2 .6.6.3 1.1.7 1.6 1.2s.9 1 1.2 1.6c.3.6.5 1.2.6 2 .2.9.2 1.8.2 2.6v82.5c0 .8-.1 1.7-.2 2.6-.1.7-.3 1.4-.6 2-.3.6-.7 1.1-1.2 1.6s-1 .9-1.6 1.2c-.6.3-1.2.5-2 .6-.9.2-1.8.2-2.6.2H11.7c-.7 0-1.7-.1-2.6-.2-.7-.1-1.4-.3-2-.7-.6-.3-1.1-.7-1.6-1.2s-.9-1-1.2-1.6c-.3-.6-.5-1.2-.6-2-.2-.9-.2-1.8-.2-2.6v-81-1.4c0-.8.1-1.7.2-2.6.1-.7.3-1.4.6-2 .3-.6.7-1.1 1.2-1.6s1-.9 1.6-1.2c.6-.3 1.2-.5 2-.6.9-.2 1.8-.2 2.6-.2h139"
        }
      ),
      (0, import_jsx_runtime53.jsx)("path", { d: "M45.2 35.6c1.4-1.8 2.4-4.2 2.1-6.6-2.1.1-4.6 1.4-6.1 3.1-1.3 1.5-2.5 4-2.2 6.3 2.4.3 4.7-1 6.2-2.8M47.3 39c-3.4-.2-6.3 1.9-7.9 1.9-1.6 0-4.1-1.8-6.8-1.8-3.5.1-6.7 2-8.5 5.2-3.6 6.3-1 15.6 2.6 20.7 1.7 2.5 3.8 5.3 6.5 5.2 2.6-.1 3.6-1.7 6.7-1.7s4 1.7 6.8 1.6c2.8-.1 4.6-2.5 6.3-5.1 2-2.9 2.8-5.7 2.8-5.8-.1-.1-5.5-2.1-5.5-8.3-.1-5.2 4.2-7.7 4.4-7.8-2.3-3.6-6.1-4-7.4-4.1" }),
      (0, import_jsx_runtime53.jsx)("g", { children: (0, import_jsx_runtime53.jsx)("path", { d: "M76.7 31.9c7.4 0 12.5 5.1 12.5 12.4 0 7.4-5.2 12.5-12.7 12.5h-8.1v12.9h-5.9V31.9h14.2zm-8.3 20h6.7c5.1 0 8-2.8 8-7.5 0-4.8-2.9-7.5-8-7.5h-6.8v15zM90.7 62c0-4.8 3.7-7.8 10.3-8.2l7.6-.4v-2.1c0-3.1-2.1-4.9-5.5-4.9-3.3 0-5.3 1.6-5.8 4h-5.4c.3-5 4.6-8.7 11.4-8.7 6.7 0 11 3.5 11 9.1v19h-5.4v-4.5h-.1c-1.6 3.1-5.1 5-8.7 5-5.6 0-9.4-3.4-9.4-8.3zm17.9-2.5v-2.2l-6.8.4c-3.4.2-5.3 1.7-5.3 4.1 0 2.4 2 4 5 4 4 0 7.1-2.7 7.1-6.3zM119.3 80v-4.6c.4.1 1.4.1 1.8.1 2.6 0 4-1.1 4.9-3.9 0-.1.5-1.7.5-1.7l-10-27.6h6.1l7 22.5h.1l7-22.5h6l-10.3 29.1c-2.4 6.7-5.1 8.8-10.8 8.8-.4-.1-1.8-.1-2.3-.2z" }) })
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useIcon.js
var import_react37 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/svg/appleSvg.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var appleSvg = (0, import_jsx_runtime54.jsxs)(
  "svg",
  {
    "data-testid": "ock-appleSvg",
    role: "img",
    "aria-label": "ock-appleSvg",
    width: "14",
    height: "16",
    viewBox: "0 0 14 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime54.jsx)("title", { children: "Apple" }),
      (0, import_jsx_runtime54.jsx)(
        "path",
        {
          d: "M10.0788 0C10.1161 0 10.1533 0 10.1926 0C10.284 1.12836 9.85329 1.97146 9.32986 2.58201C8.81627 3.18834 8.11298 3.77641 6.97549 3.68718C6.89961 2.57498 7.331 1.79441 7.85373 1.18527C8.33851 0.617575 9.22729 0.112414 10.0788 0Z",
          className: icon.foreground
        }
      ),
      (0, import_jsx_runtime54.jsx)(
        "path",
        {
          d: "M13.5228 11.7446C13.5228 11.7558 13.5228 11.7657 13.5228 11.7762C13.2031 12.7444 12.7471 13.5741 12.1907 14.3442C11.6827 15.0432 11.0602 15.984 9.9487 15.984C8.98826 15.984 8.35031 15.3664 7.36598 15.3496C6.32475 15.3327 5.75214 15.866 4.80013 16.0002C4.69123 16.0002 4.58233 16.0002 4.47554 16.0002C3.77646 15.899 3.21228 15.3454 2.80127 14.8465C1.58931 13.3725 0.652757 11.4685 0.478516 9.0319C0.478516 8.79302 0.478516 8.55485 0.478516 8.31597C0.552287 6.57215 1.39961 5.15432 2.52586 4.46719C3.12025 4.10185 3.93735 3.7906 4.84721 3.92971C5.23714 3.99014 5.63551 4.12363 5.98469 4.25571C6.31561 4.38288 6.72944 4.60841 7.12148 4.59647C7.38706 4.58874 7.65123 4.45033 7.91892 4.35267C8.70301 4.06953 9.47164 3.74493 10.4848 3.89739C11.7024 4.08147 12.5665 4.62246 13.1005 5.45714C12.0705 6.11265 11.2562 7.10049 11.3953 8.7874C11.519 10.3197 12.4099 11.2162 13.5228 11.7446Z",
          className: icon.foreground
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/coinbaseLogoSvg.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var coinbaseLogoSvg = (0, import_jsx_runtime55.jsxs)(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 16 17",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: cn(icon.foreground),
    "data-testid": "coinbaseLogoSvg",
    children: [
      (0, import_jsx_runtime55.jsx)("title", { children: "Coinbase Pay Onramp" }),
      (0, import_jsx_runtime55.jsx)(
        "path",
        {
          d: "M7.93154 12.5C5.74045 12.5 3.96577 10.6354 3.96577 8.33333C3.96577 6.03125 5.74045 4.16667 7.93154 4.16667C9.8946 4.16667 11.5239 5.67014 11.8378 7.63889H15.8333C15.4962 3.36111 12.089 0 7.93154 0C3.55267 0 0 3.73264 0 8.33333C0 12.934 3.55267 16.6667 7.93154 16.6667C12.089 16.6667 15.4962 13.3056 15.8333 9.02778H11.8378C11.5239 10.9965 9.8946 12.5 7.93154 12.5Z",
          fill: "#0052FF"
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/coinbasePaySvg.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var coinbasePaySvg = (0, import_jsx_runtime56.jsx)(
  "svg",
  {
    role: "img",
    "aria-label": "ock-coinbasePaySvg",
    width: "100%",
    height: "100%",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime56.jsx)(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M10.0145 14.1666C7.82346 14.1666 6.04878 12.302 6.04878 9.99996C6.04878 7.69788 7.82346 5.83329 10.0145 5.83329C11.9776 5.83329 13.6069 7.33677 13.9208 9.30552H17.9163C17.5793 5.02774 14.172 1.66663 10.0145 1.66663C5.63568 1.66663 2.08301 5.39926 2.08301 9.99996C2.08301 14.6007 5.63568 18.3333 10.0145 18.3333C14.172 18.3333 17.5793 14.9722 17.9163 10.6944H13.9208C13.6069 12.6632 11.9776 14.1666 10.0145 14.1666Z",
        fill: "#f9fafb"
      }
    )
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/creditCardSvg.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var creditCardSvg = (0, import_jsx_runtime57.jsxs)(
  "svg",
  {
    "data-testid": "ock-creditCardSvg",
    role: "img",
    "aria-label": "ock-creditCardSvg",
    width: "14",
    height: "16",
    viewBox: "0 0 14 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime57.jsx)("title", { children: "Credit Card" }),
      (0, import_jsx_runtime57.jsx)(
        "path",
        {
          d: "M0.478516 2.33325V12.9999H13.5228V2.33325H0.478516ZM12.164 3.99992V5.33325H1.83729V3.99992H12.164ZM1.83729 11.3333V7.66659H12.164V11.3333H1.83729Z",
          className: icon.foreground
        }
      ),
      (0, import_jsx_runtime57.jsx)(
        "path",
        {
          d: "M2.65256 8.66659H7.00064V9.66659H2.65256V8.66659Z",
          className: icon.foreground
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/fundWallet.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var fundWalletSvg = (0, import_jsx_runtime58.jsx)(
  "svg",
  {
    role: "img",
    "aria-label": "ock-fundWalletSvg",
    width: "18",
    height: "18",
    viewBox: "0 0 18 18",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime58.jsx)(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M13.5 4.5C13.5 6.15685 14.8431 7.5 16.5 7.5V10.5C14.8431 10.5 13.5 11.8431 13.5 13.5H4.5C4.5 11.8431 3.15685 10.5 1.5 10.5L1.5 13.5V7.5C3.15685 7.5 4.5 6.15685 4.5 4.5H13.5ZM0 3V15H18V3H0ZM11.25 9C11.25 7.75736 10.2426 6.75 9 6.75C7.75736 6.75 6.75 7.75736 6.75 9C6.75 10.2426 7.75736 11.25 9 11.25C10.2426 11.25 11.25 10.2426 11.25 9Z",
        fill: "#0A0B0D",
        className: icon.foreground
      }
    )
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/swapSettings.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var swapSettingsSvg = (0, import_jsx_runtime59.jsx)(
  "svg",
  {
    role: "img",
    "aria-label": "ock-swapSettingsSvg",
    width: "100%",
    height: "100%",
    viewBox: "0 0 19 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime59.jsx)(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M8.92071 5.89742e-08C8.00371 5.89742e-08 7.22171 0.663 7.07071 1.567L6.89271 2.639C6.87271 2.759 6.77771 2.899 6.59571 2.987C6.25306 3.15171 5.92344 3.34226 5.60971 3.557C5.44371 3.672 5.27571 3.683 5.15971 3.64L4.14271 3.258C3.72695 3.10224 3.26941 3.09906 2.85152 3.24904C2.43364 3.39901 2.08254 3.69241 1.86071 4.077L0.938708 5.674C0.716797 6.05836 0.638423 6.50897 0.717525 6.94569C0.796628 7.3824 1.02808 7.7769 1.37071 8.059L2.21071 8.751C2.30571 8.829 2.38071 8.98 2.36471 9.181C2.33621 9.56013 2.33621 9.94087 2.36471 10.32C2.37971 10.52 2.30571 10.672 2.21171 10.75L1.37071 11.442C1.02808 11.7241 0.796628 12.1186 0.717525 12.5553C0.638423 12.992 0.716797 13.4426 0.938708 13.827L1.86071 15.424C2.08269 15.8084 2.43387 16.1016 2.85173 16.2514C3.2696 16.4012 3.72706 16.3978 4.14271 16.242L5.16171 15.86C5.27671 15.817 5.44471 15.829 5.61171 15.942C5.92371 16.156 6.25271 16.347 6.59671 16.512C6.77871 16.6 6.87371 16.74 6.89371 16.862L7.07171 17.933C7.22271 18.837 8.00471 19.5 8.92171 19.5H10.7657C11.6817 19.5 12.4647 18.837 12.6157 17.933L12.7937 16.861C12.8137 16.741 12.9077 16.601 13.0907 16.512C13.4347 16.347 13.7637 16.156 14.0757 15.942C14.2427 15.828 14.4107 15.817 14.5257 15.86L15.5457 16.242C15.9612 16.3972 16.4183 16.4001 16.8357 16.2502C17.2532 16.1002 17.6039 15.8071 17.8257 15.423L18.7487 13.826C18.9706 13.4416 19.049 12.991 18.9699 12.5543C18.8908 12.1176 18.6593 11.7231 18.3167 11.441L17.4767 10.749C17.3817 10.671 17.3067 10.52 17.3227 10.319C17.3511 9.93987 17.3511 9.55913 17.3227 9.18C17.3067 8.98 17.3817 8.828 17.4757 8.75L18.3157 8.058C19.0237 7.476 19.2067 6.468 18.7487 5.673L17.8267 4.076C17.6047 3.69159 17.2535 3.3984 16.8357 3.24861C16.4178 3.09883 15.9604 3.10215 15.5447 3.258L14.5247 3.64C14.4107 3.683 14.2427 3.671 14.0757 3.557C13.7623 3.3423 13.433 3.15175 13.0907 2.987C12.9077 2.9 12.8137 2.76 12.7937 2.639L12.6147 1.567C12.5418 1.12906 12.3158 0.731216 11.977 0.444267C11.6383 0.157318 11.2087 -0.00011124 10.7647 5.89742e-08H8.92171H8.92071ZM9.84271 13.5C10.8373 13.5 11.7911 13.1049 12.4944 12.4017C13.1976 11.6984 13.5927 10.7446 13.5927 9.75C13.5927 8.75544 13.1976 7.80161 12.4944 7.09835C11.7911 6.39509 10.8373 6 9.84271 6C8.84815 6 7.89432 6.39509 7.19106 7.09835C6.4878 7.80161 6.09271 8.75544 6.09271 9.75C6.09271 10.7446 6.4878 11.6984 7.19106 12.4017C7.89432 13.1049 8.84815 13.5 9.84271 13.5Z",
        fill: "#6B7280",
        className: icon.foreground
      }
    )
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/walletSvg.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var walletSvg = (0, import_jsx_runtime60.jsx)(
  "svg",
  {
    role: "img",
    "aria-label": "ock-walletSvg",
    width: "100%",
    height: "100%",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime60.jsx)(
      "path",
      {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M0 10C0 15.5222 4.47778 20 10 20C15.5222 20 20 15.5222 20 10C20 4.47778 15.5222 0 10 0C4.47778 0 0 4.47778 0 10ZM7.44444 6.77778C7.075 6.77778 6.77778 7.075 6.77778 7.44444V12.5556C6.77778 12.925 7.075 13.2222 7.44444 13.2222H12.5556C12.925 13.2222 13.2222 12.925 13.2222 12.5556V7.44444C13.2222 7.075 12.925 6.77778 12.5556 6.77778H7.44444Z",
        className: icon.foreground
      }
    )
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useIcon.js
var useIcon = ({ icon: icon2 }) => {
  return (0, import_react37.useMemo)(() => {
    if (icon2 === void 0) {
      return null;
    }
    switch (icon2) {
      case "coinbasePay":
        return coinbasePaySvg;
      case "coinbaseLogo":
        return coinbaseLogoSvg;
      case "fundWallet":
        return fundWalletSvg;
      case "swapSettings":
        return swapSettingsSvg;
      case "wallet":
        return walletSvg;
      case "toggle":
        return toggleSvg;
      case "applePay":
        return applePaySvg;
      case "apple":
        return appleSvg;
      case "creditCard":
        return creditCardSvg;
    }
    if ((0, import_react37.isValidElement)(icon2)) {
      return icon2;
    }
  }, [icon2]);
};

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapSettings.js
var import_react39 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapSettingsSlippageDescription.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
function SwapSettingsSlippageDescription({
  children,
  className
}) {
  return (0, import_jsx_runtime61.jsx)("p", { className: cn(text.legal, color.foregroundMuted, "mb-2", className), children });
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapSettingsSlippageInput.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_react38 = __toESM(require_react(), 1);
var SLIPPAGE_SETTINGS = {
  AUTO: "Auto",
  CUSTOM: "Custom"
};
function SwapSettingsSlippageInput({
  className
}) {
  const { sendAnalytics } = useAnalytics();
  const {
    config: { maxSlippage: defaultMaxSlippage },
    updateLifecycleStatus,
    lifecycleStatus
  } = useSwapContext();
  const [slippageSetting, setSlippageSetting] = (0, import_react38.useState)(
    lifecycleStatus.statusData.maxSlippage === defaultMaxSlippage ? SLIPPAGE_SETTINGS.AUTO : SLIPPAGE_SETTINGS.CUSTOM
  );
  const handleAnalyticsSlippageChange = (0, import_react38.useCallback)(
    (previousSlippage, newSlippage) => {
      sendAnalytics(SwapEvent.SlippageChanged, {
        previousSlippage,
        slippage: newSlippage
      });
    },
    [sendAnalytics]
  );
  const updateSlippage = (0, import_react38.useCallback)(
    (newSlippage) => {
      const currentSlippage = lifecycleStatus.statusData.maxSlippage;
      if (newSlippage !== currentSlippage) {
        handleAnalyticsSlippageChange(currentSlippage, newSlippage);
        updateLifecycleStatus({
          statusName: "slippageChange",
          statusData: {
            maxSlippage: newSlippage
          }
        });
      }
    },
    [
      lifecycleStatus.statusData.maxSlippage,
      updateLifecycleStatus,
      handleAnalyticsSlippageChange
    ]
  );
  const handleSlippageChange = (0, import_react38.useCallback)(
    (e) => {
      const newSlippage = e.target.value;
      const parsedSlippage = Number.parseFloat(newSlippage);
      const isValidNumber = !Number.isNaN(parsedSlippage);
      updateSlippage(isValidNumber ? parsedSlippage : 0);
    },
    [updateSlippage]
  );
  const handleSlippageSettingChange = (0, import_react38.useCallback)(
    (setting) => {
      setSlippageSetting(setting);
      if (setting === SLIPPAGE_SETTINGS.AUTO) {
        updateSlippage(defaultMaxSlippage);
      }
    },
    [defaultMaxSlippage, updateSlippage]
  );
  return (0, import_jsx_runtime62.jsxs)(
    "section",
    {
      className: cn(
        background.default,
        border.defaultActive,
        border.radius,
        "flex items-center gap-2 flex-grow max-sm:pt-4",
        className
      ),
      children: [
        (0, import_jsx_runtime62.jsxs)(
          "fieldset",
          {
            className: cn(
              background.default,
              border.defaultActive,
              border.radius,
              "flex h-9 flex-1 rounded-xl border p-1"
            ),
            children: [
              (0, import_jsx_runtime62.jsx)("legend", { className: "sr-only", children: "Slippage Setting" }),
              Object.values(SLIPPAGE_SETTINGS).map((setting) => (0, import_jsx_runtime62.jsx)(
                "button",
                {
                  type: "button",
                  className: cn(
                    pressable.default,
                    color.foreground,
                    text.label1,
                    border.radiusInner,
                    "flex-1 px-3 py-1 transition-colors",
                    // Highlight the button if it is selected
                    slippageSetting === setting ? cn(background.inverse, color.primary, pressable.shadow) : color.foregroundMuted
                  ),
                  onClick: () => handleSlippageSettingChange(setting),
                  children: setting
                },
                setting
              ))
            ]
          }
        ),
        (0, import_jsx_runtime62.jsxs)(
          "div",
          {
            className: cn(
              background.default,
              border.defaultActive,
              border.radius,
              "flex h-9 w-24 items-center justify-between border px-2 py-1",
              slippageSetting === SLIPPAGE_SETTINGS.AUTO && "opacity-50"
            ),
            children: [
              (0, import_jsx_runtime62.jsx)("label", { htmlFor: "slippage-input", className: "sr-only", children: "Slippage Percentage" }),
              (0, import_jsx_runtime62.jsx)(
                "input",
                {
                  id: "slippage-input",
                  type: "text",
                  value: lifecycleStatus.statusData.maxSlippage,
                  onChange: handleSlippageChange,
                  disabled: slippageSetting === SLIPPAGE_SETTINGS.AUTO,
                  className: cn(
                    color.foreground,
                    text.label2,
                    "w-full flex-grow bg-transparent pl-1 font-normal leading-6 focus:outline-none",
                    slippageSetting === SLIPPAGE_SETTINGS.AUTO && "cursor-not-allowed"
                  )
                }
              ),
              (0, import_jsx_runtime62.jsx)(
                "span",
                {
                  className: cn(
                    background.default,
                    color.foreground,
                    text.label2,
                    "ml-1 flex-shrink-0 font-normal leading-6"
                  ),
                  children: "%"
                }
              )
            ]
          }
        )
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapSettingsSlippageLayout.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
function SwapSettingsSlippageLayout({
  children,
  className
}) {
  return (0, import_jsx_runtime63.jsx)(
    "div",
    {
      className: cn(
        background.default,
        border.radius,
        border.lineDefault,
        "right-0 z-10 w-[21.75rem] px-3 py-3",
        className
      ),
      "data-testid": "ockSwapSettingsLayout_container",
      children
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapSettingsSlippageLayoutBottomSheet.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
function SwapSettingsSlippageLayoutBottomSheet({
  children,
  className
}) {
  return (0, import_jsx_runtime64.jsxs)(
    "div",
    {
      className: cn(
        background.default,
        border.default,
        pressable.shadow,
        "right-0 z-10 h-full w-full rounded-t-lg px-3 pt-2 pb-3",
        className
      ),
      "data-testid": "ockSwapSettingsLayout_container",
      children: [
        (0, import_jsx_runtime64.jsx)(
          "div",
          {
            className: cn(
              background.alternate,
              "mx-auto mb-2 h-1 w-4 rounded-[6.25rem]"
            )
          }
        ),
        (0, import_jsx_runtime64.jsx)("div", { className: "mb-4 flex items-center justify-center", children: (0, import_jsx_runtime64.jsx)("h2", { className: cn(color.foreground, "font-bold text-sm"), children: "Settings" }) }),
        (0, import_jsx_runtime64.jsx)("div", { className: "flex flex-col", children }),
        (0, import_jsx_runtime64.jsx)("div", { className: "mt-4 flex justify-center", children: (0, import_jsx_runtime64.jsx)(
          "div",
          {
            className: cn(
              background.inverse,
              "h-1 w-28 shrink-0 rounded-[0.43931rem]"
            )
          }
        ) })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapSettingsSlippageTitle.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
function SwapSettingsSlippageTitle({
  children,
  className
}) {
  return (0, import_jsx_runtime65.jsx)(
    "h3",
    {
      className: cn(
        text.headline,
        color.foreground,
        "mb-2 text-base",
        className
      ),
      children
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapSettings.js
var DEFAULT_CHILDREN = (0, import_jsx_runtime66.jsxs)(import_jsx_runtime66.Fragment, { children: [
  (0, import_jsx_runtime66.jsx)(SwapSettingsSlippageTitle, { children: "Max. slippage" }),
  (0, import_jsx_runtime66.jsx)(SwapSettingsSlippageDescription, { children: "Your swap will revert if the prices change by more than the selected percentage." }),
  (0, import_jsx_runtime66.jsx)(SwapSettingsSlippageInput, {})
] });
function SwapSettings({
  children = DEFAULT_CHILDREN,
  className,
  icon: icon2 = "swapSettings",
  text: buttonText = ""
}) {
  const breakpoint = useBreakpoints();
  const [isOpen, setIsOpen] = (0, import_react39.useState)(false);
  const dropdownRef = (0, import_react39.useRef)(null);
  const triggerRef = (0, import_react39.useRef)(null);
  const handleToggle = (0, import_react39.useCallback)((e) => {
    e.stopPropagation();
    setIsOpen((prev) => !prev);
  }, []);
  const handleClose = (0, import_react39.useCallback)(() => {
    setIsOpen(false);
  }, []);
  const iconSvg = useIcon({ icon: icon2 });
  return (0, import_jsx_runtime66.jsxs)(
    "div",
    {
      className: cn(
        "flex w-auto items-center justify-end space-x-1 pb-4",
        className
      ),
      "data-testid": "ockSwapSettings_Settings",
      children: [
        buttonText && (0, import_jsx_runtime66.jsx)("span", { className: cn(text.body), children: buttonText }),
        (0, import_jsx_runtime66.jsxs)("div", { className: cn("relative", isOpen && "group"), ref: dropdownRef, children: [
          (0, import_jsx_runtime66.jsx)(
            "button",
            {
              ref: triggerRef,
              type: "button",
              "aria-label": "Toggle swap settings",
              className: cn(
                pressable.default,
                "rounded-full p-2 opacity-50 transition-opacity hover:opacity-100"
              ),
              onClick: handleToggle,
              children: (0, import_jsx_runtime66.jsx)("div", { className: "h-[1.125rem] w-[1.125rem]", children: iconSvg })
            }
          ),
          breakpoint === "sm" ? (0, import_jsx_runtime66.jsx)(FocusTrap, { active: isOpen, children: (0, import_jsx_runtime66.jsx)(
            DismissableLayer,
            {
              onDismiss: handleClose,
              triggerRef,
              preventTriggerEvents: true,
              children: (0, import_jsx_runtime66.jsx)(
                "div",
                {
                  className: cn(
                    background.inverse,
                    pressable.shadow,
                    "fixed inset-x-0 z-50 transition-[bottom] duration-300 ease-in-out",
                    isOpen ? "bottom-0" : "-bottom-[12.875rem]",
                    "h-[12.875rem] rounded-t-lg",
                    className
                  ),
                  "data-testid": "ockSwapSettingsSlippageLayoutBottomSheet_container",
                  children: (0, import_jsx_runtime66.jsx)(SwapSettingsSlippageLayoutBottomSheet, { className, children })
                }
              )
            }
          ) }) : (0, import_jsx_runtime66.jsx)(
            Popover,
            {
              isOpen,
              onClose: handleClose,
              anchor: dropdownRef.current,
              position: "bottom",
              align: "end",
              trigger: triggerRef,
              children: (0, import_jsx_runtime66.jsx)(
                "div",
                {
                  className: cn(
                    border.radius,
                    background.default,
                    pressable.shadow,
                    "absolute right-0 z-10 mt-1 w-[21.75rem] rounded-lg"
                  ),
                  "data-testid": "ockSwapSettingsDropdown",
                  children: (0, import_jsx_runtime66.jsx)(SwapSettingsSlippageLayout, { children })
                }
              )
            }
          )
        ] })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapToast.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react40 = __toESM(require_react(), 1);
function SwapToast({
  className,
  durationMs = 5e3,
  position = "bottom-center"
}) {
  const {
    isToastVisible,
    setIsToastVisible,
    setTransactionHash,
    transactionHash
  } = useSwapContext();
  const { chainId } = useAccount();
  const chainExplorer = getChainExplorer(chainId);
  const resetToastState = (0, import_react40.useCallback)(() => {
    setIsToastVisible(false);
    setTransactionHash("");
  }, [setIsToastVisible, setTransactionHash]);
  if (!isToastVisible) {
    return null;
  }
  return (0, import_jsx_runtime67.jsxs)(
    Toast,
    {
      position,
      className,
      durationMs,
      isVisible: isToastVisible,
      onClose: resetToastState,
      children: [
        (0, import_jsx_runtime67.jsx)("div", { className: cn(text.label2), children: (0, import_jsx_runtime67.jsx)(SuccessSvg, {}) }),
        (0, import_jsx_runtime67.jsx)("div", { className: cn(text.label1, "text-nowrap"), children: (0, import_jsx_runtime67.jsx)("p", { className: color.foreground, children: "Successful" }) }),
        (0, import_jsx_runtime67.jsx)("div", { className: cn(text.label1, "text-nowrap"), children: (0, import_jsx_runtime67.jsx)(
          "a",
          {
            href: `${chainExplorer}/tx/${transactionHash}`,
            target: "_blank",
            rel: "noreferrer",
            children: (0, import_jsx_runtime67.jsx)("span", { className: cn(text.label1, color.primary), children: "View transaction" })
          }
        ) })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/swap/components/SwapToggleButton.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
function SwapToggleButton({ className }) {
  const { handleToggle } = useSwapContext();
  return (0, import_jsx_runtime68.jsx)(
    "button",
    {
      type: "button",
      className: cn(
        pressable.alternate,
        border.default,
        "-my-6 relative mx-auto",
        "flex h-12 w-12 items-center justify-center",
        "rounded-lg border-4 border-solid",
        className
      ),
      "data-testid": "SwapTokensButton",
      onClick: handleToggle,
      children: toggleSvg
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/swap/components/Swap.js
function SwapDefaultContent({
  to,
  from,
  disabled
}) {
  return (0, import_jsx_runtime69.jsxs)(import_jsx_runtime69.Fragment, { children: [
    (0, import_jsx_runtime69.jsx)(SwapSettings, {}),
    (0, import_jsx_runtime69.jsx)(
      SwapAmountInput,
      {
        label: "Sell",
        swappableTokens: from,
        token: from == null ? void 0 : from[0],
        type: "from"
      }
    ),
    (0, import_jsx_runtime69.jsx)(SwapToggleButton, {}),
    (0, import_jsx_runtime69.jsx)(
      SwapAmountInput,
      {
        label: "Buy",
        swappableTokens: to,
        token: to == null ? void 0 : to[0],
        type: "to"
      }
    ),
    (0, import_jsx_runtime69.jsx)(SwapButton, { disabled }),
    (0, import_jsx_runtime69.jsx)(SwapMessage2, {}),
    (0, import_jsx_runtime69.jsx)(SwapToast, {})
  ] });
}
function Swap({
  children,
  config = {
    maxSlippage: FALLBACK_DEFAULT_MAX_SLIPPAGE
  },
  className,
  disabled,
  to,
  from,
  experimental = { useAggregator: false },
  isSponsored = false,
  onError,
  onStatus,
  onSuccess,
  title = "Swap",
  headerLeftContent
}) {
  const componentTheme = useTheme();
  const isMounted = useIsMounted();
  if (!isMounted) {
    return null;
  }
  return (0, import_jsx_runtime69.jsx)(
    SwapProvider,
    {
      config,
      experimental,
      isSponsored,
      onError,
      onStatus,
      onSuccess,
      children: (0, import_jsx_runtime69.jsxs)(
        "div",
        {
          className: cn(
            componentTheme,
            background.default,
            border.radius,
            color.foreground,
            "relative flex w-full max-w-[500px] flex-col px-6 pt-6 pb-4",
            className
          ),
          "data-testid": "ockSwap_Container",
          children: [
            (0, import_jsx_runtime69.jsxs)("div", { className: "absolute flex w-1/2 items-center justify-between", children: [
              headerLeftContent,
              (0, import_jsx_runtime69.jsx)(
                "h3",
                {
                  className: cn(text.title3, "text-center"),
                  "data-testid": "ockSwap_Title",
                  children: title
                }
              )
            ] }),
            children ?? (0, import_jsx_runtime69.jsx)(SwapDefaultContent, { to, from, disabled })
          ]
        }
      )
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedSwap.js
var import_react41 = __toESM(require_react(), 1);
function WalletAdvancedSwap({
  config,
  classNames,
  disabled,
  experimental,
  from,
  isSponsored = false,
  onError,
  onStatus,
  onSuccess,
  title,
  to
}) {
  var _a, _b, _c, _d;
  const {
    setActiveFeature,
    isActiveFeatureClosing,
    setIsActiveFeatureClosing
  } = useWalletContext();
  const handleCloseSwap = (0, import_react41.useCallback)(() => {
    setIsActiveFeatureClosing(true);
  }, [setIsActiveFeatureClosing]);
  const handleAnimationEnd = (0, import_react41.useCallback)(() => {
    if (isActiveFeatureClosing) {
      setActiveFeature(null);
      setIsActiveFeatureClosing(false);
    }
  }, [isActiveFeatureClosing, setActiveFeature, setIsActiveFeatureClosing]);
  const backButton = (0, import_jsx_runtime70.jsx)(PressableIcon, { ariaLabel: "Back button", onClick: handleCloseSwap, children: (0, import_jsx_runtime70.jsx)("div", { className: "p-2", children: backArrowSvg }) });
  return (0, import_jsx_runtime70.jsx)(
    "div",
    {
      className: cn(
        "h-full",
        border.radius,
        isActiveFeatureClosing ? "fade-out slide-out-to-right-5 animate-out fill-mode-forwards ease-in-out" : "fade-in slide-in-from-right-5 linear animate-in duration-150",
        "relative w-88 h-120",
        classNames == null ? void 0 : classNames.container
      ),
      onAnimationEnd: handleAnimationEnd,
      "data-testid": "ockWalletAdvancedSwap",
      children: (0, import_jsx_runtime70.jsxs)(
        Swap,
        {
          className: cn("w-full px-4 pt-3 pb-4", classNames == null ? void 0 : classNames.container),
          onStatus,
          onSuccess,
          onError,
          config,
          isSponsored,
          title,
          experimental,
          headerLeftContent: backButton,
          children: [
            (0, import_jsx_runtime70.jsxs)(SwapSettings, { className: cn("w-auto", (_a = classNames == null ? void 0 : classNames.settings) == null ? void 0 : _a.container), children: [
              (0, import_jsx_runtime70.jsx)(
                SwapSettingsSlippageTitle,
                {
                  className: (_b = classNames == null ? void 0 : classNames.settings) == null ? void 0 : _b.slippageTitle,
                  children: "Max. slippage"
                }
              ),
              (0, import_jsx_runtime70.jsx)(
                SwapSettingsSlippageDescription,
                {
                  className: (_c = classNames == null ? void 0 : classNames.settings) == null ? void 0 : _c.slippageDescription,
                  children: "Your swap will revert if the prices change by more than the selected percentage."
                }
              ),
              (0, import_jsx_runtime70.jsx)(
                SwapSettingsSlippageInput,
                {
                  className: (_d = classNames == null ? void 0 : classNames.settings) == null ? void 0 : _d.slippageInput
                }
              )
            ] }),
            (0, import_jsx_runtime70.jsx)(
              SwapAmountInput,
              {
                label: "Sell",
                swappableTokens: from,
                type: "from",
                className: classNames == null ? void 0 : classNames.fromAmountInput
              }
            ),
            (0, import_jsx_runtime70.jsx)(SwapToggleButton, { className: classNames == null ? void 0 : classNames.toggleButton }),
            (0, import_jsx_runtime70.jsx)(
              SwapAmountInput,
              {
                label: "Buy",
                swappableTokens: to,
                type: "to",
                className: classNames == null ? void 0 : classNames.toAmountInput
              }
            ),
            (0, import_jsx_runtime70.jsx)(SwapButton, { disabled, className: classNames == null ? void 0 : classNames.swapButton }),
            (0, import_jsx_runtime70.jsx)(SwapMessage2, { className: classNames == null ? void 0 : classNames.message }),
            (0, import_jsx_runtime70.jsx)(SwapToast, { className: classNames == null ? void 0 : classNames.toast })
          ]
        }
      )
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/Send.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/constants.js
var ETH_REQUIRED_FOR_SEND = 1e-6;

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendAmountInput.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/amount-input/AmountInput.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useInputResize.js
var import_react42 = __toESM(require_react(), 1);
var defaultConfig = {
  baseFontSize: 3.75,
  // 60px = 3.75rem at default browser font size
  minScale: 0.01
};
function useInputResize(containerRef, wrapperRef, inputRef, measureRef, labelRef, config = {}) {
  const { baseFontSize, minScale } = {
    ...defaultConfig,
    ...config
  };
  const updateScale = (0, import_react42.useCallback)(() => {
    const container = containerRef.current;
    const wrapper = wrapperRef.current;
    const input = inputRef.current;
    const measure = measureRef.current;
    const label = labelRef.current;
    if (!container || !wrapper || !input || !measure || !label) {
      return;
    }
    measure.style.fontSize = `${baseFontSize}rem`;
    input.style.fontSize = `${baseFontSize}rem`;
    const contentWidth = measure.clientWidth;
    const availableWidth = container.clientWidth - label.clientWidth;
    input.style.width = `${contentWidth}px`;
    if (contentWidth > availableWidth) {
      const scale = availableWidth / contentWidth;
      const finalScale = Math.max(scale, minScale);
      wrapper.style.transform = `scale(${finalScale})`;
      wrapper.style.transformOrigin = "left center";
    } else {
      wrapper.style.transform = "scale(1)";
    }
  }, [
    baseFontSize,
    minScale,
    containerRef,
    wrapperRef,
    inputRef,
    measureRef,
    labelRef
  ]);
  (0, import_react42.useEffect)(() => {
    const container = containerRef.current;
    if (!container) {
      return;
    }
    const resizeObserver = new ResizeObserver(updateScale);
    resizeObserver.observe(container);
    return () => {
      resizeObserver.disconnect();
    };
  }, [containerRef, updateScale]);
  return updateScale;
}

// node_modules/@coinbase/onchainkit/dist/internal/components/amount-input/AmountInput.js
var import_react45 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/utils/truncateDecimalPlaces.js
var truncateDecimalPlaces = (value, decimalPlaces) => {
  const stringValue = String(value);
  const decimalIndex = stringValue.indexOf(".");
  let resultValue = stringValue;
  if (decimalIndex !== -1 && stringValue.length - decimalIndex - 1 > decimalPlaces) {
    resultValue = stringValue.substring(0, decimalIndex + decimalPlaces + 1);
  }
  return resultValue;
};

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useAmountInput.js
var import_react43 = __toESM(require_react(), 1);
var useAmountInput = ({
  setFiatAmount,
  setCryptoAmount,
  selectedInputType,
  exchangeRate
}) => {
  const handleFiatChange = (0, import_react43.useCallback)(
    (value) => {
      const fiatValue = truncateDecimalPlaces(value, 2);
      setFiatAmount(fiatValue);
      const calculatedCryptoValue = String(
        Number(fiatValue) * Number(exchangeRate)
      );
      const resultCryptoValue = truncateDecimalPlaces(calculatedCryptoValue, 8);
      setCryptoAmount(calculatedCryptoValue === "0" ? "" : resultCryptoValue);
    },
    [exchangeRate, setFiatAmount, setCryptoAmount]
  );
  const handleCryptoChange = (0, import_react43.useCallback)(
    (value) => {
      const truncatedValue = truncateDecimalPlaces(value, 8);
      setCryptoAmount(truncatedValue);
      const calculatedFiatValue = String(
        Number(truncatedValue) / Number(exchangeRate)
      );
      const resultFiatValue = truncateDecimalPlaces(calculatedFiatValue, 2);
      setFiatAmount(resultFiatValue === "0" ? "" : resultFiatValue);
    },
    [exchangeRate, setFiatAmount, setCryptoAmount]
  );
  const handleChange = (0, import_react43.useCallback)(
    (value, onChange) => {
      if (selectedInputType === "fiat") {
        handleFiatChange(value);
      } else {
        handleCryptoChange(value);
      }
      onChange == null ? void 0 : onChange(value);
    },
    [handleFiatChange, handleCryptoChange, selectedInputType]
  );
  return (0, import_react43.useMemo)(
    () => ({
      handleChange,
      handleFiatChange,
      handleCryptoChange
    }),
    [handleChange, handleFiatChange, handleCryptoChange]
  );
};

// node_modules/@coinbase/onchainkit/dist/internal/components/amount-input/CurrencyLabel.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);
var CurrencyLabel = (0, import_react44.forwardRef)(
  ({ label, className }, ref) => {
    return (0, import_jsx_runtime71.jsx)(
      "span",
      {
        ref,
        className: cn(
          text.body,
          color.disabled,
          "flex items-center justify-center bg-transparent",
          "text-6xl leading-none outline-none",
          className
        ),
        "data-testid": "ockCurrencySpan",
        children: label
      }
    );
  }
);
CurrencyLabel.displayName = "CurrencyLabel";

// node_modules/@coinbase/onchainkit/dist/internal/components/amount-input/AmountInput.js
function AmountInput({
  fiatAmount,
  cryptoAmount,
  asset,
  selectedInputType,
  currency,
  setFiatAmount,
  setCryptoAmount,
  exchangeRate,
  delayMs,
  className,
  textClassName
}) {
  const containerRef = (0, import_react45.useRef)(null);
  const wrapperRef = (0, import_react45.useRef)(null);
  const inputRef = (0, import_react45.useRef)(null);
  const measureRef = (0, import_react45.useRef)(null);
  const labelRef = (0, import_react45.useRef)(null);
  const currencyOrAsset = selectedInputType === "fiat" ? currency : asset;
  const value = selectedInputType === "fiat" ? fiatAmount : cryptoAmount;
  const updateScale = useInputResize(
    containerRef,
    wrapperRef,
    inputRef,
    measureRef,
    labelRef
  );
  const { handleChange } = useAmountInput({
    setFiatAmount,
    setCryptoAmount,
    selectedInputType,
    exchangeRate
  });
  const handleAmountChange = (0, import_react45.useCallback)(
    (value2) => {
      handleChange(value2, () => {
        if (inputRef.current) {
          inputRef.current.focus();
        }
      });
    },
    [handleChange]
  );
  (0, import_react45.useEffect)(() => {
    updateScale();
  }, [value, updateScale]);
  const selectedInputTypeRef = (0, import_react45.useRef)(selectedInputType);
  (0, import_react45.useEffect)(() => {
    if (selectedInputTypeRef.current !== selectedInputType) {
      selectedInputTypeRef.current = selectedInputType;
      handleFocusInput();
    }
  }, [selectedInputType]);
  const handleFocusInput = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  return (0, import_jsx_runtime72.jsxs)(
    "div",
    {
      ref: containerRef,
      "data-testid": "ockAmountInputContainer",
      className: cn("relative h-24 cursor-text", className),
      children: [
        (0, import_jsx_runtime72.jsx)("div", { className: "absolute inset-x-0 top-6 bottom-4", children: (0, import_jsx_runtime72.jsx)("div", { className: "relative flex h-14", children: (0, import_jsx_runtime72.jsxs)("div", { ref: wrapperRef, className: "flex flex-shrink-0 items-center", children: [
          (0, import_jsx_runtime72.jsx)(
            TextInput,
            {
              className: cn(
                text.body,
                "border-none bg-transparent",
                "text-6xl leading-none outline-none",
                "[appearance:textfield]",
                "[&::-webkit-inner-spin-button]:m-0 [&::-webkit-inner-spin-button]:appearance-none",
                "[&::-webkit-outer-spin-button]:m-0 [&::-webkit-outer-spin-button]:appearance-none",
                textClassName
              ),
              value,
              onChange: handleAmountChange,
              delayMs,
              inputValidator: isValidAmount,
              ref: inputRef,
              inputMode: "decimal",
              placeholder: "0"
            }
          ),
          (0, import_jsx_runtime72.jsx)("div", { className: "ml-1", children: (0, import_jsx_runtime72.jsx)(
            CurrencyLabel,
            {
              ref: labelRef,
              label: currencyOrAsset,
              className: textClassName
            }
          ) })
        ] }) }) }),
        (0, import_jsx_runtime72.jsx)(
          "span",
          {
            "data-testid": "ockHiddenSpan",
            ref: measureRef,
            className: cn(
              text.body,
              "border-none bg-transparent",
              "text-6xl leading-none outline-none",
              "pointer-events-none absolute whitespace-nowrap opacity-0",
              "left-[-99999px]"
              // Hide the span from the DOM
            ),
            children: value ? `${value}.` : "0."
          }
        )
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendAmountInputTypeSwitch.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/amount-input/AmountInputTypeSwitch.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var import_react46 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/utils/formatFiatAmount.js
var formatFiatAmount = ({
  amount,
  currency = "USD",
  locale,
  minimumFractionDigits = 2,
  maximumFractionDigits = 2
}) => {
  let parsedAmount = Number(amount);
  if (Number.isNaN(parsedAmount)) {
    parsedAmount = 0;
  }
  return new Intl.NumberFormat(locale, {
    style: "currency",
    currency,
    minimumFractionDigits,
    maximumFractionDigits
  }).format(parsedAmount);
};

// node_modules/@coinbase/onchainkit/dist/internal/components/amount-input/AmountInputTypeSwitch.js
function AmountInputTypeSwitch({
  selectedInputType,
  setSelectedInputType,
  asset,
  fiatAmount,
  cryptoAmount,
  exchangeRate,
  exchangeRateLoading,
  currency,
  loadingDisplay = (0, import_jsx_runtime73.jsx)(Skeleton, { className: "h-[1.625rem]" }),
  className
}) {
  const iconSvg = useIcon({ icon: "toggle" });
  const handleToggle = (0, import_react46.useCallback)(() => {
    setSelectedInputType(selectedInputType === "fiat" ? "crypto" : "fiat");
  }, [selectedInputType, setSelectedInputType]);
  const formatCrypto = (0, import_react46.useCallback)(
    (amount) => {
      return `${truncateDecimalPlaces(amount || "0", 8)} ${asset}`;
    },
    [asset]
  );
  const amountLine = (0, import_react46.useMemo)(() => {
    return (0, import_jsx_runtime73.jsx)("span", { "data-testid": "ockAmountLine", className: cn(text.label1), children: selectedInputType === "fiat" ? formatCrypto(cryptoAmount) : formatFiatAmount({
      amount: fiatAmount,
      currency,
      minimumFractionDigits: 0
    }) });
  }, [cryptoAmount, fiatAmount, selectedInputType, formatCrypto, currency]);
  if (exchangeRateLoading || !exchangeRate) {
    return loadingDisplay;
  }
  return (0, import_jsx_runtime73.jsxs)("div", { className: cn("flex items-center", className), children: [
    (0, import_jsx_runtime73.jsx)(
      "button",
      {
        type: "button",
        "aria-label": "amount type switch",
        className: cn(
          pressable.default,
          "mr-1 rounded-full p-1 opacity-50 transition-opacity hover:opacity-100"
        ),
        "data-testid": "ockAmountTypeSwitch",
        onClick: handleToggle,
        children: (0, import_jsx_runtime73.jsx)("div", { className: "h-[1.125rem] w-[1.125rem]", children: iconSvg })
      }
    ),
    (0, import_jsx_runtime73.jsx)("div", { className: "w-full truncate", children: amountLine })
  ] });
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendProvider.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/api/getPriceQuote.js
async function getPriceQuote(params, _context = RequestContext.API) {
  const apiParams = validateGetPriceQuoteParams(params);
  if ("error" in apiParams) {
    return apiParams;
  }
  try {
    const res = await sendRequest(
      CDP_GET_PRICE_QUOTE,
      [apiParams],
      _context
    );
    if (res.error) {
      return {
        code: String(res.error.code),
        error: "Error fetching price quote",
        message: res.error.message
      };
    }
    return res.result;
  } catch (error) {
    return {
      code: "UNCAUGHT_PRICE_QUOTE_ERROR",
      error: "Something went wrong",
      message: `Error fetching price quote: ${error}`
    };
  }
}
function validateGetPriceQuoteParams(params) {
  const { tokens } = params;
  if (!tokens || tokens.length === 0) {
    return {
      code: "INVALID_INPUT",
      error: "Invalid input: tokens must be an array of at least one token",
      message: "Tokens must be an array of at least one token"
    };
  }
  return params;
}

// node_modules/@coinbase/onchainkit/dist/internal/hooks/usePriceQuote.js
function usePriceQuote(params, _context = RequestContext.Hook) {
  const { token, queryOptions } = params;
  return useQuery({
    queryKey: ["getPriceQuote", token],
    queryFn: async () => {
      if (!token) {
        return {
          priceQuotes: []
        };
      }
      const response = await getPriceQuote({ tokens: [token] }, _context);
      if (isApiError(response)) {
        throw response;
      }
      return response;
    },
    ...DEFAULT_QUERY_OPTIONS,
    ...queryOptions
  });
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendProvider.js
var import_react48 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/hooks/useRecipientState.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var import_react47 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/identity/utils/isEns.js
var isEns = (username) => {
  if (username.endsWith(".base.eth") || username.endsWith(".basetest.eth")) {
    return false;
  }
  if (username.endsWith(".eth") || username.endsWith(".test.eth")) {
    return true;
  }
  return false;
};

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/utils/validateAddressInput.js
async function validateAddressInput(input) {
  if (isAddress(input, { strict: false })) {
    return input;
  }
  if (isBasename(input) || isEns(input)) {
    const address = await getAddress({
      name: input,
      chain: isBasename(input) ? base : mainnet
    });
    if (address) {
      return address;
    }
  }
  return null;
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/hooks/useRecipientState.js
function useRecipientState() {
  const [recipientState, setRecipientState] = (0, import_react47.useState)({
    phase: "input",
    input: "",
    address: null,
    displayValue: null
  });
  const updateRecipientInput = (0, import_react47.useCallback)((input) => {
    setRecipientState((prev) => ({
      ...prev,
      input
    }));
  }, []);
  const validateRecipientInput = (0, import_react47.useCallback)((input) => {
    validateAddressInput(input).then((validatedAddress) => {
      if (!validatedAddress) {
        setRecipientState({
          phase: "input",
          input,
          address: null,
          displayValue: null
        });
        return;
      }
      setRecipientState({
        phase: "validated",
        input,
        address: validatedAddress,
        displayValue: null
      });
    });
  }, []);
  const selectRecipient = (0, import_react47.useCallback)(
    async (selection) => {
      setRecipientState(selection);
    },
    []
  );
  const deselectRecipient = (0, import_react47.useCallback)(() => {
    if (recipientState.phase === "selected") {
      setRecipientState({
        phase: "validated",
        input: recipientState.input,
        address: recipientState.address,
        displayValue: null
      });
    } else {
      setRecipientState({
        ...recipientState,
        displayValue: null
      });
    }
  }, [recipientState]);
  (0, import_react47.useEffect)(() => {
    if (recipientState.phase === "selected") {
      getName({
        address: recipientState.address,
        chain: base
      }).then((name) => {
        setRecipientState({
          phase: recipientState.phase,
          input: recipientState.input,
          address: recipientState.address,
          displayValue: name ?? getSlicedAddress(recipientState.address)
        });
      }).catch(
        () => setRecipientState({
          phase: recipientState.phase,
          input: recipientState.input,
          address: recipientState.address,
          displayValue: getSlicedAddress(recipientState.address)
        })
      );
    }
  }, [recipientState.phase, recipientState.address, recipientState.input]);
  return {
    recipientState,
    updateRecipientInput,
    validateRecipientInput,
    selectRecipient,
    deselectRecipient
  };
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendProvider.js
var emptyContext3 = {};
var SendContext = (0, import_react48.createContext)(emptyContext3);
function useSendContext() {
  const sendContext = (0, import_react48.useContext)(SendContext);
  if (sendContext === emptyContext3) {
    throw new Error("useSendContext must be used within a SendProvider");
  }
  return sendContext;
}
function SendProvider({ children }) {
  var _a;
  const [selectedToken, setSelectedToken] = (0, import_react48.useState)(null);
  const [selectedInputType, setSelectedInputType] = (0, import_react48.useState)(
    "crypto"
  );
  const [fiatAmount, setFiatAmount] = (0, import_react48.useState)(null);
  const [cryptoAmount, setCryptoAmount] = (0, import_react48.useState)(null);
  const {
    recipientState,
    updateRecipientInput,
    validateRecipientInput,
    selectRecipient,
    deselectRecipient
  } = useRecipientState();
  const [lifecycleStatus, updateLifecycleStatus] = useLifecycleStatus({
    statusName: "init",
    statusData: {
      isMissingRequiredField: true
    }
  });
  const hasSufficientBalance = (0, import_react48.useMemo)(() => {
    if (!selectedToken) {
      return false;
    }
    if (selectedInputType === "fiat") {
      return Number(fiatAmount) <= selectedToken.fiatBalance;
    }
    return Number(cryptoAmount) <= Number(
      formatUnits(
        BigInt(selectedToken.cryptoBalance),
        selectedToken.decimals
      )
    );
  }, [selectedInputType, selectedToken, cryptoAmount, fiatAmount]);
  const { address } = useAccount();
  const { data: portfolioData } = usePortfolio(
    { address },
    RequestContext.Wallet
  );
  const ethHolding = (_a = portfolioData == null ? void 0 : portfolioData.tokenBalances) == null ? void 0 : _a.find(
    (token) => token.address === ""
  );
  const ethBalance = ethHolding ? Number(formatUnits(BigInt(ethHolding.cryptoBalance), ethHolding.decimals)) : 0;
  const isInitialized = ethBalance !== void 0;
  (0, import_react48.useEffect)(() => {
    if (!ethBalance || ethBalance === 0) {
      updateLifecycleStatus({
        statusName: "fundingWallet",
        statusData: {
          isMissingRequiredField: true
        }
      });
      return;
    }
    updateLifecycleStatus({
      statusName: "selectingAddress",
      statusData: {
        isMissingRequiredField: true
      }
    });
  }, [ethBalance, updateLifecycleStatus]);
  const { isLoading: exchangeRateLoading, data: exchangeRateData } = usePriceQuote(
    {
      token: (selectedToken == null ? void 0 : selectedToken.address) === "" ? "ETH" : selectedToken == null ? void 0 : selectedToken.address
    },
    RequestContext.Wallet
  );
  const exchangeRate = (0, import_react48.useMemo)(() => {
    if (!exchangeRateData || isApiError(exchangeRateData) || exchangeRateData.priceQuotes.length === 0) {
      return 0;
    }
    return 1 / Number(exchangeRateData.priceQuotes[0].price);
  }, [exchangeRateData]);
  const handleTokenSelection = (0, import_react48.useCallback)(
    (token) => {
      setSelectedToken(token);
      updateLifecycleStatus({
        statusName: "amountChange",
        statusData: {
          isMissingRequiredField: true,
          sufficientBalance: false
        }
      });
    },
    [updateLifecycleStatus]
  );
  const handleResetTokenSelection = (0, import_react48.useCallback)(() => {
    setSelectedToken(null);
    setFiatAmount(null);
    setCryptoAmount(null);
    updateLifecycleStatus({
      statusName: "selectingToken",
      statusData: {
        isMissingRequiredField: true
      }
    });
  }, [updateLifecycleStatus]);
  const handleFiatAmountChange = (0, import_react48.useCallback)(
    (value2) => {
      setFiatAmount(value2);
      updateLifecycleStatus({
        statusName: "amountChange",
        statusData: {
          isMissingRequiredField: true,
          sufficientBalance: hasSufficientBalance
        }
      });
    },
    [updateLifecycleStatus, hasSufficientBalance]
  );
  const handleCryptoAmountChange = (0, import_react48.useCallback)(
    (value2) => {
      const truncatedValue = truncateDecimalPlaces(value2, 8);
      setCryptoAmount(truncatedValue);
      updateLifecycleStatus({
        statusName: "amountChange",
        statusData: {
          isMissingRequiredField: true,
          sufficientBalance: hasSufficientBalance
        }
      });
    },
    [updateLifecycleStatus, hasSufficientBalance]
  );
  const value = useValue({
    isInitialized,
    lifecycleStatus,
    updateLifecycleStatus,
    ethBalance,
    recipientState,
    updateRecipientInput,
    validateRecipientInput,
    selectRecipient,
    deselectRecipient,
    selectedToken,
    handleTokenSelection,
    handleResetTokenSelection,
    fiatAmount,
    handleFiatAmountChange,
    cryptoAmount,
    handleCryptoAmountChange,
    exchangeRate,
    exchangeRateLoading,
    selectedInputType,
    setSelectedInputType
  });
  return (0, import_jsx_runtime75.jsx)(SendContext.Provider, { value, children });
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendAmountInputTypeSwitch.js
var defaultErrorDisplay = (0, import_jsx_runtime76.jsx)(
  "div",
  {
    "data-testid": "ockSendAmountInputTypeSwitch_ErrorDisplay",
    className: cn(text.caption, color.foregroundMuted, "h-[1.625rem]"),
    children: "Exchange rate unavailable"
  }
);
function SendAmountInputTypeSwitch({
  errorDisplay,
  className
}) {
  const {
    selectedToken,
    fiatAmount,
    cryptoAmount,
    exchangeRate,
    exchangeRateLoading,
    selectedInputType,
    setSelectedInputType
  } = useSendContext();
  if (exchangeRateLoading) {
    return (0, import_jsx_runtime76.jsx)(Skeleton, { className: "h-[1.625rem]" });
  }
  if (!exchangeRate) {
    if (errorDisplay) {
      return errorDisplay;
    }
    return defaultErrorDisplay;
  }
  return (0, import_jsx_runtime76.jsx)(
    AmountInputTypeSwitch,
    {
      asset: (selectedToken == null ? void 0 : selectedToken.symbol) ?? "",
      fiatAmount: fiatAmount ?? "",
      cryptoAmount: cryptoAmount ?? "",
      exchangeRate,
      exchangeRateLoading: false,
      currency: "USD",
      selectedInputType,
      setSelectedInputType,
      className
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendAmountInput.js
function SendAmountInput({
  className,
  textClassName
}) {
  const {
    selectedToken,
    cryptoAmount,
    handleCryptoAmountChange,
    fiatAmount,
    handleFiatAmountChange,
    selectedInputType,
    exchangeRate
  } = useSendContext();
  return (0, import_jsx_runtime77.jsxs)("div", { className: "flex h-full w-full flex-col justify-center", children: [
    (0, import_jsx_runtime77.jsx)(
      AmountInput,
      {
        fiatAmount: fiatAmount ?? "",
        cryptoAmount: cryptoAmount ?? "",
        asset: (selectedToken == null ? void 0 : selectedToken.symbol) ?? "",
        currency: "USD",
        selectedInputType,
        setFiatAmount: handleFiatAmountChange,
        setCryptoAmount: handleCryptoAmountChange,
        exchangeRate: String(exchangeRate),
        className,
        textClassName
      }
    ),
    (0, import_jsx_runtime77.jsx)(SendAmountInputTypeSwitch, {})
  ] });
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendButton.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var import_react49 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/utils/defaultSendTxSuccessHandler.js
function defaultSendTxSuccessHandler({
  transactionId,
  transactionHash,
  senderChain,
  address,
  onComplete
}) {
  return (receipt) => {
    const accountChainId = (senderChain == null ? void 0 : senderChain.id) ?? useChainId();
    if (receipt && transactionId && transactionHash && (senderChain == null ? void 0 : senderChain.id) && address) {
      const url = new URL("https://wallet.coinbase.com/assets/transactions");
      url.searchParams.set("contentParams[txHash]", transactionHash);
      url.searchParams.set(
        "contentParams[chainId]",
        JSON.stringify(senderChain == null ? void 0 : senderChain.id)
      );
      url.searchParams.set("contentParams[fromAddress]", address);
      window.open(url, "_blank", "noopener,noreferrer");
    } else {
      const chainExplorer = getChainExplorer(accountChainId);
      window.open(
        `${chainExplorer}/tx/${transactionHash}`,
        "_blank",
        "noopener,noreferrer"
      );
    }
    onComplete == null ? void 0 : onComplete();
  };
}

// node_modules/@coinbase/onchainkit/dist/api/buildSendTransaction.js
function buildSendTransaction({
  recipientAddress,
  tokenAddress,
  amount
}) {
  if (!tokenAddress) {
    return {
      to: recipientAddress,
      data: "0x",
      value: amount
    };
  }
  try {
    const transferCallData = encodeFunctionData({
      abi: erc20Abi,
      functionName: "transfer",
      args: [recipientAddress, amount]
    });
    return {
      to: tokenAddress,
      data: transferCallData
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      code: "AmBSeTx01",
      // Api Module Build Send Transaction Error 01
      error: message,
      message: "Could not build transfer transaction"
    };
  }
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/utils/getSendCalldata.js
function getSendCalldata({
  recipientAddress,
  token,
  amount
}) {
  if (!recipientAddress || !token || !token.decimals || !amount) {
    return {
      calldata: null,
      error: {
        code: "SemBSeTx01",
        error: "Invalid transaction parameters",
        message: "Could not build send transaction"
      }
    };
  }
  if (!token.address && token.symbol !== "ETH") {
    return {
      calldata: null,
      error: {
        code: "SemBSeTx02",
        error: "No token address provided for non-ETH token",
        message: "Could not build send transaction"
      }
    };
  }
  try {
    const parsedAmount = parseUnits(amount, token.decimals);
    const sendTransaction = buildSendTransaction({
      recipientAddress,
      tokenAddress: token.address || null,
      amount: parsedAmount
    });
    if (isApiError(sendTransaction)) {
      return {
        calldata: null,
        error: sendTransaction
      };
    }
    return {
      calldata: sendTransaction,
      error: null
    };
  } catch (err) {
    return {
      calldata: null,
      error: {
        code: "SemBSeTx03",
        error: err instanceof Error ? err.message : "Unknown error",
        message: "Could not build send transaction"
      }
    };
  }
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendButton.js
function SendButton() {
  const { chain: senderChain, isSponsored } = useWalletContext();
  const {
    recipientState,
    cryptoAmount: inputAmount,
    selectedToken,
    updateLifecycleStatus
  } = useSendContext();
  const { calldata, error } = getSendCalldata({
    recipientAddress: recipientState.address,
    token: selectedToken,
    amount: inputAmount
  });
  const disableSendButton = Boolean(error) || !validateAmountInput({
    inputAmount: inputAmount ?? "",
    balance: BigInt((selectedToken == null ? void 0 : selectedToken.cryptoBalance) ?? 0),
    selectedToken: selectedToken ?? void 0
  });
  const buttonLabel = getDefaultSendButtonLabel(inputAmount, selectedToken);
  const handleStatus = (0, import_react49.useCallback)(
    (status) => {
      const validStatuses = [
        "transactionPending",
        "transactionLegacyExecuted",
        "success",
        "error"
      ];
      if (validStatuses.includes(
        status.statusName
      )) {
        updateLifecycleStatus(
          status
        );
      }
    },
    [updateLifecycleStatus]
  );
  return (0, import_jsx_runtime78.jsxs)(
    Transaction,
    {
      isSponsored,
      chainId: (senderChain == null ? void 0 : senderChain.id) ?? base.id,
      calls: calldata ? [calldata] : [],
      onStatus: handleStatus,
      children: [
        (0, import_jsx_runtime78.jsx)(
          SendTransactionButton,
          {
            label: buttonLabel,
            senderChain,
            disabled: disableSendButton
          }
        ),
        (0, import_jsx_runtime78.jsxs)(TransactionStatus, { children: [
          (0, import_jsx_runtime78.jsx)(TransactionStatusLabel, {}),
          (0, import_jsx_runtime78.jsx)(TransactionStatusAction, {})
        ] })
      ]
    }
  );
}
function SendTransactionButton({
  label,
  senderChain,
  disabled
}) {
  const { address, setActiveFeature } = useWalletContext();
  const { transactionHash, transactionId } = useTransactionContext();
  const completionHandler = (0, import_react49.useCallback)(() => {
    setActiveFeature(null);
  }, [setActiveFeature]);
  const defaultSuccessOverride = {
    onClick: defaultSendTxSuccessHandler({
      transactionId,
      transactionHash,
      senderChain: senderChain ?? void 0,
      address: address ?? void 0,
      onComplete: completionHandler
    })
  };
  return (0, import_jsx_runtime78.jsx)(
    TransactionButton,
    {
      text: label,
      successOverride: defaultSuccessOverride,
      disabled
    }
  );
}
function getDefaultSendButtonLabel(cryptoAmount, selectedToken) {
  if (!cryptoAmount) {
    return "Input amount";
  }
  if (!selectedToken) {
    return "Select token";
  }
  if (parseUnits(cryptoAmount, selectedToken.decimals) > selectedToken.cryptoBalance) {
    return "Insufficient balance";
  }
  return "Continue";
}
function validateAmountInput({
  inputAmount,
  balance,
  selectedToken
}) {
  if (!inputAmount || !selectedToken || !balance) {
    return false;
  }
  const parsedCryptoAmount = parseUnits(inputAmount, selectedToken.decimals);
  return parsedCryptoAmount > 0n && parsedCryptoAmount <= balance;
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendFundWallet.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var import_react66 = __toESM(require_react(), 1);
var import_react_dom6 = __toESM(require_react_dom(), 1);

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCard.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/fund/hooks/useFundCardSetupOnrampEventListeners.js
var import_react54 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardProvider.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/fund/hooks/useEmitLifecycleStatus.js
var import_react50 = __toESM(require_react(), 1);
var useEmitLifecycleStatus = ({
  onError,
  onSuccess,
  onStatus
}) => {
  const [lifecycleStatus, updateLifecycleStatus] = useLifecycleStatus({
    statusName: "init",
    statusData: null
  });
  (0, import_react50.useEffect)(() => {
    if (lifecycleStatus.statusName === "error") {
      onError == null ? void 0 : onError(lifecycleStatus.statusData);
    }
    if (lifecycleStatus.statusName === "transactionSuccess") {
      onSuccess == null ? void 0 : onSuccess(lifecycleStatus.statusData);
    }
    onStatus == null ? void 0 : onStatus(lifecycleStatus);
  }, [
    onError,
    onStatus,
    onSuccess,
    lifecycleStatus,
    lifecycleStatus.statusData,
    lifecycleStatus.statusName
  ]);
  return (0, import_react50.useMemo)(
    () => ({ lifecycleStatus, updateLifecycleStatus }),
    [lifecycleStatus, updateLifecycleStatus]
  );
};

// node_modules/@coinbase/onchainkit/dist/fund/hooks/useOnrampExchangeRate.js
var import_react51 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/utils/convertSnakeToCamelCase.js
function convertSnakeToCamelCase(obj) {
  if (typeof obj === "string") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => convertSnakeToCamelCase(item));
  }
  if (obj && obj.constructor === Object) {
    return Object.keys(obj).reduce((acc, key) => {
      const camelCaseKey = toCamelCase(key);
      acc[camelCaseKey] = convertSnakeToCamelCase(obj[key]);
      return acc;
    }, {});
  }
  return obj;
}
function toCamelCase(str) {
  return str.replace(
    /_([a-z])/g,
    (_, letter) => letter.toUpperCase()
  );
}

// node_modules/@coinbase/onchainkit/dist/internal/utils/getApiKey.js
var getApiKey = () => {
  if (!ONCHAIN_KIT_CONFIG.apiKey) {
    throw new Error(
      "API Key Unset: Please set the API Key by providing it in the `OnchainKitProvider` or by manually calling `setOnchainKitConfig`. For more information, visit: https://portal.cdp.coinbase.com/products/onchainkit"
    );
  }
  return ONCHAIN_KIT_CONFIG.apiKey;
};

// node_modules/@coinbase/onchainkit/dist/fund/constants.js
var DEFAULT_ONRAMP_URL = "https://pay.coinbase.com";
var ONRAMP_BUY_URL = `${DEFAULT_ONRAMP_URL}/buy`;
var ONRAMP_POPUP_HEIGHT = 720;
var ONRAMP_POPUP_WIDTH = 460;
var ONRAMP_API_BASE_URL = "https://api.developer.coinbase.com/onramp/v1";
var FUND_BUTTON_RESET_TIMEOUT = 3e3;

// node_modules/@coinbase/onchainkit/dist/fund/utils/fetchOnrampQuote.js
async function fetchOnrampQuote({
  purchaseCurrency,
  purchaseNetwork,
  paymentCurrency,
  paymentMethod,
  paymentAmount,
  country,
  subdivision,
  apiKey
}) {
  const cpdApiKey = apiKey || getApiKey();
  const response = await fetch(`${ONRAMP_API_BASE_URL}/buy/quote`, {
    method: "POST",
    body: JSON.stringify({
      purchase_currency: purchaseCurrency,
      purchase_network: purchaseNetwork,
      payment_currency: paymentCurrency,
      payment_method: paymentMethod,
      payment_amount: paymentAmount,
      country,
      subdivision
    }),
    headers: {
      Authorization: `Bearer ${cpdApiKey}`
    }
  });
  const responseJson = await response.json();
  return convertSnakeToCamelCase(responseJson);
}

// node_modules/@coinbase/onchainkit/dist/fund/hooks/useOnrampExchangeRate.js
var useOnrampExchangeRate = ({
  asset,
  currency,
  country,
  subdivision,
  setExchangeRate,
  onError
}) => {
  const fetchExchangeRate = (0, import_react51.useCallback)(async () => {
    try {
      const quote = await fetchOnrampQuote({
        purchaseCurrency: asset,
        paymentCurrency: currency,
        paymentAmount: "100",
        paymentMethod: "CARD",
        country,
        subdivision
      });
      setExchangeRate(
        Number(quote.purchaseAmount.value) / Number(quote.paymentSubtotal.value)
      );
    } catch (err) {
      if (err instanceof Error) {
        console.error("Error fetching exchange rate:", err);
        onError == null ? void 0 : onError({
          errorType: "handled_error",
          code: "EXCHANGE_RATE_ERROR",
          debugMessage: err.message
        });
      } else {
        console.error("Unknown error fetching exchange rate:", err);
        onError == null ? void 0 : onError({
          errorType: "unknown_error",
          code: "EXCHANGE_RATE_ERROR",
          debugMessage: JSON.stringify(err)
        });
      }
    }
  }, [asset, country, subdivision, currency, onError, setExchangeRate]);
  return (0, import_react51.useMemo)(() => ({ fetchExchangeRate }), [fetchExchangeRate]);
};

// node_modules/@coinbase/onchainkit/dist/fund/hooks/usePaymentMethods.js
var import_react52 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/fund/utils/buildPaymentMethods.js
var DEFAULT_MIN_AMOUNT = 2;
var DEFAULT_MAX_AMOUNT = 500;
var buildCoinbasePaymentMethodDescription = (paymentMethodLimits) => {
  const availableMethods = [
    // Check API-provided methods
    paymentMethodLimits.some((limit) => limit.id === "ACH_BANK_ACCOUNT") && "ACH",
    paymentMethodLimits.some((limit) => limit.id === "CARD") && "debit",
    // Always include these methods
    "cash",
    "crypto balance"
  ].filter(Boolean);
  return availableMethods.join(", ");
};
var buildCoinbasePaymentMethod = ({
  limits
}) => ({
  id: "",
  name: "Coinbase",
  description: buildCoinbasePaymentMethodDescription(limits),
  icon: "coinbaseLogo",
  minAmount: Math.min(...limits.map((l) => Number(l.min))),
  maxAmount: Math.max(...limits.map((l) => Number(l.max)))
});
var buildUSPaymentMethods = (paymentCurrency) => {
  const paymentMethodConfigs = [
    {
      id: "APPLE_PAY",
      name: "Apple Pay",
      icon: "apple"
    },
    {
      id: "CARD",
      name: "Debit card",
      icon: "creditCard"
    }
  ];
  return paymentMethodConfigs.map((config) => {
    const limit = paymentCurrency.limits.find(
      (limit2) => limit2.id === config.id
    );
    return {
      ...config,
      description: "Up to $500/week. No sign up required.",
      minAmount: Number(limit == null ? void 0 : limit.min) || DEFAULT_MIN_AMOUNT,
      maxAmount: Number(limit == null ? void 0 : limit.max) || DEFAULT_MAX_AMOUNT
    };
  });
};
var buildPaymentMethods = (paymentOptions, currency, country) => {
  const paymentCurrency = paymentOptions.paymentCurrencies.find(
    (paymentCurrency2) => paymentCurrency2.id === currency
  );
  if (!paymentCurrency) {
    return [];
  }
  const coinbasePaymentMethod = buildCoinbasePaymentMethod(paymentCurrency);
  let usPaymentMethods = [];
  if (country === "US" && currency === "USD") {
    usPaymentMethods = buildUSPaymentMethods(paymentCurrency);
  }
  return [coinbasePaymentMethod, ...usPaymentMethods];
};

// node_modules/@coinbase/onchainkit/dist/fund/utils/fetchOnrampOptions.js
async function fetchOnrampOptions({
  country,
  subdivision,
  apiKey
}) {
  const cpdApiKey = apiKey || getApiKey();
  let queryParams = `?country=${country}`;
  if (subdivision) {
    queryParams = `${queryParams}&subdivision=${subdivision}`;
  }
  const response = await fetch(
    `${ONRAMP_API_BASE_URL}/buy/options${queryParams}`,
    {
      method: "GET",
      headers: {
        Authorization: `Bearer ${cpdApiKey}`
      }
    }
  );
  const responseJson = await response.json();
  return convertSnakeToCamelCase(responseJson);
}

// node_modules/@coinbase/onchainkit/dist/fund/hooks/usePaymentMethods.js
var usePaymentMethods = ({
  country,
  subdivision,
  currency,
  setPaymentMethods,
  setIsPaymentMethodsLoading,
  onError
}) => {
  const handleFetchPaymentMethods = (0, import_react52.useCallback)(async () => {
    setIsPaymentMethodsLoading(true);
    try {
      const paymentOptions = await fetchOnrampOptions({
        country,
        subdivision
      });
      const paymentMethods = buildPaymentMethods(
        paymentOptions,
        currency,
        country
      );
      if (paymentMethods.length === 0) {
        console.error(
          "No payment methods found for the selected country and currency. See docs for more information: https://docs.cdp.coinbase.com/onramp/docs/api-configurations"
        );
        onError == null ? void 0 : onError({
          errorType: "handled_error",
          code: "NO_PAYMENT_METHODS",
          debugMessage: "No payment methods found for the selected country and currency. See docs for more information: https://docs.cdp.coinbase.com/onramp/docs/api-configurations"
        });
      }
      setPaymentMethods(paymentMethods);
    } catch (error) {
      if (error instanceof Error) {
        console.error("Error fetching payment options:", error);
        onError == null ? void 0 : onError({
          errorType: "handled_error",
          code: "PAYMENT_METHODS_ERROR",
          debugMessage: error.message
        });
      }
    } finally {
      setIsPaymentMethodsLoading(false);
    }
  }, [
    country,
    subdivision,
    currency,
    setPaymentMethods,
    setIsPaymentMethodsLoading,
    onError
  ]);
  (0, import_react52.useEffect)(() => {
    handleFetchPaymentMethods();
  }, []);
};

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardProvider.js
var FundContext = (0, import_react53.createContext)(void 0);
function FundCardProvider({
  children,
  asset,
  currency = "USD",
  headerText = `Buy ${asset.toUpperCase()}`,
  buttonText,
  country,
  subdivision,
  inputType,
  onError,
  onStatus,
  onSuccess,
  presetAmountInputs
}) {
  const [selectedPaymentMethod, setSelectedPaymentMethod] = (0, import_react53.useState)();
  const [selectedInputType, setSelectedInputType] = (0, import_react53.useState)(
    inputType || "fiat"
  );
  const [fundAmountFiat, setFundAmountFiat] = (0, import_react53.useState)("");
  const [fundAmountCrypto, setFundAmountCrypto] = (0, import_react53.useState)("");
  const [exchangeRate, setExchangeRate] = (0, import_react53.useState)(0);
  const [exchangeRateLoading, setExchangeRateLoading] = (0, import_react53.useState)(true);
  const [submitButtonState, setSubmitButtonState] = (0, import_react53.useState)("default");
  const [paymentMethods, setPaymentMethods] = (0, import_react53.useState)([]);
  const [isPaymentMethodsLoading, setIsPaymentMethodsLoading] = (0, import_react53.useState)(true);
  const { lifecycleStatus, updateLifecycleStatus } = useEmitLifecycleStatus({
    onError,
    onSuccess,
    onStatus
  });
  const { fetchExchangeRate } = useOnrampExchangeRate({
    asset,
    currency,
    country,
    subdivision,
    setExchangeRate,
    onError
  });
  const { sendAnalytics } = useAnalytics();
  const handleAnalyticsAmountChanged = (0, import_react53.useCallback)(
    (amount, currency2) => {
      sendAnalytics(FundEvent.FundAmountChanged, {
        amount,
        currency: currency2
      });
    },
    [sendAnalytics]
  );
  const handleAnalyticsOptionSelected = (0, import_react53.useCallback)(
    (option) => {
      sendAnalytics(FundEvent.FundOptionSelected, {
        option
      });
    },
    [sendAnalytics]
  );
  const handleSetFundAmountFiat = (0, import_react53.useCallback)(
    (amount) => {
      const newAmount = Number.parseFloat(amount);
      if (!Number.isNaN(newAmount)) {
        handleAnalyticsAmountChanged(newAmount, currency);
      }
      setFundAmountFiat(amount);
    },
    [currency, handleAnalyticsAmountChanged]
  );
  const handleSetSelectedPaymentMethod = (0, import_react53.useCallback)(
    (paymentMethod) => {
      handleAnalyticsOptionSelected(paymentMethod.id);
      setSelectedPaymentMethod(paymentMethod);
    },
    [handleAnalyticsOptionSelected]
  );
  const handleFetchExchangeRate = (0, import_react53.useCallback)(async () => {
    setExchangeRateLoading(true);
    await fetchExchangeRate();
    setExchangeRateLoading(false);
  }, [fetchExchangeRate]);
  (0, import_react53.useEffect)(() => {
    handleFetchExchangeRate();
  }, []);
  usePaymentMethods({
    country,
    subdivision,
    currency,
    setPaymentMethods,
    setIsPaymentMethodsLoading,
    onError
  });
  const value = useValue({
    asset,
    currency,
    selectedPaymentMethod,
    setSelectedPaymentMethod: handleSetSelectedPaymentMethod,
    fundAmountFiat,
    setFundAmountFiat: handleSetFundAmountFiat,
    fundAmountCrypto,
    setFundAmountCrypto,
    selectedInputType,
    setSelectedInputType,
    exchangeRate,
    setExchangeRate,
    exchangeRateLoading,
    setExchangeRateLoading,
    submitButtonState,
    setSubmitButtonState,
    paymentMethods,
    setPaymentMethods,
    isPaymentMethodsLoading,
    setIsPaymentMethodsLoading,
    headerText,
    buttonText,
    country,
    subdivision,
    lifecycleStatus,
    updateLifecycleStatus,
    presetAmountInputs,
    onError
  });
  return (0, import_jsx_runtime79.jsx)(FundContext.Provider, { value, children });
}
function useFundContext() {
  const context = (0, import_react53.useContext)(FundContext);
  if (!context) {
    throw new Error("useFundContext must be used within a FundCardProvider");
  }
  return context;
}

// node_modules/@coinbase/onchainkit/dist/fund/utils/subscribeToWindowMessage.js
var MessageCodes = ((MessageCodes2) => {
  MessageCodes2["AppParams"] = "app_params";
  MessageCodes2["PaymentLinkSuccess"] = "payment_link_success";
  MessageCodes2["PaymentLinkClosed"] = "payment_link_closed";
  MessageCodes2["GuestCheckoutRedirectSuccess"] = "guest_checkout_redirect_success";
  MessageCodes2["Success"] = "success";
  MessageCodes2["Event"] = "event";
  return MessageCodes2;
})(MessageCodes || {});
function subscribeToWindowMessage({
  onMessage,
  allowedOrigin = DEFAULT_ONRAMP_URL,
  onValidateOrigin = () => Promise.resolve(true)
}) {
  const handleMessage = (event) => {
    if (!isAllowedOrigin({ event, allowedOrigin })) {
      return;
    }
    const { eventName, data } = JSON.parse(event.data);
    if (eventName === "event") {
      (async () => {
        if (await onValidateOrigin(event.origin)) {
          onMessage(data);
        }
      })();
    }
  };
  window.addEventListener("message", handleMessage);
  return () => {
    window.removeEventListener("message", handleMessage);
  };
}
function isAllowedOrigin({
  event,
  allowedOrigin
}) {
  const isOriginAllowed = !allowedOrigin || event.origin === allowedOrigin;
  return isOriginAllowed;
}

// node_modules/@coinbase/onchainkit/dist/fund/utils/setupOnrampEventListeners.js
function setupOnrampEventListeners({
  onEvent,
  onExit,
  onSuccess,
  host = DEFAULT_ONRAMP_URL
}) {
  const unsubscribe = subscribeToWindowMessage({
    allowedOrigin: host,
    onMessage: (data) => {
      const metadata = data;
      if (metadata.eventName === "success") {
        onSuccess == null ? void 0 : onSuccess(metadata.data);
      }
      if (metadata.eventName === "exit") {
        onExit == null ? void 0 : onExit(metadata.error);
      }
      onEvent == null ? void 0 : onEvent(metadata);
    }
  });
  return unsubscribe;
}

// node_modules/@coinbase/onchainkit/dist/fund/hooks/useFundCardSetupOnrampEventListeners.js
var useFundCardSetupOnrampEventListeners = () => {
  const { setSubmitButtonState, updateLifecycleStatus } = useFundContext();
  const handleOnrampEvent = (0, import_react54.useCallback)(
    (data) => {
      if (data.eventName === "transition_view") {
        updateLifecycleStatus({
          statusName: "transactionPending",
          statusData: void 0
        });
      } else if (data.eventName === "error") {
        updateLifecycleStatus({
          statusName: "error",
          statusData: data.error
        });
        setSubmitButtonState("error");
        setTimeout(() => {
          setSubmitButtonState("default");
        }, FUND_BUTTON_RESET_TIMEOUT);
      }
    },
    [updateLifecycleStatus, setSubmitButtonState]
  );
  const handleOnrampSuccess = (0, import_react54.useCallback)(
    (data) => {
      updateLifecycleStatus({
        statusName: "transactionSuccess",
        statusData: data
      });
      setSubmitButtonState("success");
      setTimeout(() => {
        setSubmitButtonState("default");
      }, FUND_BUTTON_RESET_TIMEOUT);
    },
    [updateLifecycleStatus, setSubmitButtonState]
  );
  const handleOnrampExit = (0, import_react54.useCallback)(() => {
    setSubmitButtonState("default");
    updateLifecycleStatus({
      statusName: "exit",
      statusData: void 0
    });
  }, [updateLifecycleStatus, setSubmitButtonState]);
  (0, import_react54.useEffect)(() => {
    const unsubscribe = setupOnrampEventListeners({
      onEvent: handleOnrampEvent,
      onExit: handleOnrampExit,
      onSuccess: handleOnrampSuccess
    });
    return () => {
      unsubscribe();
    };
  }, []);
};

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardAmountInput.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useThrottle.js
var import_react55 = __toESM(require_react(), 1);
var useThrottle = (callback, delay) => {
  const lastCallTime = (0, import_react55.useRef)(0);
  const timeoutRef = (0, import_react55.useRef)();
  const lastArgsRef = (0, import_react55.useRef)();
  const callbackRef = (0, import_react55.useRef)(callback);
  callbackRef.current = callback;
  (0, import_react55.useEffect)(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);
  return (0, import_react55.useCallback)(
    (...args) => {
      const now = Date.now();
      const timeSinceLastCall = now - lastCallTime.current;
      if (timeSinceLastCall >= delay) {
        callbackRef.current(...args);
        lastCallTime.current = now;
      } else if (timeoutRef.current) {
        lastArgsRef.current = args;
      } else if (!timeoutRef.current) {
        lastArgsRef.current = args;
        timeoutRef.current = setTimeout(() => {
          if (lastArgsRef.current) {
            callbackRef.current(...lastArgsRef.current);
            lastCallTime.current = Date.now();
          }
          timeoutRef.current = void 0;
        }, delay - timeSinceLastCall);
      }
    },
    [delay]
  );
};

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardAmountInput.js
var import_react56 = __toESM(require_react(), 1);
var THROTTLE_DELAY_MS = 5e3;
var FundCardAmountInput = ({
  className
}) => {
  const {
    fundAmountFiat,
    fundAmountCrypto,
    asset,
    selectedInputType,
    currency,
    exchangeRate,
    setFundAmountFiat,
    setFundAmountCrypto,
    country,
    subdivision,
    setExchangeRate,
    onError
  } = useFundContext();
  const { fetchExchangeRate } = useOnrampExchangeRate({
    asset,
    currency,
    country,
    subdivision,
    setExchangeRate,
    onError
  });
  const throttledFetchExchangeRate = useThrottle(
    fetchExchangeRate,
    THROTTLE_DELAY_MS
  );
  const { sendAnalytics } = useAnalytics();
  const handleFiatAmountChange = (0, import_react56.useCallback)(
    (amount) => {
      setFundAmountFiat(amount);
      throttledFetchExchangeRate();
      sendAnalytics(FundEvent.FundAmountChanged, {
        amount: Number(amount),
        currency
      });
    },
    [currency, sendAnalytics, setFundAmountFiat, throttledFetchExchangeRate]
  );
  return (0, import_jsx_runtime80.jsx)(
    AmountInput,
    {
      fiatAmount: fundAmountFiat,
      cryptoAmount: fundAmountCrypto,
      asset,
      selectedInputType,
      currency,
      className,
      setFiatAmount: handleFiatAmountChange,
      setCryptoAmount: setFundAmountCrypto,
      exchangeRate: String(exchangeRate)
    }
  );
};

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardAmountInputTypeSwitch.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var FundCardAmountInputTypeSwitch = ({
  className
}) => {
  const {
    selectedInputType,
    setSelectedInputType,
    asset,
    fundAmountFiat,
    fundAmountCrypto,
    exchangeRate,
    exchangeRateLoading,
    currency
  } = useFundContext();
  return (0, import_jsx_runtime81.jsx)(
    AmountInputTypeSwitch,
    {
      selectedInputType,
      setSelectedInputType,
      asset,
      fiatAmount: fundAmountFiat,
      cryptoAmount: fundAmountCrypto,
      exchangeRate,
      exchangeRateLoading,
      currency,
      className
    }
  );
};

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardHeader.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
function FundCardHeader({ className }) {
  const { headerText } = useFundContext();
  return (0, import_jsx_runtime82.jsx)(
    "div",
    {
      className: cn(text.headline, className),
      "data-testid": "ockFundCardHeader",
      children: headerText
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardPaymentMethodDropdown.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/buy/utils/isApplePaySupported.js
function isApplePaySupported() {
  return /iPhone|iPad|iPod/.test(navigator.userAgent) || /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);
}

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardPaymentMethodDropdown.js
var import_react59 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardPaymentMethodSelectRow.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var import_react57 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardPaymentMethodImage.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
function FundCardPaymentMethodImage({
  className,
  paymentMethod
}) {
  const { icon: icon2 } = paymentMethod;
  const iconSvg = useIcon({ icon: icon2 });
  return (0, import_jsx_runtime83.jsx)(
    "div",
    {
      "data-testid": "ockFundCardPaymentMethodImage__iconContainer",
      className: cn(
        "flex items-center justify-center overflow-hidden rounded-[50%]",
        className
      ),
      children: iconSvg
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardPaymentMethodSelectRow.js
var FundCardPaymentMethodSelectRow = (0, import_react57.memo)(
  ({
    paymentMethod,
    onClick,
    hideImage,
    hideDescription,
    disabled,
    disabledReason,
    testId
  }) => {
    const { sendAnalytics } = useAnalytics();
    const handleOnClick = (0, import_react57.useCallback)(() => {
      if (!disabled) {
        onClick == null ? void 0 : onClick(paymentMethod);
        sendAnalytics(FundEvent.FundOptionSelected, {
          option: paymentMethod.id
        });
      }
    }, [disabled, onClick, paymentMethod, sendAnalytics]);
    return (0, import_jsx_runtime84.jsx)(
      "button",
      {
        "data-testid": testId,
        type: "button",
        className: cn(
          pressable.default,
          border.radius,
          background.default,
          "flex w-full items-center justify-between px-4 py-2",
          {
            [pressable.disabled]: disabled
          }
        ),
        onClick: handleOnClick,
        disabled,
        title: disabledReason,
        children: (0, import_jsx_runtime84.jsxs)("span", { className: "flex items-center gap-3", children: [
          !hideImage && (0, import_jsx_runtime84.jsx)(
            FundCardPaymentMethodImage,
            {
              paymentMethod,
              className: cn("h-4 w-4", {
                [pressable.disabled]: disabled
              })
            }
          ),
          (0, import_jsx_runtime84.jsxs)("span", { className: "flex flex-col items-start", children: [
            (0, import_jsx_runtime84.jsx)("span", { className: cn(text.headline), children: paymentMethod.name }),
            !hideDescription && (0, import_jsx_runtime84.jsx)(
              "span",
              {
                className: cn(
                  text.label2,
                  color.foregroundMuted,
                  "font-normal"
                ),
                children: disabledReason || paymentMethod.description
              }
            )
          ] })
        ] })
      }
    );
  }
);
FundCardPaymentMethodSelectRow.displayName = "FundCardPaymentMethodSelectRow";

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardPaymentMethodSelectorToggle.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var import_react58 = __toESM(require_react(), 1);
var FundCardPaymentMethodSelectorToggle = (0, import_react58.forwardRef)(
  ({
    onClick,
    paymentMethod,
    isOpen,
    className
  }, ref) => {
    return (0, import_jsx_runtime85.jsxs)(
      "button",
      {
        type: "button",
        className: cn(
          pressable.default,
          border.radius,
          border.lineDefault,
          "flex h-12 w-full items-center gap-2 px-3 py-1",
          className
        ),
        onClick,
        ref,
        "data-testid": "ockFundCardPaymentMethodSelectorToggle",
        children: [
          (0, import_jsx_runtime85.jsx)("div", { className: "w-4", children: (0, import_jsx_runtime85.jsx)(
            FundCardPaymentMethodImage,
            {
              paymentMethod,
              className: "h-4 w-4"
            }
          ) }),
          (0, import_jsx_runtime85.jsx)(
            "span",
            {
              className: cn(text.headline, color.foreground, "flex w-full"),
              "data-testid": "ockFundCardPaymentMethodSelectorToggle__paymentMethodName",
              children: paymentMethod.name
            }
          ),
          (0, import_jsx_runtime85.jsx)(
            "span",
            {
              className: cn(
                "rotate-90 transition-transform duration-200",
                isOpen && "rotate-180"
              ),
              children: caretUpSvg
            }
          )
        ]
      }
    );
  }
);
FundCardPaymentMethodSelectorToggle.displayName = "FundCardPaymentMethodSelectorToggle";

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardPaymentMethodDropdown.js
function FundCardPaymentMethodDropdown({
  className
}) {
  const [isOpen, setIsOpen] = (0, import_react59.useState)(false);
  const {
    selectedPaymentMethod,
    setSelectedPaymentMethod,
    paymentMethods,
    fundAmountFiat,
    isPaymentMethodsLoading,
    currency
  } = useFundContext();
  const { sendAnalytics } = useAnalytics();
  const filteredPaymentMethods = (0, import_react59.useMemo)(() => {
    return paymentMethods.filter(
      (method) => method.id !== "APPLE_PAY" || isApplePaySupported()
    );
  }, [paymentMethods]);
  const getPaymentMethodDisabledReason = (0, import_react59.useCallback)(
    (method) => {
      const amount = Number(fundAmountFiat);
      if (method.minAmount && amount < method.minAmount) {
        return `Minimum amount of ${formatFiatAmount({
          amount: method.minAmount,
          currency,
          minimumFractionDigits: 0
        })} required`;
      }
      if (method.maxAmount && amount > method.maxAmount) {
        return `Maximum amount allowed is ${formatFiatAmount({
          amount: method.maxAmount,
          currency,
          minimumFractionDigits: 0
        })}`;
      }
      return void 0;
    },
    [fundAmountFiat, currency]
  );
  const isPaymentMethodDisabled = (0, import_react59.useCallback)(
    (method) => {
      if (!fundAmountFiat) {
        return false;
      }
      return Boolean(getPaymentMethodDisabledReason(method));
    },
    [fundAmountFiat, getPaymentMethodDisabledReason]
  );
  (0, import_react59.useEffect)(() => {
    if (selectedPaymentMethod && isPaymentMethodDisabled(selectedPaymentMethod)) {
      const coinbaseMethod = paymentMethods.find((m) => m.id === "");
      if (coinbaseMethod) {
        setSelectedPaymentMethod(coinbaseMethod);
      }
    }
  }, [
    selectedPaymentMethod,
    paymentMethods,
    setSelectedPaymentMethod,
    isPaymentMethodDisabled
  ]);
  const handlePaymentMethodSelect = (0, import_react59.useCallback)(
    (paymentMethod2) => {
      if (!isPaymentMethodDisabled(paymentMethod2)) {
        sendAnalytics(FundEvent.FundOptionSelected, {
          option: paymentMethod2.id
        });
        setSelectedPaymentMethod(paymentMethod2);
        setIsOpen(false);
      }
    },
    [setSelectedPaymentMethod, isPaymentMethodDisabled, sendAnalytics]
  );
  const handleToggle = (0, import_react59.useCallback)(() => {
    setIsOpen(!isOpen);
  }, [isOpen]);
  const dropdownRef = (0, import_react59.useRef)(null);
  const dropdownContainerRef = (0, import_react59.useRef)(null);
  const buttonRef = (0, import_react59.useRef)(null);
  useOutsideClick(dropdownContainerRef, () => {
    if (isOpen) {
      setIsOpen(false);
    }
  });
  const handleEscKeyPress = (0, import_react59.useCallback)(
    (event) => {
      if (event.key === "Escape") {
        setIsOpen(false);
      }
    },
    []
  );
  const paymentMethod = selectedPaymentMethod || filteredPaymentMethods[0];
  return (0, import_jsx_runtime86.jsxs)(
    "div",
    {
      className: cn("relative py-4", className),
      ref: dropdownContainerRef,
      "data-testid": "ockFundCardPaymentMethodDropdownContainer",
      onKeyUp: handleEscKeyPress,
      children: [
        isPaymentMethodsLoading || !paymentMethod ? (0, import_jsx_runtime86.jsx)(Skeleton, { className: "h-12 w-full" }) : (0, import_jsx_runtime86.jsx)(
          FundCardPaymentMethodSelectorToggle,
          {
            ref: buttonRef,
            onClick: handleToggle,
            isOpen,
            paymentMethod
          }
        ),
        isOpen && (0, import_jsx_runtime86.jsx)(
          "div",
          {
            ref: dropdownRef,
            "data-testid": "ockFundCardPaymentMethodDropdown",
            className: cn(
              border.radius,
              border.lineDefault,
              "ock-scrollbar absolute z-10 mt-2 flex w-full flex-col overflow-y-hidden"
            ),
            children: (0, import_jsx_runtime86.jsx)("div", { className: cn(background.default, "overflow-y-auto p-2"), children: filteredPaymentMethods.map((paymentMethod2) => {
              const isDisabled = isPaymentMethodDisabled(paymentMethod2);
              return (0, import_jsx_runtime86.jsx)(
                FundCardPaymentMethodSelectRow,
                {
                  testId: `ockFundCardPaymentMethodSelectRow__${paymentMethod2.id}`,
                  paymentMethod: paymentMethod2,
                  onClick: handlePaymentMethodSelect,
                  disabled: isDisabled,
                  disabledReason: getPaymentMethodDisabledReason(paymentMethod2)
                },
                paymentMethod2.name
              );
            }) })
          }
        )
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardPresetAmountInputList.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardPresetAmountInputItem.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var import_react60 = __toESM(require_react(), 1);
function FundCardPresetAmountInputItem({
  presetAmountInput,
  currency,
  onClick
}) {
  const { sendAnalytics } = useAnalytics();
  const presetAmountInputText = (0, import_react60.useMemo)(() => {
    return formatFiatAmount({
      amount: presetAmountInput,
      currency,
      minimumFractionDigits: 0
    });
  }, [presetAmountInput, currency]);
  const handleClick = (0, import_react60.useCallback)(() => {
    sendAnalytics(FundEvent.FundAmountChanged, {
      amount: Number(presetAmountInput),
      currency
    });
    onClick(presetAmountInput);
  }, [presetAmountInput, currency, onClick, sendAnalytics]);
  const handleKeyPress = (0, import_react60.useCallback)(
    (event) => {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        sendAnalytics(FundEvent.FundAmountChanged, {
          amount: Number(presetAmountInput),
          currency
        });
        onClick(presetAmountInput);
      }
    },
    [presetAmountInput, currency, onClick, sendAnalytics]
  );
  if (!presetAmountInput) {
    return null;
  }
  return (0, import_jsx_runtime87.jsx)(
    "button",
    {
      type: "button",
      "data-testid": "ockPresetAmountInput",
      className: cn(
        text.body,
        color.foreground,
        border.radius,
        border.lineDefault,
        "flex-1",
        "p-1",
        "overflow-hidden",
        "whitespace-nowrap",
        "text-ellipsis",
        "hover:bg-[var(--ock-bg-default-hover)]",
        "focus:outline-none focus:ring-2"
      ),
      title: presetAmountInputText,
      onClick: handleClick,
      onKeyDown: handleKeyPress,
      children: presetAmountInputText
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardPresetAmountInputList.js
function FundCardPresetAmountInputList() {
  const {
    presetAmountInputs,
    currency,
    selectedInputType,
    exchangeRate,
    setFundAmountFiat,
    setFundAmountCrypto
  } = useFundContext();
  const { handleFiatChange } = useAmountInput({
    setFiatAmount: setFundAmountFiat,
    setCryptoAmount: setFundAmountCrypto,
    selectedInputType,
    exchangeRate: String(exchangeRate)
  });
  if (!presetAmountInputs) {
    return null;
  }
  return (0, import_jsx_runtime88.jsx)(
    "div",
    {
      "data-testid": "ockPresetAmountInputList",
      className: "flex w-full flex-wrap items-center justify-between gap-2 pt-8",
      children: presetAmountInputs.map((amount, index) => (0, import_jsx_runtime88.jsx)(
        FundCardPresetAmountInputItem,
        {
          presetAmountInput: amount,
          onClick: handleFiatChange,
          currency
        },
        index
      ))
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardSubmitButton.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/fund/hooks/useFundCardFundingUrl.js
var import_react61 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/fund/utils/getOnrampBuyUrl.js
function getOnrampBuyUrl({
  projectId,
  originComponentName,
  ...props
}) {
  const url = new URL(ONRAMP_BUY_URL);
  if (projectId !== void 0) {
    url.searchParams.append("appId", projectId);
  }
  for (const key of Object.keys(props)) {
    const value = props[key];
    if (value !== void 0) {
      if (["string", "number", "boolean"].includes(typeof value)) {
        url.searchParams.append(key, value.toString());
      } else {
        url.searchParams.append(key, JSON.stringify(value));
      }
    }
  }
  if (originComponentName) {
    url.searchParams.append(
      "sdkVersion",
      `onchainkit@${version}:${originComponentName}`
    );
  } else {
    url.searchParams.append("sdkVersion", `onchainkit@${version}`);
  }
  url.searchParams.sort();
  return url.toString();
}

// node_modules/@coinbase/onchainkit/dist/fund/hooks/useFundCardFundingUrl.js
var useFundCardFundingUrl = () => {
  const { projectId, chain: defaultChain } = useOnchainKit();
  const { address, chain: accountChain } = useAccount();
  const {
    selectedPaymentMethod,
    selectedInputType,
    fundAmountFiat,
    fundAmountCrypto,
    asset,
    currency
  } = useFundContext();
  const chain = accountChain || defaultChain;
  return (0, import_react61.useMemo)(() => {
    if (projectId === null || address === void 0) {
      return void 0;
    }
    const fundAmount = selectedInputType === "fiat" ? fundAmountFiat : fundAmountCrypto;
    return getOnrampBuyUrl({
      projectId,
      assets: [asset],
      presetFiatAmount: selectedInputType === "fiat" ? Number(fundAmount) : void 0,
      presetCryptoAmount: selectedInputType === "crypto" ? Number(fundAmount) : void 0,
      defaultPaymentMethod: selectedPaymentMethod == null ? void 0 : selectedPaymentMethod.id,
      addresses: { [address]: [chain.name.toLowerCase()] },
      fiatCurrency: currency,
      originComponentName: "FundCard"
    });
  }, [
    asset,
    fundAmountFiat,
    fundAmountCrypto,
    selectedPaymentMethod,
    selectedInputType,
    projectId,
    address,
    chain,
    currency
  ]);
};

// node_modules/@coinbase/onchainkit/dist/fund/components/FundButton.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var import_react64 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/buy/hooks/usePopupMonitor.js
var import_react62 = __toESM(require_react(), 1);
var usePopupMonitor = (onClose) => {
  const intervalRef = (0, import_react62.useRef)(null);
  const startPopupMonitor = (0, import_react62.useCallback)(
    (popupWindow) => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
      intervalRef.current = window.setInterval(() => {
        if (popupWindow.closed) {
          if (intervalRef.current) {
            clearInterval(intervalRef.current);
            intervalRef.current = null;
          }
          onClose == null ? void 0 : onClose();
        }
      }, 500);
    },
    [onClose]
  );
  const stopPopupMonitor = (0, import_react62.useCallback)(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);
  (0, import_react62.useEffect)(() => {
    return () => stopPopupMonitor();
  }, [stopPopupMonitor]);
  return { startPopupMonitor, stopPopupMonitor };
};

// node_modules/@coinbase/onchainkit/dist/internal/utils/openPopup.js
function openPopup({ url, target, height, width }) {
  const left = Math.round((window.screen.width - width) / 2);
  const top = Math.round((window.screen.height - height) / 2);
  const windowFeatures = `width=${width},height=${height},resizable,scrollbars=yes,status=1,left=${left},top=${top}`;
  return window.open(url, target, windowFeatures);
}

// node_modules/@coinbase/onchainkit/dist/internal/svg/addSvg.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var AddSvg = ({ className = cn(icon.inverse) }) => (0, import_jsx_runtime89.jsxs)(
  "svg",
  {
    "data-testid": "ock-addSvg",
    role: "img",
    "aria-label": "ock-addSvg",
    width: "13",
    height: "12",
    viewBox: "0 0 13 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime89.jsx)("title", { children: "Add" }),
      (0, import_jsx_runtime89.jsx)(
        "path",
        {
          d: "M7.125 0H5.875V5.37501L0.5 5.37501L0.5 6.62501H5.875V12H7.125V6.62501H12.5V5.37501H7.125V0Z",
          className
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/fund/hooks/useGetFundingUrl.js
var import_react63 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/hooks/useIsWalletACoinbaseSmartWallet.js
var COINBASE_WALLET_SDK_CONNECTOR_ID = "coinbaseWalletSDK";
function useIsWalletACoinbaseSmartWallet() {
  var _a;
  const { chain } = useOnchainKit();
  const { connector } = useAccount();
  const walletCapabilities = useCapabilitiesSafe({
    chainId: chain.id
  });
  return (connector == null ? void 0 : connector.id) === COINBASE_WALLET_SDK_CONNECTOR_ID && ((_a = walletCapabilities.atomicBatch) == null ? void 0 : _a.supported) === true;
}

// node_modules/@coinbase/onchainkit/dist/fund/utils/getCoinbaseSmartWalletFundUrl.js
var COINBASE_SMART_WALLET_FUND_URL = "https://keys.coinbase.com/fund";
function getCoinbaseSmartWalletFundUrl() {
  const currentURL = window.location.href;
  const tabName = document.title;
  const fundUrl = `${COINBASE_SMART_WALLET_FUND_URL}?dappName=${encodeURIComponent(
    tabName
  )}&dappUrl=${encodeURIComponent(currentURL)}&version=${encodeURIComponent(
    version
  )}&source=onchainkit`;
  return fundUrl;
}

// node_modules/@coinbase/onchainkit/dist/fund/hooks/useGetFundingUrl.js
function useGetFundingUrl({
  fiatCurrency,
  originComponentName
}) {
  const { projectId, chain: defaultChain } = useOnchainKit();
  const { address, chain: accountChain } = useAccount();
  const isCoinbaseSmartWallet = useIsWalletACoinbaseSmartWallet();
  const chain = accountChain || defaultChain;
  return (0, import_react63.useMemo)(() => {
    if (isCoinbaseSmartWallet) {
      return getCoinbaseSmartWalletFundUrl();
    }
    if (projectId === null || address === void 0) {
      return void 0;
    }
    return getOnrampBuyUrl({
      projectId,
      addresses: { [address]: [chain.name.toLowerCase()] },
      fiatCurrency,
      originComponentName
    });
  }, [
    isCoinbaseSmartWallet,
    projectId,
    address,
    chain,
    fiatCurrency,
    originComponentName
  ]);
}

// node_modules/@coinbase/onchainkit/dist/internal/utils/getWindowDimensions.js
var popupSizes = {
  sm: { width: "24.67vw", height: "30.83vw" },
  md: { width: "29vw", height: "36.25vw" },
  lg: { width: "35vw", height: "43.75vw" }
};
var getWindowDimensions = (size) => {
  const { width, height } = popupSizes[size];
  const minWidth = 280;
  const minHeight = 350;
  const vwToPx = (vw) => vw / 100 * window.innerWidth;
  const widthPx = Math.max(
    minWidth,
    Math.round(vwToPx(Number.parseFloat(width)))
  );
  const heightPx = Math.max(
    minHeight,
    Math.round(vwToPx(Number.parseFloat(height)))
  );
  const maxWidth = Math.round(window.innerWidth * 0.9);
  const maxHeight = Math.round(window.innerHeight * 0.9);
  const adjustedWidthPx = Math.min(widthPx, maxWidth);
  const adjustedHeightPx = Math.min(heightPx, maxHeight);
  return { width: adjustedWidthPx, height: adjustedHeightPx };
};

// node_modules/@coinbase/onchainkit/dist/fund/utils/getFundingPopupSize.js
function getFundingPopupSize(size, fundingUrl) {
  if (fundingUrl == null ? void 0 : fundingUrl.includes(ONRAMP_BUY_URL)) {
    return {
      height: ONRAMP_POPUP_HEIGHT,
      width: ONRAMP_POPUP_WIDTH
    };
  }
  return getWindowDimensions(size);
}

// node_modules/@coinbase/onchainkit/dist/fund/components/FundButton.js
function FundButton({
  className,
  disabled = false,
  fundingUrl,
  hideIcon = false,
  hideText = false,
  openIn = "popup",
  popupSize = "md",
  rel,
  target,
  text: buttonText = "Fund",
  successText: buttonSuccessText = "Success",
  errorText: buttonErrorText = "Something went wrong",
  state: buttonState = "default",
  fiatCurrency = "USD",
  onPopupClose,
  onClick
}) {
  const componentTheme = useTheme();
  const fallbackFundingUrl = useGetFundingUrl({
    fiatCurrency,
    originComponentName: "FundButton"
  });
  const { address } = useAccount();
  const fundingUrlToRender = fundingUrl ?? fallbackFundingUrl;
  const isDisabled = disabled || !fundingUrlToRender;
  const shouldShowConnectWallet = !address;
  const { startPopupMonitor } = usePopupMonitor(onPopupClose);
  const { sendAnalytics } = useAnalytics();
  const handleAnalyticsInitiated = (0, import_react64.useCallback)(() => {
    sendAnalytics(FundEvent.FundInitiated, {
      currency: fiatCurrency
    });
  }, [sendAnalytics, fiatCurrency]);
  const handleAnalyticsFailure = (0, import_react64.useCallback)(
    (error) => {
      sendAnalytics(FundEvent.FundFailure, {
        error,
        metadata: { currency: fiatCurrency }
      });
    },
    [sendAnalytics, fiatCurrency]
  );
  const handleClick = (0, import_react64.useCallback)(
    (e) => {
      e.preventDefault();
      if (fundingUrlToRender) {
        handleAnalyticsInitiated();
        onClick == null ? void 0 : onClick();
        const { height, width } = getFundingPopupSize(
          popupSize,
          fundingUrlToRender
        );
        const popupWindow = openPopup({
          url: fundingUrlToRender,
          height,
          width,
          target
        });
        if (popupWindow) {
          startPopupMonitor(popupWindow);
        } else {
          handleAnalyticsFailure("Failed to open funding popup");
        }
      }
    },
    [
      fundingUrlToRender,
      popupSize,
      target,
      onClick,
      startPopupMonitor,
      handleAnalyticsInitiated,
      handleAnalyticsFailure
    ]
  );
  const buttonColorClass = (0, import_react64.useMemo)(() => {
    if (buttonState === "error") {
      return background.error;
    }
    return pressable.primary;
  }, [buttonState]);
  const classNames = cn(
    componentTheme,
    buttonColorClass,
    "px-4 py-3 inline-flex items-center justify-center space-x-2",
    {
      [pressable.disabled]: isDisabled
    },
    text.headline,
    border.radius,
    color.inverse,
    className
  );
  const buttonIcon = (0, import_react64.useMemo)(() => {
    if (hideIcon) {
      return null;
    }
    switch (buttonState) {
      case "loading":
        return "";
      case "success":
        return (0, import_jsx_runtime90.jsx)(SuccessSvg, { fill: "#F9FAFB" });
      case "error":
        return (0, import_jsx_runtime90.jsx)(ErrorSvg, { fill: "#F9FAFB" });
      default:
        return (0, import_jsx_runtime90.jsx)(AddSvg, {});
    }
  }, [buttonState, hideIcon]);
  const buttonTextContent = (0, import_react64.useMemo)(() => {
    switch (buttonState) {
      case "loading":
        return "";
      case "success":
        return buttonSuccessText;
      case "error":
        return buttonErrorText;
      default:
        return buttonText;
    }
  }, [buttonState, buttonSuccessText, buttonErrorText, buttonText]);
  const buttonContent = (0, import_react64.useMemo)(() => {
    if (buttonState === "loading") {
      return (0, import_jsx_runtime90.jsx)(Spinner, {});
    }
    return (0, import_jsx_runtime90.jsxs)(import_jsx_runtime90.Fragment, { children: [
      buttonIcon && (0, import_jsx_runtime90.jsx)(
        "span",
        {
          "data-testid": "ockFundButtonIcon",
          className: "flex h-6 items-center",
          children: buttonIcon
        }
      ),
      hideText || (0, import_jsx_runtime90.jsx)("span", { "data-testid": "ockFundButtonTextContent", children: buttonTextContent })
    ] });
  }, [buttonState, buttonIcon, buttonTextContent, hideText]);
  if (openIn === "tab") {
    return (0, import_jsx_runtime90.jsx)(
      "a",
      {
        className: classNames,
        href: fundingUrlToRender,
        target: target ?? "_blank",
        rel,
        children: buttonContent
      }
    );
  }
  if (shouldShowConnectWallet) {
    return (0, import_jsx_runtime90.jsx)(ConnectWallet, { className: cn("w-full", className) });
  }
  return (0, import_jsx_runtime90.jsx)(
    "button",
    {
      className: classNames,
      onClick: handleClick,
      type: "button",
      disabled: isDisabled,
      "data-testid": "ockFundButton",
      children: buttonContent
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCardSubmitButton.js
function FundCardSubmitButton() {
  const {
    fundAmountFiat,
    fundAmountCrypto,
    submitButtonState,
    setSubmitButtonState,
    buttonText,
    currency,
    updateLifecycleStatus
  } = useFundContext();
  const fundingUrl = useFundCardFundingUrl();
  const handleOnClick = (0, import_react65.useCallback)(
    () => setSubmitButtonState("loading"),
    [setSubmitButtonState]
  );
  const handleOnPopupClose = (0, import_react65.useCallback)(() => {
    updateLifecycleStatus({ statusName: "exit", statusData: void 0 });
    setSubmitButtonState("default");
  }, [updateLifecycleStatus, setSubmitButtonState]);
  const isButtonDisabled = (0, import_react65.useMemo)(
    () => (!fundAmountFiat || Number(fundAmountCrypto) === 0) && (!fundAmountCrypto || Number(fundAmountFiat) === 0),
    [fundAmountCrypto, fundAmountFiat]
  );
  return (0, import_jsx_runtime91.jsx)(
    FundButton,
    {
      disabled: isButtonDisabled,
      hideIcon: submitButtonState === "default",
      text: buttonText,
      className: "w-full",
      fundingUrl,
      state: submitButtonState,
      onClick: handleOnClick,
      onPopupClose: handleOnPopupClose,
      fiatCurrency: currency
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/fund/components/FundCard.js
function FundCard({
  assetSymbol,
  buttonText = "Buy",
  headerText,
  country = "US",
  subdivision,
  currency = "USD",
  presetAmountInputs,
  children = (0, import_jsx_runtime92.jsx)(DefaultFundCardContent, {}),
  className,
  onError,
  onStatus,
  onSuccess
}) {
  const componentTheme = useTheme();
  return (0, import_jsx_runtime92.jsx)(
    FundCardProvider,
    {
      asset: assetSymbol,
      headerText,
      buttonText,
      country,
      subdivision,
      currency,
      onError,
      onStatus,
      onSuccess,
      presetAmountInputs,
      children: (0, import_jsx_runtime92.jsx)(
        "div",
        {
          className: cn(
            componentTheme,
            background.default,
            color.foreground,
            "flex w-full flex-col p-6",
            text.headline,
            border.radius,
            border.lineDefault,
            className
          ),
          children: (0, import_jsx_runtime92.jsx)(FundCardContent, { children })
        }
      )
    }
  );
}
function FundCardContent({ children }) {
  useFundCardSetupOnrampEventListeners();
  return (0, import_jsx_runtime92.jsx)("form", { className: "w-full", "data-testid": "ockFundCardForm", children });
}
function DefaultFundCardContent() {
  return (0, import_jsx_runtime92.jsxs)(import_jsx_runtime92.Fragment, { children: [
    (0, import_jsx_runtime92.jsx)(FundCardHeader, {}),
    (0, import_jsx_runtime92.jsx)(FundCardAmountInput, {}),
    (0, import_jsx_runtime92.jsx)(FundCardAmountInputTypeSwitch, {}),
    (0, import_jsx_runtime92.jsx)(FundCardPresetAmountInputList, {}),
    (0, import_jsx_runtime92.jsx)(FundCardPaymentMethodDropdown, {}),
    (0, import_jsx_runtime92.jsx)(FundCardSubmitButton, {})
  ] });
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendFundWallet.js
function SendFundWallet({
  onError,
  onStatus,
  onSuccess,
  classNames
}) {
  return (0, import_jsx_runtime93.jsxs)(
    "div",
    {
      className: cn(
        "flex flex-col items-center justify-between",
        classNames == null ? void 0 : classNames.container
      ),
      "data-testid": "ockSendFundWallet",
      children: [
        (0, import_jsx_runtime93.jsx)(
          "div",
          {
            className: cn(text.label2, color.foregroundMuted, classNames == null ? void 0 : classNames.subtitle),
            children: "Insufficient ETH balance to send transaction. Fund your wallet to continue."
          }
        ),
        (0, import_jsx_runtime93.jsxs)(
          FundCard,
          {
            assetSymbol: "ETH",
            country: "US",
            currency: "USD",
            presetAmountInputs: ["2", "5", "10"],
            onError,
            onStatus,
            onSuccess,
            className: cn("mt-3 w-88 border-none py-0", classNames == null ? void 0 : classNames.fundCard),
            children: [
              (0, import_jsx_runtime93.jsx)(FundCardAmountInput, {}),
              (0, import_jsx_runtime93.jsx)(FundCardAmountInputTypeSwitch, {}),
              (0, import_jsx_runtime93.jsx)(FundCardPresetAmountInputList, {}),
              (0, import_jsx_runtime93.jsx)(FundCardPaymentMethodDropdown, {}),
              (0, import_jsx_runtime93.jsx)(FundCardSubmitButton, {})
            ]
          }
        )
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendHeader.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var import_react67 = __toESM(require_react(), 1);
function SendHeader({ label = "Send", classNames }) {
  const { setActiveFeature } = useWalletContext();
  const {
    recipientState,
    selectedToken,
    handleResetTokenSelection,
    deselectRecipient
  } = useSendContext();
  const handleBack = (0, import_react67.useCallback)(() => {
    if (selectedToken) {
      handleResetTokenSelection();
    } else if (recipientState.address) {
      deselectRecipient();
    }
  }, [
    recipientState.address,
    selectedToken,
    handleResetTokenSelection,
    deselectRecipient
  ]);
  const handleClose = (0, import_react67.useCallback)(() => {
    setActiveFeature(null);
  }, [setActiveFeature]);
  return (0, import_jsx_runtime94.jsxs)(
    "div",
    {
      "data-testid": "ockSendHeader",
      className: cn(
        "mb-4 grid grid-cols-3 items-center",
        classNames == null ? void 0 : classNames.container
      ),
      children: [
        (0, import_jsx_runtime94.jsx)("div", { "data-testid": "ockSendHeader_back", className: "justify-self-start", children: recipientState.phase === "selected" && (0, import_jsx_runtime94.jsx)(
          PressableIcon,
          {
            onClick: handleBack,
            className: cn("h-7 w-7 scale-110 p-2", classNames == null ? void 0 : classNames.back),
            children: backArrowSvg
          }
        ) }),
        (0, import_jsx_runtime94.jsx)(
          "div",
          {
            "data-testid": "ockSendHeader_label",
            className: cn(text.headline, "justify-self-center", classNames == null ? void 0 : classNames.label),
            children: label
          }
        ),
        (0, import_jsx_runtime94.jsx)("div", { "data-testid": "ockSendHeader_close", className: "justify-self-end", children: (0, import_jsx_runtime94.jsx)(
          PressableIcon,
          {
            onClick: handleClose,
            className: cn("h-7 w-7 scale-110 p-2", classNames == null ? void 0 : classNames.close),
            children: (0, import_jsx_runtime94.jsx)(CloseSvg, {})
          }
        ) })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendTokenSelector.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_react69 = __toESM(require_react(), 1);
var import_react_dom7 = __toESM(require_react_dom(), 1);

// node_modules/@coinbase/onchainkit/dist/token/components/TokenBalance.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_react68 = __toESM(require_react(), 1);
function TokenBalance({
  token,
  onClick,
  onActionPress,
  actionText = "Max",
  classNames,
  "aria-label": ariaLabel,
  ...contentProps
}) {
  if (onClick) {
    return (0, import_jsx_runtime95.jsxs)("div", { className: "relative", children: [
      (0, import_jsx_runtime95.jsx)(
        "button",
        {
          type: "button",
          "aria-label": ariaLabel ?? `${token.name} token balance`,
          onClick: () => onClick(token),
          className: cn(
            "flex w-full items-center justify-start gap-4 px-2 py-1",
            classNames == null ? void 0 : classNames.container
          ),
          "data-testid": "ockTokenBalanceButton",
          children: (0, import_jsx_runtime95.jsx)(
            TokenBalanceContent,
            {
              token,
              classNames,
              onActionPress,
              ...contentProps
            }
          )
        }
      ),
      onActionPress && (0, import_jsx_runtime95.jsx)(
        ActionButton,
        {
          actionText,
          onActionPress,
          className: classNames == null ? void 0 : classNames.action
        }
      )
    ] });
  }
  return (0, import_jsx_runtime95.jsxs)(
    "div",
    {
      className: cn(
        "flex w-full items-center justify-start gap-4 px-2 py-1",
        classNames == null ? void 0 : classNames.container
      ),
      "data-testid": "ockTokenBalance",
      children: [
        (0, import_jsx_runtime95.jsx)(
          TokenBalanceContent,
          {
            token,
            ...contentProps,
            classNames
          }
        ),
        onActionPress && (0, import_jsx_runtime95.jsx)(
          ActionButton,
          {
            actionText,
            onActionPress,
            className: classNames == null ? void 0 : classNames.action
          }
        )
      ]
    }
  );
}
function TokenBalanceContent({
  token,
  subtitle,
  showImage = true,
  onActionPress,
  tokenSize = 40,
  classNames
}) {
  var _a;
  const formattedFiatValue = (0, import_react68.useMemo)(
    () => formatFiatAmount({
      amount: token.fiatBalance,
      currency: "USD"
    }),
    [token.fiatBalance]
  );
  const formattedCryptoValue = (0, import_react68.useMemo)(
    () => truncateDecimalPlaces(
      formatUnits(BigInt(token.cryptoBalance), token.decimals),
      3
    ),
    [token.cryptoBalance, token.decimals]
  );
  return (0, import_jsx_runtime95.jsxs)("div", { className: "grid w-full grid-cols-[2.5rem_1fr_auto] items-center gap-3", children: [
    (0, import_jsx_runtime95.jsx)("div", { className: "h-10 w-10", children: showImage && (0, import_jsx_runtime95.jsx)(TokenImage, { token, size: tokenSize }) }),
    (0, import_jsx_runtime95.jsxs)("div", { className: "flex min-w-0 flex-col text-left", children: [
      (0, import_jsx_runtime95.jsx)(
        "span",
        {
          className: cn(
            text.headline,
            color.foreground,
            "overflow-hidden text-ellipsis whitespace-nowrap",
            classNames == null ? void 0 : classNames.tokenName
          ),
          children: (_a = token.name) == null ? void 0 : _a.trim()
        }
      ),
      (0, import_jsx_runtime95.jsx)(
        "span",
        {
          className: cn(
            text.label2,
            color.foregroundMuted,
            classNames == null ? void 0 : classNames.tokenValue
          ),
          children: `${formattedCryptoValue} ${token.symbol} ${subtitle ?? ""}`
        }
      )
    ] }),
    (0, import_jsx_runtime95.jsx)("div", { className: "text-right", children: !onActionPress && (0, import_jsx_runtime95.jsx)(
      "span",
      {
        className: cn(
          text.label2,
          color.foregroundMuted,
          "whitespace-nowrap",
          classNames == null ? void 0 : classNames.fiatValue
        ),
        children: formattedFiatValue
      }
    ) })
  ] });
}
function ActionButton({
  actionText,
  onActionPress,
  className
}) {
  return (0, import_jsx_runtime95.jsx)(
    "button",
    {
      type: "button",
      "data-testid": "ockTokenBalanceAction",
      "aria-label": actionText,
      onClick: onActionPress,
      className: cn(
        text.label2,
        color.primary,
        border.radius,
        "cursor-pointer p-0.5 font-bold",
        "border border-transparent hover:border-[--ock-line-primary]",
        "-translate-y-1/2 absolute top-1/2 right-2",
        className
      ),
      children: actionText
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendTokenSelector.js
function SendTokenSelector({ classNames }) {
  const { address } = useAccount();
  const { data: portfolioData } = usePortfolio(
    { address },
    RequestContext.Wallet
  );
  const tokenBalances = portfolioData == null ? void 0 : portfolioData.tokenBalances;
  const {
    selectedToken,
    handleTokenSelection,
    handleResetTokenSelection,
    setSelectedInputType,
    handleCryptoAmountChange,
    handleFiatAmountChange
  } = useSendContext();
  if (!selectedToken) {
    return (0, import_jsx_runtime96.jsxs)("div", { className: "mt-4 flex max-h-80 flex-col gap-2", children: [
      (0, import_jsx_runtime96.jsx)("span", { className: cn(text.caption, color.foregroundMuted, "uppercase"), children: "Select a token" }),
      (0, import_jsx_runtime96.jsx)("div", { className: "scrollbar-hidden overflow-y-auto", children: tokenBalances == null ? void 0 : tokenBalances.map((token) => (0, import_jsx_runtime96.jsx)(
        TokenBalance,
        {
          token,
          onClick: handleTokenSelection,
          subtitle: "",
          classNames: {
            container: cn(
              pressable.default,
              border.radius,
              classNames == null ? void 0 : classNames.container
            ),
            ...classNames
          }
        },
        token.address
      )) })
    ] });
  }
  return (0, import_jsx_runtime96.jsx)(
    TokenBalance,
    {
      token: selectedToken,
      showImage: true,
      subtitle: "available",
      onClick: handleResetTokenSelection,
      onActionPress: () => {
        setSelectedInputType("crypto");
        handleFiatAmountChange(String(selectedToken.fiatBalance));
        handleCryptoAmountChange(
          String(
            formatUnits(
              BigInt(selectedToken.cryptoBalance),
              selectedToken.decimals
            )
          )
        );
      },
      classNames: {
        container: cn(
          pressable.alternate,
          border.radius,
          classNames == null ? void 0 : classNames.container
        ),
        ...classNames
      }
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendAddressInput.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
function SendAddressInput({ classNames }) {
  const {
    recipientState,
    updateRecipientInput,
    validateRecipientInput,
    deselectRecipient
  } = useSendContext();
  return (0, import_jsx_runtime97.jsxs)(
    "div",
    {
      "data-testid": "ockSendAddressInput",
      className: cn(
        border.lineDefault,
        border.radius,
        "w-full",
        "flex items-center gap-2",
        "px-4 py-3",
        classNames == null ? void 0 : classNames.container
      ),
      children: [
        (0, import_jsx_runtime97.jsx)("span", { className: cn(color.foreground, classNames == null ? void 0 : classNames.label), children: "To" }),
        (0, import_jsx_runtime97.jsx)(
          TextInput,
          {
            inputMode: "text",
            placeholder: "Basename, ENS, or Address",
            value: recipientState.displayValue ?? recipientState.input,
            setValue: updateRecipientInput,
            onChange: validateRecipientInput,
            onFocus: deselectRecipient,
            "aria-label": "Input Receiver Address",
            className: cn(
              background.default,
              "w-full outline-none",
              classNames == null ? void 0 : classNames.input
            )
          }
        )
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/SendAddressSelector.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react70 = __toESM(require_react(), 1);
function SendAddressSelector({ classNames }) {
  const { chain } = useWalletContext();
  const { recipientState, selectRecipient } = useSendContext();
  const handleSelectorClick = (0, import_react70.useCallback)(async () => {
    selectRecipient({
      phase: "selected",
      input: recipientState.input,
      address: recipientState.address,
      displayValue: recipientState.displayValue
    });
  }, [
    recipientState.input,
    recipientState.address,
    recipientState.displayValue,
    selectRecipient
  ]);
  if (!recipientState.address || !chain) {
    return null;
  }
  return (0, import_jsx_runtime98.jsx)(
    "button",
    {
      "data-testid": "ockSendAddressSelector_button",
      type: "button",
      onClick: handleSelectorClick,
      className: "w-full text-left",
      children: (0, import_jsx_runtime98.jsx)(
        "div",
        {
          "data-testid": "ockSendAddressSelector_container",
          className: cn(
            background.default,
            border.radius,
            pressable.default,
            "items-left flex min-w-[300px]",
            "mt-2 p-2",
            classNames == null ? void 0 : classNames.container
          ),
          children: (0, import_jsx_runtime98.jsxs)("div", { className: "flex items-center space-x-3", children: [
            (0, import_jsx_runtime98.jsx)("div", { className: "flex-shrink-0", children: (0, import_jsx_runtime98.jsx)(
              Avatar,
              {
                address: recipientState.address,
                chain,
                className: classNames == null ? void 0 : classNames.avatar
              }
            ) }),
            (0, import_jsx_runtime98.jsxs)("div", { className: "flex flex-col", children: [
              (0, import_jsx_runtime98.jsx)(
                Name,
                {
                  address: recipientState.address,
                  chain,
                  className: classNames == null ? void 0 : classNames.name
                }
              ),
              (0, import_jsx_runtime98.jsx)(
                Address,
                {
                  address: recipientState.address,
                  hasCopyAddressOnClick: false,
                  className: classNames == null ? void 0 : classNames.address
                }
              )
            ] })
          ] })
        }
      )
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/wallet-advanced-send/components/Send.js
function Send({
  children = (0, import_jsx_runtime99.jsx)(SendDefaultChildren, {}),
  className
}) {
  return (0, import_jsx_runtime99.jsx)(SendProvider, { children: (0, import_jsx_runtime99.jsx)(
    "div",
    {
      "data-testid": "ockSend",
      className: cn(
        background.default,
        border.radius,
        border.lineDefault,
        color.foreground,
        "h-120 w-88",
        "flex flex-col",
        "p-4",
        className
      ),
      children
    }
  ) });
}
function SendDefaultChildren() {
  const { ethBalance, isInitialized, recipientState, selectedToken } = useSendContext();
  const walletHasEth = (ethBalance ?? 0) > ETH_REQUIRED_FOR_SEND;
  if (!isInitialized) {
    return (0, import_jsx_runtime99.jsx)(Skeleton, { className: "h-full w-full" });
  }
  return (0, import_jsx_runtime99.jsxs)(import_jsx_runtime99.Fragment, { children: [
    (0, import_jsx_runtime99.jsx)(SendHeader, {}),
    walletHasEth ? (0, import_jsx_runtime99.jsxs)("div", { className: "flex h-full flex-col justify-between gap-4", children: [
      (0, import_jsx_runtime99.jsxs)("div", { children: [
        (0, import_jsx_runtime99.jsx)(SendAddressInput, {}),
        recipientState.phase === "validated" && (0, import_jsx_runtime99.jsx)(SendAddressSelector, {}),
        recipientState.phase === "selected" && !selectedToken && (0, import_jsx_runtime99.jsx)(SendTokenSelector, {})
      ] }),
      recipientState.phase === "selected" && selectedToken && (0, import_jsx_runtime99.jsxs)(import_jsx_runtime99.Fragment, { children: [
        (0, import_jsx_runtime99.jsx)(SendAmountInput, {}),
        (0, import_jsx_runtime99.jsx)(SendTokenSelector, {}),
        (0, import_jsx_runtime99.jsx)(SendButton, {})
      ] })
    ] }) : (0, import_jsx_runtime99.jsx)(SendFundWallet, {})
  ] });
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletDropdownContent.js
function WalletDropdownContent({
  children,
  swappableTokens,
  classNames
}) {
  const {
    isSubComponentOpen,
    setIsSubComponentOpen,
    isSubComponentClosing,
    setIsSubComponentClosing,
    connectRef,
    breakpoint,
    activeFeature,
    animations
  } = useWalletContext();
  const { address } = useAccount();
  const { data: portfolioData } = usePortfolio(
    { address, enabled: Boolean(activeFeature) },
    RequestContext.Wallet
  );
  const tokenBalances = portfolioData == null ? void 0 : portfolioData.tokenBalances;
  const handleBottomSheetClose = (0, import_react71.useCallback)(() => {
    setIsSubComponentOpen(false);
  }, [setIsSubComponentOpen]);
  const handleAnimationEnd = (0, import_react71.useCallback)(() => {
    if (isSubComponentClosing) {
      setIsSubComponentOpen(false);
      setIsSubComponentClosing(false);
    }
  }, [isSubComponentClosing, setIsSubComponentOpen, setIsSubComponentClosing]);
  const content = (0, import_react71.useMemo)(() => {
    if (activeFeature === "send") {
      return (0, import_jsx_runtime100.jsx)(ContentWrapper, { children: (0, import_jsx_runtime100.jsx)(Send, { className: "border-none" }) });
    }
    if (activeFeature === "qr") {
      return (0, import_jsx_runtime100.jsx)(ContentWrapper, { children: (0, import_jsx_runtime100.jsx)(WalletAdvancedQrReceive, { classNames: classNames == null ? void 0 : classNames.qr }) });
    }
    if (activeFeature === "swap") {
      return (0, import_jsx_runtime100.jsx)(ContentWrapper, { children: (0, import_jsx_runtime100.jsx)(
        WalletAdvancedSwap,
        {
          title: (0, import_jsx_runtime100.jsx)(
            "div",
            {
              className: cn(text.headline, "w-full text-center text-base"),
              children: "Swap"
            }
          ),
          to: swappableTokens ?? WALLET_ADVANCED_DEFAULT_SWAPPABLE_TOKENS,
          from: (tokenBalances == null ? void 0 : tokenBalances.map((token) => ({
            address: token.address,
            chainId: token.chainId,
            symbol: token.symbol,
            decimals: token.decimals,
            image: token.image,
            name: token.name
          }))) ?? [],
          classNames: classNames == null ? void 0 : classNames.swap
        }
      ) });
    }
    return (0, import_jsx_runtime100.jsx)(ContentWrapper, { children });
  }, [activeFeature, swappableTokens, tokenBalances, children, classNames]);
  if (breakpoint === "sm") {
    return (0, import_jsx_runtime100.jsx)(
      BottomSheet,
      {
        isOpen: isSubComponentOpen,
        triggerRef: connectRef,
        onClose: handleBottomSheetClose,
        className: classNames == null ? void 0 : classNames.container,
        children: (0, import_jsx_runtime100.jsx)("div", { className: "flex h-full w-full flex-col items-center justify-center", children: content })
      }
    );
  }
  return (0, import_jsx_runtime100.jsx)(
    "div",
    {
      "data-testid": "ockWalletDropdownContent",
      className: cn(
        background.default,
        border.radius,
        border.lineDefault,
        zIndex.dropdown,
        "my-1.5 h-auto w-full",
        "flex justify-center",
        // ensure border radius is respected
        "overflow-hidden",
        animations.container,
        classNames == null ? void 0 : classNames.container
      ),
      onAnimationEnd: handleAnimationEnd,
      children: content
    }
  );
}
function ContentWrapper({
  children,
  className
}) {
  return (0, import_jsx_runtime100.jsx)(
    "div",
    {
      className: cn(
        "flex flex-col justify-between",
        "min-w-80 max-h-120",
        className
      ),
      children
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvanced.js
var defaultWalletAdvancedChildren = (0, import_jsx_runtime101.jsxs)(import_jsx_runtime101.Fragment, { children: [
  (0, import_jsx_runtime101.jsx)(WalletAdvancedWalletActions, {}),
  (0, import_jsx_runtime101.jsx)(WalletAdvancedAddressDetails, {}),
  (0, import_jsx_runtime101.jsx)(WalletAdvancedTransactionActions, {}),
  (0, import_jsx_runtime101.jsx)(WalletAdvancedTokenHoldings, {})
] });
function WalletAdvanced({
  children,
  classNames,
  swappableTokens
}) {
  const { isSubComponentOpen, showSubComponentAbove, alignSubComponentRight } = useWalletContext();
  if (!isSubComponentOpen) {
    return null;
  }
  return (0, import_jsx_runtime101.jsx)(
    "div",
    {
      "data-testid": "ockWalletAdvancedContainer",
      className: cn(
        "absolute",
        showSubComponentAbove ? "bottom-full" : "top-full",
        alignSubComponentRight ? "right-0" : "left-0"
      ),
      children: (0, import_jsx_runtime101.jsx)(
        WalletDropdownContent,
        {
          classNames,
          swappableTokens,
          children: children || defaultWalletAdvancedChildren
        }
      )
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletDropdown.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var import_react73 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletDropdownDisconnect.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_react72 = __toESM(require_react(), 1);
function WalletDropdownDisconnect({
  className,
  text: text$1 = "Disconnect"
}) {
  const { disconnect, connectors } = useDisconnect();
  const handleDisconnect = (0, import_react72.useCallback)(() => {
    connectors.map((connector) => disconnect({ connector }));
  }, [disconnect, connectors]);
  return (0, import_jsx_runtime102.jsxs)(
    "button",
    {
      type: "button",
      className: cn(
        pressable.default,
        color.foreground,
        "relative flex w-full items-center px-4 pt-3 pb-4",
        className
      ),
      onClick: handleDisconnect,
      children: [
        (0, import_jsx_runtime102.jsx)("div", { className: "absolute left-4 flex h-[1.125rem] w-[1.125rem] items-center justify-center", children: disconnectSvg }),
        (0, import_jsx_runtime102.jsx)("span", { className: cn(text.body, "pl-6"), children: text$1 })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletDropdownLink.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
function WalletDropdownLink({
  children,
  className,
  icon: icon2,
  href,
  rel,
  target
}) {
  const iconSvg = useIcon({ icon: icon2 });
  return (0, import_jsx_runtime103.jsxs)(
    "a",
    {
      className: cn(
        pressable.default,
        color.foreground,
        "relative flex items-center px-4 py-3",
        className
      ),
      href,
      target,
      rel,
      children: [
        (0, import_jsx_runtime103.jsx)("div", { className: "-translate-y-1/2 absolute top-1/2 left-4 flex h-[1.125rem] w-[1.125rem] items-center justify-center", children: iconSvg }),
        (0, import_jsx_runtime103.jsx)("span", { className: cn(text.body, "pl-6"), children })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletDropdown.js
var defaultWalletDropdownChildren = (0, import_jsx_runtime104.jsxs)(import_jsx_runtime104.Fragment, { children: [
  (0, import_jsx_runtime104.jsxs)(Identity, { className: "px-4 pt-3 pb-2", children: [
    (0, import_jsx_runtime104.jsx)(Avatar, {}),
    (0, import_jsx_runtime104.jsx)(Name, {}),
    (0, import_jsx_runtime104.jsx)(Address, { className: color.foregroundMuted }),
    (0, import_jsx_runtime104.jsx)(EthBalance, {})
  ] }, "wallet-dd-identity"),
  (0, import_jsx_runtime104.jsx)(
    WalletDropdownLink,
    {
      icon: "wallet",
      href: "https://keys.coinbase.com",
      target: "_blank",
      children: "Wallet"
    },
    "wallet-dd-link"
  ),
  (0, import_jsx_runtime104.jsx)(WalletDropdownDisconnect, {}, "wallet-dd-disconnect")
] });
function WalletDropdown({
  children,
  className,
  classNames,
  swappableTokens
}) {
  const {
    address,
    breakpoint,
    isSubComponentOpen,
    showSubComponentAbove,
    alignSubComponentRight
  } = useWalletContext();
  if (!address) {
    return null;
  }
  if (!breakpoint) {
    return null;
  }
  if (!isSubComponentOpen) {
    return null;
  }
  return (0, import_jsx_runtime104.jsx)(
    "div",
    {
      "data-testid": "ockWalletDropdown",
      className: cn(
        "absolute",
        showSubComponentAbove ? "bottom-full" : "top-full",
        alignSubComponentRight ? "right-0" : "left-0",
        className
      ),
      children: (0, import_jsx_runtime104.jsx)(
        WalletDropdownContent,
        {
          classNames,
          swappableTokens,
          children: children || defaultWalletDropdownChildren
        }
      )
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/Wallet.js
var defaultWalletChildren = (0, import_jsx_runtime105.jsxs)(import_jsx_runtime105.Fragment, { children: [
  (0, import_jsx_runtime105.jsx)(ConnectWallet, {}),
  (0, import_jsx_runtime105.jsx)(WalletDropdown, {})
] });
function Wallet({
  children,
  className,
  draggable,
  draggableStartingPosition,
  isSponsored
}) {
  const componentTheme = useTheme();
  const isMounted = useIsMounted();
  if (!isMounted) {
    return null;
  }
  return (0, import_jsx_runtime105.jsx)(WalletProvider, { isSponsored, children: (0, import_jsx_runtime105.jsx)(
    WalletContent,
    {
      className: cn(componentTheme, className),
      ...getWalletDraggableProps({ draggable, draggableStartingPosition }),
      children
    }
  ) });
}
function WalletContent({
  children,
  className,
  draggable,
  draggableStartingPosition
}) {
  const {
    isSubComponentOpen,
    isConnectModalOpen,
    handleClose,
    connectRef,
    breakpoint
  } = useWalletContext();
  const walletContainerRef = (0, import_react74.useRef)(null);
  useOutsideClick(walletContainerRef, handleClose);
  const { dropdown, advanced } = (0, import_react74.useMemo)(() => {
    const childrenArray = import_react74.Children.toArray(children);
    return {
      dropdown: childrenArray.find(findComponent(WalletDropdown)),
      advanced: childrenArray.find(findComponent(WalletAdvanced))
    };
  }, [children]);
  const childrenToRender = (0, import_react74.useMemo)(() => {
    return import_react74.Children.map(children, (child) => {
      if ((0, import_react74.isValidElement)(child) && child.type === WalletAdvanced && dropdown) {
        return null;
      }
      return child;
    });
  }, [dropdown, children]);
  if (dropdown && advanced) {
    console.error(
      "Defaulted to WalletDropdown. Wallet cannot have both WalletDropdown and WalletAdvanced as children."
    );
  }
  const disableDraggable = isConnectModalOpen || breakpoint === "sm" && isSubComponentOpen;
  if (draggable) {
    return (0, import_jsx_runtime105.jsx)(
      "div",
      {
        ref: walletContainerRef,
        className: cn("relative w-fit shrink-0", className),
        children: (0, import_jsx_runtime105.jsx)(
          Draggable,
          {
            startingPosition: draggableStartingPosition,
            disabled: disableDraggable,
            children: (0, import_jsx_runtime105.jsx)("div", { ref: connectRef, children: childrenToRender || defaultWalletChildren })
          }
        )
      }
    );
  }
  return (0, import_jsx_runtime105.jsx)(
    "div",
    {
      ref: walletContainerRef,
      className: cn("relative w-fit shrink-0", className),
      children: (0, import_jsx_runtime105.jsx)("div", { ref: connectRef, children: childrenToRender || defaultWalletChildren })
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletDefault.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
function WalletDefault() {
  return (0, import_jsx_runtime106.jsx)(Wallet, {});
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletIsland.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var import_react75 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/svg/portfolioSvg.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var portfolioSvg = (0, import_jsx_runtime107.jsxs)(
  "svg",
  {
    width: "100%",
    height: "100%",
    viewBox: "0 0 18 18",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: icon.foreground,
    children: [
      (0, import_jsx_runtime107.jsx)("title", { children: "Portfolio" }),
      (0, import_jsx_runtime107.jsx)(
        "path",
        {
          d: "M2.7125 0.875H15.875V4.625H2.7125C1.7 4.625 0.875 3.8 0.875 2.7875V2.7125C0.875 1.7 1.7 0.875 2.7125 0.875Z",
          fill: "currentColor"
        }
      ),
      (0, import_jsx_runtime107.jsx)(
        "path",
        {
          d: "M0.875 5.875V14.5C0.875 15.95 2.05 17.125 3.5 17.125H17.125V5.875H0.875ZM13.375 12.125C12.6875 12.125 12.125 11.5625 12.125 10.875C12.125 10.1875 12.6875 9.625 13.375 9.625C14.0625 9.625 14.625 10.1875 14.625 10.875C14.625 11.5625 14.0625 12.125 13.375 12.125Z",
          fill: "currentColor"
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletIsland.js
function WalletIsland({
  startingPosition = getDefaultDraggableStartingPosition(),
  isSponsored
}) {
  return (0, import_jsx_runtime108.jsxs)(
    Wallet,
    {
      draggable: true,
      draggableStartingPosition: startingPosition,
      isSponsored,
      children: [
        (0, import_jsx_runtime108.jsx)(
          ConnectWallet,
          {
            className: "!rounded-full m-0 flex h-14 w-14 min-w-14 flex-col items-center justify-center p-0",
            disconnectedLabel: (0, import_jsx_runtime108.jsx)("div", { className: "h-5 w-5", children: portfolioSvg }),
            children: (0, import_jsx_runtime108.jsx)(Avatar, { className: "pointer-events-none h-14 w-14" })
          }
        ),
        (0, import_jsx_runtime108.jsxs)(WalletDropdown, { children: [
          (0, import_jsx_runtime108.jsx)(WalletAdvancedWalletActions, {}),
          (0, import_jsx_runtime108.jsx)(WalletAdvancedAddressDetails, {}),
          (0, import_jsx_runtime108.jsx)(WalletAdvancedTransactionActions, {}),
          (0, import_jsx_runtime108.jsx)(WalletAdvancedTokenHoldings, {})
        ] })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletDropdownBasename.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/svg/basenameSvg.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var basenameSvg = (0, import_jsx_runtime109.jsx)(
  "svg",
  {
    "data-testid": "ock-basenameSvg",
    role: "img",
    "aria-label": "ock-basenameSvg",
    width: "100%",
    height: "100%",
    viewBox: "0 0 20 20",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    className: "h-full w-full",
    children: (0, import_jsx_runtime109.jsx)("g", { id: "Icons/User", children: (0, import_jsx_runtime109.jsx)(
      "path",
      {
        id: "Vector",
        d: "M10 20C4.47715 20 0 15.5228 0 10C0 4.47715 4.47715 0 10 0C15.5228 0 20 4.47715 20 10C20 15.5228 15.5228 20 10 20ZM12.832 6.9987C12.832 5.43461 11.5641 4.16666 10 4.16666C8.43594 4.16666 7.168 5.43461 7.168 6.9987C7.168 8.56279 8.43594 9.83073 10 9.83073C11.5641 9.83073 12.832 8.56279 12.832 6.9987ZM5.67266 11.6810L4.76738 14.0938C6.10704 15.4238 7.95093 16.2465 9.98699 16.2500L10.0130 16.2500C12.0491 16.2465 13.8930 15.4238 15.2326 14.0938L14.3273 11.6810C14.0026 10.8125 13.1794 10.2385 12.2581 10.2159C12.2279 10.2385 11.2310 10.9635 10.0000 10.9635C8.76903 10.9635 7.77215 10.2385 7.74194 10.2159C6.82059 10.2310 5.9974 10.8125 5.67266 11.6810Z",
        className: icon.foreground
      }
    ) })
  }
);

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletDropdownBasename.js
function WalletDropdownBasename({
  className
}) {
  const { address } = useAccount();
  if (!address) {
    return null;
  }
  const { data: basename, isLoading } = useName({
    address,
    chain: base
  });
  const hasBaseUserName = !!basename;
  const title = hasBaseUserName ? "Profile" : "Claim Basename";
  const href = hasBaseUserName ? `https://www.base.org/name/${basename}` : "https://www.base.org/names";
  return (0, import_jsx_runtime110.jsxs)(
    "a",
    {
      className: cn(
        pressable.default,
        color.foreground,
        "relative flex items-center px-4 py-3",
        className
      ),
      href,
      target: "_blank",
      rel: "noopener noreferrer",
      children: [
        (0, import_jsx_runtime110.jsx)("div", { className: "-translate-y-1/2 absolute top-1/2 left-4 flex h-[1.125rem] w-[1.125rem] items-center justify-center", children: basenameSvg }),
        (0, import_jsx_runtime110.jsx)("div", { className: "flex w-full items-center pl-6", children: isLoading ? (0, import_jsx_runtime110.jsx)(Spinner, {}) : (0, import_jsx_runtime110.jsxs)(import_jsx_runtime110.Fragment, { children: [
          (0, import_jsx_runtime110.jsx)("span", { className: cn(text.body), children: title }),
          !hasBaseUserName && (0, import_jsx_runtime110.jsx)(
            "span",
            {
              className: cn(
                "ml-2 rounded-full bg-[#E0E7FF] px-2 py-0.5 text-center font-bold font-inter text-[#4F46E5] text-[0.6875rem] uppercase leading-none"
              ),
              children: "NEW"
            }
          )
        ] }) })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletDropdownFundLink.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var import_react76 = __toESM(require_react(), 1);
function WalletDropdownFundLink({
  className,
  fundingUrl,
  icon: icon2 = "fundWallet",
  openIn = "popup",
  popupSize = "md",
  rel,
  target,
  text: text$1 = "Fund wallet"
}) {
  const fundingUrlToRender = fundingUrl ?? // eslint-disable-next-line react-hooks/rules-of-hooks
  useGetFundingUrl({
    originComponentName: "WalletDropdownFundLink"
  });
  const iconSvg = useIcon({ icon: icon2 });
  const handleClick = (0, import_react76.useCallback)(
    (e) => {
      e.preventDefault();
      if (fundingUrlToRender) {
        const { height, width } = getFundingPopupSize(
          popupSize,
          fundingUrlToRender
        );
        openPopup({
          url: fundingUrlToRender,
          height,
          width,
          target
        });
      }
    },
    [fundingUrlToRender, popupSize, target]
  );
  const overrideClassName = cn(
    pressable.default,
    color.foreground,
    // Disable hover effects if there is no funding URL
    !fundingUrlToRender && "pointer-events-none",
    "relative flex items-center px-4 py-3 w-full",
    className
  );
  const linkContent = (0, import_react76.useMemo)(
    () => (
      // We put disabled on the content wrapper rather than the button/link because we dont wan't to change the
      // background color of the dropdown item, just the text and icon
      (0, import_jsx_runtime111.jsxs)("span", { className: cn(!fundingUrlToRender && pressable.disabled), children: [
        (0, import_jsx_runtime111.jsx)("div", { className: "-translate-y-1/2 absolute top-1/2 left-4 flex h-[1.125rem] w-[1.125rem] items-center justify-center", children: iconSvg }),
        (0, import_jsx_runtime111.jsx)("span", { className: cn(text.body, "pl-6"), children: text$1 })
      ] })
    ),
    [fundingUrlToRender, iconSvg, text$1]
  );
  if (openIn === "tab") {
    return (0, import_jsx_runtime111.jsx)(
      "a",
      {
        className: overrideClassName,
        href: fundingUrlToRender,
        target,
        rel,
        children: linkContent
      }
    );
  }
  return (0, import_jsx_runtime111.jsx)("button", { type: "button", className: overrideClassName, onClick: handleClick, children: linkContent });
}

// node_modules/@coinbase/onchainkit/dist/wallet/components/WalletAdvancedDefault.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
function WalletAdvancedDefault() {
  return (0, import_jsx_runtime112.jsxs)(Wallet, { children: [
    (0, import_jsx_runtime112.jsx)(ConnectWallet, {}),
    (0, import_jsx_runtime112.jsxs)(WalletDropdown, { children: [
      (0, import_jsx_runtime112.jsx)(WalletAdvancedWalletActions, {}),
      (0, import_jsx_runtime112.jsx)(WalletAdvancedAddressDetails, {}),
      (0, import_jsx_runtime112.jsx)(WalletAdvancedTransactionActions, {}),
      (0, import_jsx_runtime112.jsx)(WalletAdvancedTokenHoldings, {})
    ] })
  ] });
}

// node_modules/@coinbase/onchainkit/dist/wallet/utils/isValidAAEntrypoint.js
function isValidAAEntrypoint({
  entrypoint
}) {
  if (entrypoint.toLowerCase() !== entryPoint06Address.toLowerCase()) {
    return false;
  }
  return true;
}

// node_modules/@coinbase/onchainkit/dist/wallet/utils/isWalletACoinbaseSmartWallet.js
async function isWalletACoinbaseSmartWallet({
  client,
  userOp
}) {
  var _a;
  try {
    const code = await client.getBytecode({ address: userOp.sender });
    if (!code) {
      const factoryAddress = (_a = userOp == null ? void 0 : userOp.initCode) == null ? void 0 : _a.slice(0, 42);
      if (checksumAddress(factoryAddress) !== checksumAddress(CB_SW_FACTORY_ADDRESS)) {
        return {
          isCoinbaseSmartWallet: false,
          error: "Invalid factory address",
          code: "W_ERR_1"
        };
      }
      return { isCoinbaseSmartWallet: true };
    }
    if (code !== CB_SW_PROXY_BYTECODE) {
      return {
        isCoinbaseSmartWallet: false,
        error: "Invalid bytecode",
        code: "W_ERR_2"
      };
    }
  } catch (error) {
    console.error("Error retrieving bytecode:", error);
    return {
      isCoinbaseSmartWallet: false,
      error: "Error retrieving bytecode",
      code: "W_ERR_3"
    };
  }
  let implementation;
  try {
    implementation = await client.request({
      method: "eth_getStorageAt",
      params: [userOp.sender, ERC_1967_PROXY_IMPLEMENTATION_SLOT, "latest"]
    });
  } catch (error) {
    console.error("Error retrieving implementation address:", error);
    return {
      isCoinbaseSmartWallet: false,
      error: "Error retrieving implementation address",
      code: "W_ERR_4"
    };
  }
  const implementationAddress = decodeAbiParameters(
    [{ type: "address" }],
    implementation
  )[0];
  if (checksumAddress(implementationAddress) !== checksumAddress(CB_SW_V1_IMPLEMENTATION_ADDRESS)) {
    return {
      isCoinbaseSmartWallet: false,
      error: "Invalid implementation address",
      code: "W_ERR_5"
    };
  }
  return { isCoinbaseSmartWallet: true };
}
export {
  ConnectWallet,
  ConnectWalletText,
  Wallet,
  WalletAdvanced,
  WalletAdvancedAddressDetails,
  WalletAdvancedDefault,
  WalletAdvancedQrReceive,
  WalletAdvancedSwap,
  WalletAdvancedTokenHoldings,
  WalletAdvancedTransactionActions,
  WalletAdvancedWalletActions,
  WalletDefault,
  WalletDropdown,
  WalletDropdownBasename,
  WalletDropdownDisconnect,
  WalletDropdownFundLink,
  WalletDropdownLink,
  WalletIsland,
  WalletModal,
  WalletProvider,
  isValidAAEntrypoint,
  isWalletACoinbaseSmartWallet,
  usePortfolio,
  useWalletContext
};
/*! Bundled license information:

react-dom/cjs/react-dom-server-legacy.browser.development.js:
  (**
   * @license React
   * react-dom-server-legacy.browser.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.browser.development.js:
  (**
   * @license React
   * react-dom-server.browser.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@coinbase_onchainkit_wallet.js.map
