import {
  background,
  border,
  cn,
  color,
  icon,
  pressable,
  text,
  useTheme,
  useValue
} from "./chunk-JTJHCETJ.js";
import {
  Capabilities,
  TransactionEvent,
  sendAnalyticsPayload
} from "./chunk-2YAJQTYP.js";
import {
  useOnchainKit
} from "./chunk-D3A4POTL.js";
import {
  useAccount,
  useCallsStatus,
  useCapabilities,
  useChainId,
  useConfig,
  useSendCalls,
  useSendTransaction,
  useShowCallsStatus,
  useSwitchChain,
  useWaitForTransactionReceipt
} from "./chunk-5WJVUKOY.js";
import {
  waitForTransactionReceipt
} from "./chunk-XNSTLHSV.js";
import {
  arbitrum,
  arbitrumSepolia,
  base,
  baseSepolia,
  mainnet,
  optimism,
  optimismSepolia,
  polygon,
  polygonMumbai,
  sepolia
} from "./chunk-73ADTDOL.js";
import {
  encodeFunctionData
} from "./chunk-SBWNL4JE.js";
import {
  require_jsx_runtime
} from "./chunk-TLG7CTPL.js";
import {
  require_react
} from "./chunk-VT65UQWK.js";
import {
  __toESM
} from "./chunk-ONY6HBPH.js";

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/core/analytics/hooks/useAnalytics.js
var useAnalytics = () => {
  return { sendAnalytics: sendAnalyticsPayload };
};

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useCapabilitiesSafe.js
var import_react = __toESM(require_react(), 1);
function useCapabilitiesSafe({
  chainId
}) {
  const { isConnected } = useAccount();
  const { data: capabilities, error } = useCapabilities({
    query: { enabled: isConnected }
  });
  return (0, import_react.useMemo)(() => {
    if (error || !capabilities || !capabilities[chainId]) {
      return {};
    }
    return capabilities[chainId];
  }, [capabilities, chainId, error]);
}

// node_modules/@coinbase/onchainkit/dist/transaction/constants.js
var GENERIC_ERROR_MESSAGE = "Something went wrong. Please try again.";

// node_modules/@coinbase/onchainkit/dist/internal/utils/normalizeWagmi.js
function normalizeStatus(status) {
  if (status === "CONFIRMED") {
    return "success";
  }
  if (status === "PENDING") {
    return "pending";
  }
  return status;
}
function normalizeTransactionId(data) {
  if (typeof data === "string") {
    return data;
  }
  return data.id;
}

// node_modules/@coinbase/onchainkit/dist/transaction/hooks/useCallsStatus.js
function useCallsStatus2({
  setLifecycleStatus,
  transactionId
}) {
  var _a, _b;
  try {
    const { data } = useCallsStatus({
      id: transactionId,
      query: {
        refetchInterval: (query) => {
          var _a2;
          return normalizeStatus((_a2 = query.state.data) == null ? void 0 : _a2.status) === "success" ? false : 1e3;
        },
        enabled: !!transactionId
      }
    });
    const transactionHash = (_b = (_a = data == null ? void 0 : data.receipts) == null ? void 0 : _a[0]) == null ? void 0 : _b.transactionHash;
    return { status: data == null ? void 0 : data.status, transactionHash };
  } catch (err) {
    setLifecycleStatus({
      statusName: "error",
      statusData: {
        code: "TmUCSh01",
        error: JSON.stringify(err),
        message: ""
      }
    });
    return { status: "error", transactionHash: void 0 };
  }
}

// node_modules/@coinbase/onchainkit/dist/transaction/utils/isUserRejectedRequestError.js
function isUserRejectedRequestError(err) {
  var _a, _b;
  if (((_a = err == null ? void 0 : err.cause) == null ? void 0 : _a.name) === "UserRejectedRequestError") {
    return true;
  }
  if ((_b = err == null ? void 0 : err.shortMessage) == null ? void 0 : _b.includes(
    "User rejected the request."
  )) {
    return true;
  }
  return false;
}

// node_modules/@coinbase/onchainkit/dist/transaction/hooks/useSendCall.js
function useSendCall({
  setLifecycleStatus,
  transactionHashList
}) {
  const {
    status,
    sendTransactionAsync: sendCallAsync,
    data,
    reset
  } = useSendTransaction({
    mutation: {
      onError: (e) => {
        const errorMessage = isUserRejectedRequestError(e) ? "Request denied." : GENERIC_ERROR_MESSAGE;
        setLifecycleStatus({
          statusName: "error",
          statusData: {
            code: "TmUSCh01",
            // Transaction module UseSendCall hook 01 error
            error: e.message,
            message: errorMessage
          }
        });
      },
      onSuccess: (hash) => {
        setLifecycleStatus({
          statusName: "transactionLegacyExecuted",
          statusData: {
            transactionHashList: [...transactionHashList, hash]
          }
        });
      }
    }
  });
  return { status, sendCallAsync, data, reset };
}

// node_modules/@coinbase/onchainkit/dist/transaction/hooks/useSendCalls.js
function useSendCalls2({
  setLifecycleStatus,
  setTransactionId
}) {
  const { status, sendCallsAsync, data, reset } = useSendCalls({
    mutation: {
      onError: (e) => {
        const errorMessage = isUserRejectedRequestError(e) ? "Request denied." : GENERIC_ERROR_MESSAGE;
        setLifecycleStatus({
          statusName: "error",
          statusData: {
            code: "TmUSCSh01",
            // Transaction module UseSendCalls hook 01 error
            error: e.message,
            message: errorMessage
          }
        });
      },
      onSuccess: (data2) => {
        setTransactionId(normalizeTransactionId(data2));
      }
    }
  });
  return { status, sendCallsAsync, data, reset };
}

// node_modules/@coinbase/onchainkit/dist/transaction/hooks/useSendWalletTransactions.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/transaction/utils/isContract.js
function isContract(transaction) {
  return "abi" in transaction;
}

// node_modules/@coinbase/onchainkit/dist/transaction/utils/sendBatchedTransactions.js
var sendBatchedTransactions = async ({
  capabilities,
  sendCallsAsync,
  transactions
}) => {
  if (!transactions) {
    return;
  }
  const calls = transactions == null ? void 0 : transactions.map((transaction) => {
    if (isContract(transaction)) {
      const { address, ...rest } = transaction;
      return {
        ...rest,
        to: address
      };
    }
    return transaction;
  });
  await sendCallsAsync({
    calls,
    capabilities
  });
};

// node_modules/@coinbase/onchainkit/dist/transaction/utils/sendSingleTransactions.js
var sendSingleTransactions = async ({
  config,
  sendCallAsync,
  transactions
}) => {
  const calls = transactions == null ? void 0 : transactions.map((transaction) => {
    if (isContract(transaction)) {
      return {
        data: encodeFunctionData({
          abi: transaction == null ? void 0 : transaction.abi,
          functionName: transaction == null ? void 0 : transaction.functionName,
          args: transaction == null ? void 0 : transaction.args
        }),
        to: transaction == null ? void 0 : transaction.address
      };
    }
    return transaction;
  });
  for (const call2 of calls) {
    const txHash = await sendCallAsync(call2);
    if (txHash) {
      await waitForTransactionReceipt(config, {
        hash: txHash,
        confirmations: 1
      });
    }
  }
};

// node_modules/@coinbase/onchainkit/dist/transaction/hooks/useSendWalletTransactions.js
var useSendWalletTransactions = ({
  capabilities,
  sendCallAsync,
  sendCallsAsync,
  walletCapabilities
}) => {
  const config = useConfig();
  return (0, import_react2.useCallback)(
    async (transactions) => {
      var _a;
      if (!transactions) {
        return;
      }
      const resolvedTransactions = await Promise.resolve(transactions);
      if ((_a = walletCapabilities[Capabilities.AtomicBatch]) == null ? void 0 : _a.supported) {
        await sendBatchedTransactions({
          capabilities,
          sendCallsAsync,
          transactions: resolvedTransactions
        });
      } else {
        await sendSingleTransactions({
          config,
          sendCallAsync,
          transactions: resolvedTransactions
        });
      }
    },
    [sendCallsAsync, sendCallAsync, capabilities, walletCapabilities, config]
  );
};

// node_modules/@coinbase/onchainkit/dist/transaction/utils/getPaymasterUrl.js
var getPaymasterUrl = (capabilities) => {
  var _a;
  return ((_a = capabilities == null ? void 0 : capabilities.paymasterService) == null ? void 0 : _a.url) || null;
};

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionProvider.js
var emptyContext = {};
var TransactionContext = (0, import_react3.createContext)(emptyContext);
function useTransactionContext() {
  const context = (0, import_react3.useContext)(TransactionContext);
  if (context === emptyContext) {
    throw new Error(
      "useTransactionContext must be used within a Transaction component"
    );
  }
  return context;
}
function TransactionProvider({
  calls,
  capabilities: transactionCapabilities,
  chainId,
  children,
  contracts,
  isSponsored,
  onError,
  onStatus,
  onSuccess,
  resetAfter
}) {
  const account = useAccount();
  const config = useConfig();
  const { config: { paymaster } = { paymaster: void 0 } } = useOnchainKit();
  const [errorMessage, setErrorMessage] = (0, import_react3.useState)("");
  const [errorCode, setErrorCode] = (0, import_react3.useState)("");
  const [isToastVisible, setIsToastVisible] = (0, import_react3.useState)(false);
  const [lifecycleStatus, setLifecycleStatus] = (0, import_react3.useState)({
    statusName: "init",
    statusData: null
  });
  const [transactionId, setTransactionId] = (0, import_react3.useState)("");
  const [transactionCount, setTransactionCount] = (0, import_react3.useState)();
  const [transactionHashList, setTransactionHashList] = (0, import_react3.useState)([]);
  const transactions = calls || contracts;
  const walletCapabilities = useCapabilitiesSafe({
    chainId
  });
  const { switchChainAsync } = useSwitchChain();
  if (!contracts && !calls) {
    throw new Error(
      "Transaction: calls or contracts must be provided as a prop to the Transaction component."
    );
  }
  if (calls && contracts) {
    throw new Error(
      "Transaction: Only one of contracts or calls can be provided as a prop to the Transaction component."
    );
  }
  const {
    status: statusSendCalls,
    sendCallsAsync,
    reset: resetSendCalls
  } = useSendCalls2({
    setLifecycleStatus,
    setTransactionId
  });
  const {
    status: statusSendCall,
    sendCallAsync,
    data: singleTransactionHash,
    reset: resetSendCall
  } = useSendCall({
    setLifecycleStatus,
    transactionHashList
  });
  const transactionStatus = (0, import_react3.useMemo)(() => {
    var _a;
    if ((_a = walletCapabilities[Capabilities.AtomicBatch]) == null ? void 0 : _a.supported) {
      return statusSendCalls;
    }
    return statusSendCall;
  }, [statusSendCall, statusSendCalls, walletCapabilities]);
  const capabilities = (0, import_react3.useMemo)(() => {
    if (isSponsored && paymaster) {
      return {
        paymasterService: { url: paymaster },
        // this needs to be below so devs can override default paymaster
        // with their personal paymaster in production playgroundd
        ...transactionCapabilities
      };
    }
    return transactionCapabilities;
  }, [isSponsored, paymaster, transactionCapabilities]);
  const sendWalletTransactions = useSendWalletTransactions({
    capabilities,
    sendCallAsync,
    sendCallsAsync,
    walletCapabilities
  });
  const { transactionHash: batchedTransactionHash, status: callStatus } = useCallsStatus2({
    setLifecycleStatus,
    transactionId
  });
  const { data: receipt } = useWaitForTransactionReceipt({
    hash: singleTransactionHash || batchedTransactionHash
  });
  const { sendAnalytics } = useAnalytics();
  const handleAnalytics = (0, import_react3.useCallback)(
    (event, data) => {
      sendAnalytics(event, data);
    },
    [sendAnalytics]
  );
  (0, import_react3.useEffect)(() => {
    setErrorMessage("");
    if (lifecycleStatus.statusName === "error") {
      setErrorMessage(lifecycleStatus.statusData.message);
      setErrorCode(lifecycleStatus.statusData.code);
      onError == null ? void 0 : onError(lifecycleStatus.statusData);
    }
    if (lifecycleStatus.statusName === "transactionLegacyExecuted") {
      setTransactionHashList(lifecycleStatus.statusData.transactionHashList);
    }
    if (lifecycleStatus.statusName === "success") {
      onSuccess == null ? void 0 : onSuccess({
        transactionReceipts: lifecycleStatus.statusData.transactionReceipts
      });
    }
    onStatus == null ? void 0 : onStatus(lifecycleStatus);
  }, [
    onError,
    onStatus,
    onSuccess,
    lifecycleStatus,
    lifecycleStatus.statusData,
    // Keep statusData, so that the effect runs when it changes
    lifecycleStatus.statusName
    // Keep statusName, so that the effect runs when it changes
  ]);
  (0, import_react3.useEffect)(() => {
    if (transactionStatus === "pending") {
      setLifecycleStatus({
        statusName: "transactionPending",
        statusData: null
      });
    }
  }, [transactionStatus]);
  (0, import_react3.useEffect)(() => {
    if (!receipt) {
      return;
    }
    setLifecycleStatus({
      statusName: "success",
      statusData: {
        transactionReceipts: [receipt]
      }
    });
    if (resetAfter) {
      const timeoutId = setTimeout(() => {
        setErrorMessage("");
        setErrorCode("");
        setIsToastVisible(false);
        setTransactionId("");
        setTransactionHashList([]);
        setTransactionCount(void 0);
        resetSendCalls();
        resetSendCall();
      }, resetAfter);
      return () => clearTimeout(timeoutId);
    }
  }, [receipt, resetAfter, resetSendCalls, resetSendCall]);
  const getTransactionLegacyReceipts = (0, import_react3.useCallback)(async () => {
    const receipts = [];
    for (const hash of transactionHashList) {
      try {
        const txnReceipt = await waitForTransactionReceipt(config, {
          hash,
          chainId
        });
        receipts.push(txnReceipt);
      } catch (err) {
        setLifecycleStatus({
          statusName: "error",
          statusData: {
            code: "TmTPc01",
            // Transaction module TransactionProvider component 01 error
            error: JSON.stringify(err),
            message: GENERIC_ERROR_MESSAGE
          }
        });
      }
    }
    setLifecycleStatus({
      statusName: "success",
      statusData: {
        transactionReceipts: receipts
      }
    });
  }, [chainId, config, transactionHashList]);
  (0, import_react3.useEffect)(() => {
    if (!transactions || transactionHashList.length !== transactionCount || transactionCount < 2) {
      return;
    }
    getTransactionLegacyReceipts();
  }, [
    transactions,
    transactionCount,
    transactionHashList,
    getTransactionLegacyReceipts
  ]);
  const switchChain2 = (0, import_react3.useCallback)(
    async (targetChainId) => {
      if (targetChainId && account.chainId !== targetChainId) {
        await switchChainAsync({ chainId: targetChainId });
      }
    },
    [account.chainId, switchChainAsync]
  );
  const buildTransaction = (0, import_react3.useCallback)(async () => {
    setLifecycleStatus({
      statusName: "buildingTransaction",
      statusData: null
    });
    try {
      handleAnalytics(TransactionEvent.TransactionInitiated, {
        address: account.address
      });
      const resolvedTransactions = await (typeof transactions === "function" ? transactions() : Promise.resolve(transactions));
      setTransactionCount(resolvedTransactions == null ? void 0 : resolvedTransactions.length);
      return resolvedTransactions;
    } catch (err) {
      handleAnalytics(TransactionEvent.TransactionFailure, {
        error: err.message,
        metadata: {
          code: errorCode
        }
      });
      setLifecycleStatus({
        statusName: "error",
        statusData: {
          code: "TmTPc04",
          // Transaction module TransactionProvider component 04 error
          error: JSON.stringify(err),
          message: "Error building transactions"
        }
      });
      return void 0;
    }
  }, [transactions, handleAnalytics, account.address, errorCode]);
  const handleSubmit = (0, import_react3.useCallback)(async () => {
    setErrorMessage("");
    setIsToastVisible(true);
    try {
      await switchChain2(chainId);
      const resolvedTransactions = await buildTransaction();
      await sendWalletTransactions(resolvedTransactions);
    } catch (err) {
      const errorMessage2 = isUserRejectedRequestError(err) ? "Request denied." : GENERIC_ERROR_MESSAGE;
      setLifecycleStatus({
        statusName: "error",
        statusData: {
          code: "TmTPc03",
          // Transaction module TransactionProvider component 03 error
          error: JSON.stringify(err),
          message: errorMessage2
        }
      });
    }
  }, [buildTransaction, chainId, sendWalletTransactions, switchChain2]);
  const value = useValue({
    chainId,
    errorCode,
    errorMessage,
    isLoading: callStatus === "PENDING",
    isToastVisible,
    lifecycleStatus,
    onSubmit: handleSubmit,
    paymasterUrl: getPaymasterUrl(capabilities),
    receipt,
    setIsToastVisible,
    setLifecycleStatus,
    setTransactionId,
    transactions,
    transactionId,
    transactionHash: singleTransactionHash || batchedTransactionHash,
    transactionCount
  });
  (0, import_react3.useEffect)(() => {
    if (!receipt) {
      return;
    }
    if (receipt.status === "success") {
      handleAnalytics(TransactionEvent.TransactionSuccess, {
        paymaster: Boolean(isSponsored && paymaster),
        address: account.address,
        transactionHash: receipt.transactionHash
      });
    } else {
      handleAnalytics(TransactionEvent.TransactionFailure, {
        error: "Transaction failed",
        metadata: {
          code: errorCode
        }
      });
    }
  }, [
    receipt,
    handleAnalytics,
    isSponsored,
    paymaster,
    account.address,
    errorCode
  ]);
  return (0, import_jsx_runtime.jsx)(TransactionContext.Provider, { value, children });
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionButton.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/core/network/getChainExplorer.js
var chainExplorerMap = {
  [baseSepolia.id]: "https://sepolia.basescan.org",
  [base.id]: "https://basescan.org",
  [arbitrum.id]: "https://arbiscan.io",
  [arbitrumSepolia.id]: "https://sepolia.arbiscan.io",
  [optimism.id]: "https://optimistic.etherscan.io",
  [optimismSepolia.id]: "https://sepolia-optimism.etherscan.io/",
  [polygon.id]: "https://polygonscan.com",
  [polygonMumbai.id]: "https://mumbai.polygonscan.com",
  [mainnet.id]: "https://etherscan.io",
  [sepolia.id]: "https://sepolia.etherscan.io"
};
function getChainExplorer(chainId) {
  if (!chainId) {
    return "https://basescan.org";
  }
  return chainExplorerMap[chainId] ?? "https://basescan.org";
}

// node_modules/@coinbase/onchainkit/dist/internal/components/Spinner.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function Spinner({ className }) {
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      className: "flex h-full items-center justify-center",
      "data-testid": "ockSpinner",
      children: (0, import_jsx_runtime2.jsx)(
        "div",
        {
          className: cn(
            "animate-spin border-2 border-gray-200 border-t-3",
            "rounded-full border-t-gray-400 px-2.5 py-2.5",
            className
          )
        }
      )
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/transaction/utils/isSpinnerDisplayed.js
function isSpinnerDisplayed({
  errorMessage,
  hasReceipt,
  isInProgress,
  transactionHash,
  transactionId
}) {
  const isWaitingForReceipt = transactionId || transactionHash;
  if (hasReceipt || errorMessage) {
    return false;
  }
  if (isInProgress || isWaitingForReceipt) {
    return true;
  }
  return false;
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionButton.js
function TransactionButton({
  className,
  disabled = false,
  text: idleText = "Transact",
  errorOverride,
  successOverride,
  pendingOverride
}) {
  var _a, _b;
  const {
    chainId,
    errorMessage,
    isLoading,
    lifecycleStatus,
    onSubmit,
    receipt,
    transactions,
    transactionCount,
    transactionHash,
    transactionId
  } = useTransactionContext();
  const { address } = useAccount();
  const accountChainId = chainId ?? useChainId();
  const isLegacyTransactionInProgress = lifecycleStatus.statusName === "transactionLegacyExecuted" && transactionCount !== ((_b = (_a = lifecycleStatus == null ? void 0 : lifecycleStatus.statusData) == null ? void 0 : _a.transactionHashList) == null ? void 0 : _b.length);
  const isInProgress = lifecycleStatus.statusName === "buildingTransaction" || lifecycleStatus.statusName === "transactionPending" || isLegacyTransactionInProgress || isLoading;
  const isMissingProps = !transactions || !address;
  const isWaitingForReceipt = !!transactionId || !!transactionHash;
  const isDisabled = !receipt && (isInProgress || isMissingProps || isWaitingForReceipt || disabled);
  const displayPendingState = isSpinnerDisplayed({
    errorMessage,
    hasReceipt: !!receipt,
    isInProgress,
    transactionHash,
    transactionId
  });
  const { errorText, successText, pendingContent } = (0, import_react4.useMemo)(() => {
    const successText2 = (successOverride == null ? void 0 : successOverride.text) ?? "View transaction";
    const errorText2 = (errorOverride == null ? void 0 : errorOverride.text) ?? "Try again";
    const pendingContent2 = (pendingOverride == null ? void 0 : pendingOverride.text) ?? (0, import_jsx_runtime3.jsx)(Spinner, {});
    return { successText: successText2, errorText: errorText2, pendingContent: pendingContent2 };
  }, [errorOverride, pendingOverride, successOverride]);
  const defaultSuccessHandler = (0, import_react4.useCallback)(() => {
    if (receipt && transactionId && transactionHash && chainId && address) {
      const url = new URL("https://wallet.coinbase.com/assets/transactions");
      url.searchParams.set("contentParams[txHash]", transactionHash);
      url.searchParams.set("contentParams[chainId]", JSON.stringify(chainId));
      url.searchParams.set("contentParams[fromAddress]", address);
      return window.open(url, "_blank", "noopener,noreferrer");
    }
    const chainExplorer = getChainExplorer(accountChainId);
    return window.open(
      `${chainExplorer}/tx/${transactionHash}`,
      "_blank",
      "noopener,noreferrer"
    );
  }, [
    address,
    chainId,
    receipt,
    transactionId,
    transactionHash,
    accountChainId
  ]);
  const successHandler = (0, import_react4.useCallback)(() => {
    var _a2;
    if ((successOverride == null ? void 0 : successOverride.onClick) && receipt) {
      return (_a2 = successOverride == null ? void 0 : successOverride.onClick) == null ? void 0 : _a2.call(successOverride, receipt);
    }
    defaultSuccessHandler();
  }, [defaultSuccessHandler, successOverride, receipt]);
  const errorHandler = (0, import_react4.useCallback)(() => {
    var _a2;
    if (errorOverride == null ? void 0 : errorOverride.onClick) {
      return (_a2 = errorOverride == null ? void 0 : errorOverride.onClick) == null ? void 0 : _a2.call(errorOverride);
    }
    return onSubmit();
  }, [errorOverride, onSubmit]);
  const buttonContent = (0, import_react4.useMemo)(() => {
    if (receipt) {
      return successText;
    }
    if (errorMessage) {
      return errorText;
    }
    if (displayPendingState) {
      return pendingContent;
    }
    return idleText;
  }, [
    displayPendingState,
    errorMessage,
    errorText,
    idleText,
    pendingContent,
    receipt,
    successText
  ]);
  const handleSubmit = (0, import_react4.useCallback)(() => {
    if (receipt) {
      successHandler();
    } else if (errorMessage) {
      errorHandler();
    } else {
      onSubmit();
    }
  }, [errorMessage, errorHandler, onSubmit, receipt, successHandler]);
  return (0, import_jsx_runtime3.jsx)(
    "button",
    {
      className: cn(
        pressable.primary,
        border.radius,
        "w-full rounded-xl",
        "px-4 py-3 font-medium leading-6",
        isDisabled && pressable.disabled,
        text.headline,
        color.inverse,
        className
      ),
      onClick: handleSubmit,
      type: "button",
      disabled: isDisabled,
      "data-testid": "ockTransactionButton_Button",
      children: buttonContent
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionToastAction.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/transaction/hooks/useGetTransactionToastAction.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
function useGetTransactionToastAction() {
  const { chainId, errorMessage, onSubmit, transactionHash, transactionId } = useTransactionContext();
  const accountChainId = chainId ?? useChainId();
  const { showCallsStatus: showCallsStatus2 } = useShowCallsStatus();
  return (0, import_react5.useMemo)(() => {
    const chainExplorer = getChainExplorer(accountChainId);
    let actionElement = null;
    if (transactionHash) {
      actionElement = (0, import_jsx_runtime4.jsx)(
        "a",
        {
          href: `${chainExplorer}/tx/${transactionHash}`,
          target: "_blank",
          rel: "noreferrer",
          children: (0, import_jsx_runtime4.jsx)("span", { className: cn(text.label1, color.primary), children: "View transaction" })
        }
      );
    }
    if (transactionId) {
      actionElement = (0, import_jsx_runtime4.jsx)(
        "button",
        {
          onClick: () => showCallsStatus2({ id: transactionId }),
          type: "button",
          children: (0, import_jsx_runtime4.jsx)("span", { className: cn(text.label1, color.primary), children: "View transaction" })
        }
      );
    }
    if (errorMessage) {
      actionElement = (0, import_jsx_runtime4.jsx)("button", { type: "button", onClick: onSubmit, children: (0, import_jsx_runtime4.jsx)("span", { className: cn(text.label1, color.primary), children: "Try again" }) });
    }
    return { actionElement };
  }, [
    accountChainId,
    errorMessage,
    onSubmit,
    showCallsStatus2,
    transactionHash,
    transactionId
  ]);
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionToastAction.js
function TransactionToastAction({
  className
}) {
  const { actionElement } = useGetTransactionToastAction();
  return (0, import_jsx_runtime5.jsx)("div", { className: cn(text.label1, "text-nowrap", className), children: actionElement });
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionToastIcon.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/svg/errorSvg.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var ErrorSvg = ({ fill = "#E11D48" }) => (0, import_jsx_runtime6.jsxs)(
  "svg",
  {
    "aria-label": "ock-errorSvg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "data-testid": "ock-errorSvg",
    children: [
      (0, import_jsx_runtime6.jsx)("title", { children: "Error" }),
      (0, import_jsx_runtime6.jsx)(
        "path",
        {
          d: "M8 16C12.4183 16 16 12.4183 16 8C16 3.58171 12.4183 0 8 0C3.58172 0 0 3.58171 0 8C0 12.4183 3.58172 16 8 16ZM11.7576 5.0909L8.84853 8L11.7576 10.9091L10.9091 11.7576L8 8.84851L5.09093 11.7576L4.2424 10.9091L7.15147 8L4.2424 5.0909L5.09093 4.24239L8 7.15145L10.9091 4.24239L11.7576 5.0909Z",
          fill
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/internal/svg/successSvg.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var SuccessSvg = ({ fill = "#65A30D" }) => (0, import_jsx_runtime7.jsxs)(
  "svg",
  {
    "aria-label": "ock-successSvg",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "data-testid": "ock-successSvg",
    children: [
      (0, import_jsx_runtime7.jsx)("title", { children: "Success SVG" }),
      (0, import_jsx_runtime7.jsx)(
        "path",
        {
          d: "M8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C12.42 16 16 12.42 16 8C16 3.58 12.42 0 8 0ZM6.72667 11.5333L3.73333 8.54L4.67333 7.6L6.72667 9.65333L11.44 4.94L12.38 5.88L6.72667 11.5333Z",
          fill
        }
      )
    ]
  }
);

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionToastIcon.js
function TransactionToastIcon({ className }) {
  const { errorMessage, isLoading, receipt, transactionHash, transactionId } = useTransactionContext();
  const isInProgress = isLoading || !!transactionId || !!transactionHash;
  const icon2 = (0, import_react6.useMemo)(() => {
    if (receipt) {
      return (0, import_jsx_runtime8.jsx)(SuccessSvg, {});
    }
    if (errorMessage) {
      return (0, import_jsx_runtime8.jsx)(ErrorSvg, {});
    }
    if (isInProgress) {
      return (0, import_jsx_runtime8.jsx)(Spinner, { className: "px-1.5 py-1.5" });
    }
    return null;
  }, [isInProgress, errorMessage, receipt]);
  if (!icon2) {
    return null;
  }
  return (0, import_jsx_runtime8.jsx)("div", { className: cn(text.label2, className), children: icon2 });
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionToastLabel.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/transaction/hooks/useGetTransactionToastLabel.js
var import_react7 = __toESM(require_react(), 1);
function useGetTransactionToastLabel() {
  const {
    errorMessage,
    isLoading,
    lifecycleStatus,
    receipt,
    transactionHash,
    transactionId
  } = useTransactionContext();
  const isInProgress = isLoading || !!transactionId || !!transactionHash;
  const isBuildingTransaction = lifecycleStatus.statusName === "buildingTransaction";
  return (0, import_react7.useMemo)(() => {
    let label = "";
    let labelClassName = color.foregroundMuted;
    if (isBuildingTransaction) {
      label = "Building transaction";
    }
    if (isInProgress) {
      label = "Transaction in progress";
    }
    if (receipt) {
      label = "Successful";
    }
    if (errorMessage) {
      label = "Something went wrong";
      labelClassName = color.error;
    }
    return { label, labelClassName };
  }, [errorMessage, isBuildingTransaction, isInProgress, receipt]);
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionToastLabel.js
function TransactionToastLabel({
  className
}) {
  const { label } = useGetTransactionToastLabel();
  return (0, import_jsx_runtime9.jsx)("div", { className: cn(text.label1, "text-nowrap", className), children: (0, import_jsx_runtime9.jsx)("p", { className: color.foreground, children: label }) });
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionToast.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/components/Toast.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/svg/closeSvg.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
function CloseSvg({ className = icon.foreground }) {
  return (0, import_jsx_runtime10.jsxs)(
    "svg",
    {
      "aria-label": "ock-closeSvg",
      width: "12",
      height: "12",
      viewBox: "0 0 16 16",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      className,
      children: [
        (0, import_jsx_runtime10.jsx)("title", { children: "Close" }),
        (0, import_jsx_runtime10.jsx)("path", { d: "M2.14921 1L1 2.1492L6.8508 8L1 13.8508L2.1492 15L8 9.1492L13.8508 15L15 13.8508L9.14921 8L15 2.1492L13.8508 1L8 6.8508L2.14921 1Z" })
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/internal/utils/getToastPosition.js
function getToastPosition(position) {
  if (position === "bottom-right") {
    return "bottom-5 left-3/4";
  }
  if (position === "top-right") {
    return "top-[100px] left-3/4";
  }
  if (position === "top-center") {
    return "top-[100px] left-2/4";
  }
  return "bottom-5 left-2/4";
}

// node_modules/@coinbase/onchainkit/dist/internal/components/Toast.js
var defaultAnimationByPosition = {
  "top-center": "animate-enterDown",
  "top-right": "animate-enterRight",
  "bottom-center": "animate-enterUp",
  "bottom-right": "animate-enterRight"
};
function Toast({
  className,
  durationMs = 5e3,
  startTimeout = true,
  position = "bottom-center",
  animation,
  isVisible,
  onClose,
  children
}) {
  const positionClass = getToastPosition(position);
  const animationClass = animation ?? defaultAnimationByPosition[position];
  (0, import_react8.useEffect)(() => {
    if (startTimeout) {
      const timer = setTimeout(() => {
        if (isVisible) {
          onClose();
        }
      }, durationMs);
      return () => {
        if (timer) {
          clearTimeout(timer);
        }
      };
    }
  }, [durationMs, isVisible, onClose, startTimeout]);
  if (!isVisible) {
    return null;
  }
  return (0, import_jsx_runtime11.jsx)(
    "div",
    {
      className: cn("-translate-x-2/4 fixed z-20", positionClass),
      "data-testid": "ockToastContainer",
      children: (0, import_jsx_runtime11.jsxs)(
        "div",
        {
          className: cn(
            background.default,
            "flex items-center justify-between rounded-lg",
            "p-2 shadow-[0px_8px_24px_0px_rgba(0,0,0,0.12)]",
            animationClass,
            className
          ),
          "data-testid": "ockToast",
          children: [
            (0, import_jsx_runtime11.jsx)("div", { className: "flex items-center gap-4 p-2", children }),
            (0, import_jsx_runtime11.jsx)(
              "button",
              {
                className: "p-2",
                onClick: onClose,
                type: "button",
                "data-testid": "ockCloseButton",
                children: (0, import_jsx_runtime11.jsx)(CloseSvg, {})
              }
            )
          ]
        }
      )
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionToast.js
function TransactionToast({
  children,
  className,
  durationMs = 5e3,
  position = "bottom-center"
}) {
  const {
    errorMessage,
    isLoading,
    isToastVisible,
    receipt,
    setIsToastVisible,
    transactionHash,
    transactionId
  } = useTransactionContext();
  const closeToast = (0, import_react9.useCallback)(() => {
    setIsToastVisible(false);
  }, [setIsToastVisible]);
  const isInProgress = !receipt && !isLoading && !transactionHash && !errorMessage && !transactionId;
  if (!isToastVisible || isInProgress) {
    return null;
  }
  return (0, import_jsx_runtime12.jsx)(
    Toast,
    {
      position,
      className,
      durationMs,
      isVisible: isToastVisible,
      onClose: closeToast,
      startTimeout: !!receipt || !!errorMessage,
      children: children ?? (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
        (0, import_jsx_runtime12.jsx)(TransactionToastIcon, {}),
        (0, import_jsx_runtime12.jsx)(TransactionToastLabel, {}),
        (0, import_jsx_runtime12.jsx)(TransactionToastAction, {})
      ] })
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/Transaction.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useIsMounted.js
var import_react10 = __toESM(require_react(), 1);
function useIsMounted() {
  const [isMounted, setIsMounted] = (0, import_react10.useState)(false);
  (0, import_react10.useEffect)(() => {
    setIsMounted(true);
  }, []);
  return isMounted;
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/Transaction.js
function Transaction({
  calls,
  capabilities,
  chainId,
  className,
  children,
  contracts,
  disabled = false,
  isSponsored,
  onError,
  onStatus,
  onSuccess,
  resetAfter
}) {
  const isMounted = useIsMounted();
  const componentTheme = useTheme();
  const { chain } = useOnchainKit();
  if (!isMounted) {
    return (0, import_jsx_runtime13.jsx)(
      "div",
      {
        className: cn(componentTheme, "flex w-full flex-col gap-2", className)
      }
    );
  }
  const accountChainId = chainId ? chainId : chain.id;
  return (0, import_jsx_runtime13.jsx)(
    TransactionProvider,
    {
      calls,
      capabilities,
      chainId: accountChainId,
      contracts,
      isSponsored,
      onError,
      onStatus,
      onSuccess,
      resetAfter,
      children: (0, import_jsx_runtime13.jsx)(
        "div",
        {
          className: cn(componentTheme, "flex w-full flex-col gap-2", className),
          children: children ?? (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, { children: [
            (0, import_jsx_runtime13.jsx)(TransactionButton, { disabled }),
            (0, import_jsx_runtime13.jsx)(TransactionToast, {})
          ] })
        }
      )
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionStatusAction.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/transaction/hooks/useGetTransactionStatusAction.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
function useGetTransactionStatusAction() {
  const { chainId, receipt, transactionHash, transactionId } = useTransactionContext();
  const accountChainId = chainId ?? useChainId();
  const { showCallsStatus: showCallsStatus2 } = useShowCallsStatus();
  return (0, import_react11.useMemo)(() => {
    const chainExplorer = getChainExplorer(accountChainId);
    let actionElement = null;
    if (transactionHash) {
      actionElement = (0, import_jsx_runtime14.jsx)(
        "a",
        {
          href: `${chainExplorer}/tx/${transactionHash}`,
          target: "_blank",
          rel: "noreferrer",
          children: (0, import_jsx_runtime14.jsx)("span", { className: cn(text.label1, color.primary), children: "View transaction" })
        }
      );
    }
    if (transactionId) {
      actionElement = (0, import_jsx_runtime14.jsx)(
        "button",
        {
          onClick: () => showCallsStatus2({ id: transactionId }),
          type: "button",
          children: (0, import_jsx_runtime14.jsx)("span", { className: cn(text.label1, color.primary), children: "View transaction" })
        }
      );
    }
    if (receipt) {
      actionElement = null;
    }
    return { actionElement };
  }, [
    accountChainId,
    receipt,
    showCallsStatus2,
    transactionHash,
    transactionId
  ]);
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionStatusAction.js
function TransactionStatusAction({
  className
}) {
  const { actionElement } = useGetTransactionStatusAction();
  return (0, import_jsx_runtime15.jsx)("div", { className: cn(text.label2, "min-w-[70px]", className), children: actionElement });
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionStatusLabel.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);

// node_modules/@coinbase/onchainkit/dist/transaction/hooks/useGetTransactionStatusLabel.js
var import_react12 = __toESM(require_react(), 1);
function useGetTransactionStatusLabel() {
  const {
    errorMessage,
    isLoading,
    receipt,
    lifecycleStatus,
    transactionHash,
    transactionId
  } = useTransactionContext();
  const isInProgress = isLoading || !!transactionId || !!transactionHash;
  const isPending = lifecycleStatus.statusName === "transactionPending";
  const isBuildingTransaction = lifecycleStatus.statusName === "buildingTransaction";
  return (0, import_react12.useMemo)(() => {
    let label = "";
    let labelClassName = color.foregroundMuted;
    if (isBuildingTransaction) {
      label = "Building transaction...";
    }
    if (isPending) {
      label = "Confirm in wallet.";
    }
    if (isInProgress) {
      label = "Transaction in progress...";
    }
    if (receipt) {
      label = "Successful";
    }
    if (errorMessage) {
      label = errorMessage;
      labelClassName = color.error;
    }
    return { label, labelClassName };
  }, [errorMessage, isBuildingTransaction, isInProgress, isPending, receipt]);
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionStatusLabel.js
function TransactionStatusLabel({
  className
}) {
  const { label, labelClassName } = useGetTransactionStatusLabel();
  return (0, import_jsx_runtime16.jsx)("div", { className: cn(text.label2, className), children: (0, import_jsx_runtime16.jsx)("p", { className: labelClassName, children: label }) });
}

// node_modules/@coinbase/onchainkit/dist/transaction/components/TransactionStatus.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
function TransactionStatus({
  children,
  className
}) {
  return (0, import_jsx_runtime17.jsx)("div", { className: cn("flex justify-between", className), children: children ?? (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [
    (0, import_jsx_runtime17.jsx)(TransactionStatusLabel, {}),
    (0, import_jsx_runtime17.jsx)(TransactionStatusAction, {})
  ] }) });
}

export {
  useIsMounted,
  getChainExplorer,
  Spinner,
  useAnalytics,
  useCapabilitiesSafe,
  GENERIC_ERROR_MESSAGE,
  normalizeStatus,
  normalizeTransactionId,
  isUserRejectedRequestError,
  useTransactionContext,
  TransactionButton,
  CloseSvg,
  Toast,
  TransactionToastAction,
  ErrorSvg,
  SuccessSvg,
  TransactionToastIcon,
  TransactionToastLabel,
  TransactionToast,
  Transaction,
  TransactionStatusAction,
  TransactionStatusLabel,
  TransactionStatus
};
//# sourceMappingURL=chunk-KRBD3JGL.js.map
