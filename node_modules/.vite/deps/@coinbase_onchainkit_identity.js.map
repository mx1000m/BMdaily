{
  "version": 3,
  "sources": ["../../@coinbase/onchainkit/src/identity/components/IdentityCard.tsx", "../../@coinbase/onchainkit/src/identity/utils/getAvatars.ts", "../../@coinbase/onchainkit/src/identity/utils/getNames.ts", "../../@coinbase/onchainkit/src/identity/hooks/useAddress.ts", "../../@coinbase/onchainkit/src/identity/hooks/useAddresses.ts", "../../@coinbase/onchainkit/src/identity/hooks/useAvatars.ts", "../../@coinbase/onchainkit/src/identity/hooks/useNames.ts"],
  "sourcesContent": ["'use client';\nimport type { Address, Chain } from 'viem';\nimport { Address as AddressComponent } from './Address';\nimport { Avatar } from './Avatar';\nimport { Badge } from './Badge';\nimport { Identity } from './Identity';\nimport { Name } from './Name';\nimport { Socials } from './Socials';\n\nimport { background, border, cn } from '../../styles/theme';\n\ntype IdentityCardReact = {\n  address?: Address;\n  chain?: Chain;\n  className?: string;\n  schemaId?: Address | null;\n  /** Controls whether the badge shows a tooltip on hover. When true, the tooltip displays the attestation's name. When a string is provided, that text overrides the default display. Defaults to false. */\n  badgeTooltip?: boolean | string;\n};\n\nexport function IdentityCard({\n  address,\n  chain,\n  className = '',\n  schemaId,\n  badgeTooltip,\n}: IdentityCardReact) {\n  return (\n    <Identity\n      address={address}\n      chain={chain}\n      className={cn(\n        border.radius,\n        border.lineDefault,\n        background.default,\n        'items-left flex min-w-[300px] p-4',\n        className,\n      )}\n      schemaId={schemaId}\n    >\n      <Avatar />\n      <Name>\n        <Badge tooltip={badgeTooltip} />\n      </Name>\n      <AddressComponent />\n      <Socials />\n    </Identity>\n  );\n}\n", "import { getChainPublicClient } from '@/core/network/getChainPublicClient';\nimport { isBase } from '@/core/utils/isBase';\nimport { isEthereum } from '@/core/utils/isEthereum';\nimport type {\n  Basename,\n  GetAvatarReturnType,\n  GetAvatars,\n} from '@/identity/types';\nimport { mainnet } from 'viem/chains';\nimport { normalize } from 'viem/ens';\nimport { RESOLVER_ADDRESSES_BY_CHAIN_ID } from '../constants';\nimport { getBaseDefaultProfilePicture } from './getBaseDefaultProfilePicture';\nimport { isBasename } from './isBasename';\n\n/**\n * An asynchronous function to fetch multiple Basenames or Ethereum Name Service (ENS)\n * avatars for a given array of ENS names in a single batch request.\n * It returns an array of avatar URLs in the same order as the input names.\n */\nexport const getAvatars = async ({\n  ensNames,\n  chain = mainnet,\n}: GetAvatars): Promise<GetAvatarReturnType[]> => {\n  if (!ensNames || ensNames.length === 0) {\n    return [];\n  }\n\n  const chainIsBase = isBase({ chainId: chain.id });\n  const chainIsEthereum = isEthereum({ chainId: chain.id });\n  const chainSupportsUniversalResolver = chainIsEthereum || chainIsBase;\n\n  if (!chainSupportsUniversalResolver) {\n    return Promise.reject(\n      'ChainId not supported, avatar resolution is only supported on Ethereum and Base.',\n    );\n  }\n\n  const results: GetAvatarReturnType[] = Array(ensNames.length).fill(null);\n\n  // Categorize names by type for optimized processing\n  const basenameIndices: number[] = [];\n  const normalIndices: number[] = [];\n\n  ensNames.forEach((name, index) => {\n    if (isBasename(name)) {\n      basenameIndices.push(index);\n    } else {\n      normalIndices.push(index);\n    }\n  });\n\n  // Process Base avatars\n  if (chainIsBase && basenameIndices.length > 0) {\n    const client = getChainPublicClient(chain);\n\n    try {\n      // Create batch of calls for Base avatars with individual error handling\n      const baseAvatarPromises = basenameIndices.map((index) =>\n        client\n          .getEnsAvatar({\n            name: normalize(ensNames[index]),\n            universalResolverAddress: RESOLVER_ADDRESSES_BY_CHAIN_ID[chain.id],\n          })\n          .catch((error) => {\n            console.error(\n              `Error resolving Base avatar for ${ensNames[index]}:`,\n              error,\n            );\n            return null; // Return null for failed resolutions\n          }),\n      );\n\n      const baseAvatarResults = await Promise.all(baseAvatarPromises);\n\n      baseAvatarResults.forEach((avatar, i) => {\n        const originalIndex = basenameIndices[i];\n        if (avatar) {\n          results[originalIndex] = avatar;\n        }\n      });\n    } catch (error) {\n      console.error('Error resolving Base avatars in batch:', error);\n    }\n  }\n\n  // Process mainnet avatars\n  const fallbackClient = getChainPublicClient(mainnet);\n\n  try {\n    // Create batch of ENS avatar resolution calls with individual error handling\n    const ensAvatarPromises = ensNames.map((name, index) => {\n      // Skip if we already have a result\n      if (results[index] !== null) {\n        return Promise.resolve(null);\n      }\n      return fallbackClient\n        .getEnsAvatar({\n          name: normalize(name),\n        })\n        .catch((error) => {\n          console.error(`Error resolving ENS avatar for ${name}:`, error);\n          return null; // Return null for failed resolutions\n        });\n    });\n\n    // Execute all ENS avatar resolution calls\n    const ensAvatarResults = await Promise.all(ensAvatarPromises);\n\n    // Update results with ENS avatars\n    ensAvatarResults.forEach((avatar, index) => {\n      if (avatar && results[index] === null) {\n        results[index] = avatar;\n      }\n    });\n  } catch (error) {\n    console.error('Error resolving ENS avatars in batch:', error);\n  }\n\n  // Apply default Base profile pictures for basenames that don't have avatars\n  for (const index of basenameIndices) {\n    if (results[index] === null) {\n      results[index] = getBaseDefaultProfilePicture(\n        ensNames[index] as Basename,\n      );\n    }\n  }\n\n  return results;\n};\n", "import type { Basename, GetNameReturnType, GetNames } from '@/identity/types';\nimport { mainnet } from 'viem/chains';\nimport { getChainPublicClient } from '../../core/network/getChainPublicClient';\nimport { isBase } from '../../core/utils/isBase';\nimport { isEthereum } from '../../core/utils/isEthereum';\nimport L2ResolverAbi from '../abis/L2ResolverAbi';\nimport { RESOLVER_ADDRESSES_BY_CHAIN_ID } from '../constants';\nimport { convertReverseNodeToBytes } from './convertReverseNodeToBytes';\nimport { getAddresses } from './getAddresses';\n\n/**\n * An asynchronous function to fetch multiple Basenames or Ethereum Name Service (ENS)\n * names for a given array of Ethereum addresses in a single batch request.\n * It returns an array of ENS names in the same order as the input addresses.\n */\n// eslint-disable-next-line complexity\nexport const getNames = async ({\n  addresses,\n  chain = mainnet,\n}: GetNames): Promise<GetNameReturnType[]> => {\n  if (!addresses || addresses.length === 0) {\n    return [];\n  }\n\n  const chainIsBase = isBase({ chainId: chain.id });\n  const chainIsEthereum = isEthereum({ chainId: chain.id });\n  const chainSupportsUniversalResolver = chainIsEthereum || chainIsBase;\n\n  if (!chainSupportsUniversalResolver) {\n    return Promise.reject(\n      'ChainId not supported, name resolution is only supported on Ethereum and Base.',\n    );\n  }\n\n  const client = getChainPublicClient(chain);\n  const results: GetNameReturnType[] = Array(addresses.length).fill(null);\n\n  if (chainIsBase) {\n    try {\n      // Create batch of calls for the multicall contract\n      const calls = addresses.map((address) => ({\n        address: RESOLVER_ADDRESSES_BY_CHAIN_ID[chain.id],\n        abi: L2ResolverAbi,\n        functionName: 'name',\n        args: [convertReverseNodeToBytes(address, chain.id)],\n      }));\n\n      const batchResults = await client.multicall({\n        contracts: calls,\n        allowFailure: true,\n      });\n\n      // Collect all successfully resolved basenames for batch verification\n      const basenamesWithIndices: Array<{ basename: Basename; index: number }> =\n        [];\n\n      for (let index = 0; index < batchResults.length; index++) {\n        const result = batchResults[index];\n        if (result.status === 'success' && result.result) {\n          const basename = result.result as Basename;\n          basenamesWithIndices.push({ basename, index });\n        }\n      }\n\n      if (basenamesWithIndices.length > 0) {\n        try {\n          // Verify basenames with forward resolution using batch processing\n          const basenames = basenamesWithIndices.map(\n            ({ basename }) => basename,\n          );\n          const resolvedAddresses = await getAddresses({\n            names: basenames,\n          });\n\n          // Update results with validated basenames\n          for (let i = 0; i < basenamesWithIndices.length; i++) {\n            const { basename, index } = basenamesWithIndices[i];\n            const resolvedAddress = resolvedAddresses[i];\n\n            if (\n              resolvedAddress &&\n              resolvedAddress.toLowerCase() === addresses[index].toLowerCase()\n            ) {\n              results[index] = basename;\n            }\n          }\n        } catch (error) {\n          console.error(\n            'Error during batch basename forward resolution verification:',\n            error,\n          );\n        }\n      }\n\n      // If we have all results, return them\n      if (results.every((result) => result !== null)) {\n        return results;\n      }\n    } catch (error) {\n      console.error('Error resolving Base names in batch:', error);\n    }\n  }\n\n  // Default fallback to mainnet\n  // ENS resolution is not well-supported on Base, so want to ensure that we fall back to mainnet\n  const fallbackClient = getChainPublicClient(mainnet);\n\n  // For addresses that don't have a result yet, try ENS resolution on mainnet\n  const unresolvedIndices = results\n    .map((result, index) => (result === null ? index : -1))\n    .filter((index) => index !== -1);\n\n  if (unresolvedIndices.length > 0) {\n    try {\n      const ensPromises = unresolvedIndices.map((index) =>\n        fallbackClient\n          .getEnsName({\n            address: addresses[index],\n          })\n          .catch((error) => {\n            console.error(\n              `Error resolving ENS name for ${addresses[index]}:`,\n              error,\n            );\n            return null; // Return null for failed resolutions\n          }),\n      );\n\n      const ensResults = await Promise.all(ensPromises);\n\n      // Collect all successfully resolved ENS names for batch verification\n      const ensNamesWithIndices: Array<{\n        ensName: string;\n        originalIndex: number;\n      }> = [];\n\n      for (let i = 0; i < ensResults.length; i++) {\n        const ensName = ensResults[i];\n        const originalIndex = unresolvedIndices[i];\n\n        if (ensName) {\n          ensNamesWithIndices.push({ ensName, originalIndex });\n        }\n      }\n\n      if (ensNamesWithIndices.length > 0) {\n        try {\n          // Verify ENS names with forward resolution using batch processing\n          const ensNames = ensNamesWithIndices.map(({ ensName }) => ensName);\n          const resolvedAddresses = await getAddresses({\n            names: ensNames,\n          });\n\n          // Update results with validated ENS names\n          for (let i = 0; i < ensNamesWithIndices.length; i++) {\n            const { ensName, originalIndex } = ensNamesWithIndices[i];\n            const resolvedAddress = resolvedAddresses[i];\n\n            if (\n              resolvedAddress &&\n              resolvedAddress.toLowerCase() ===\n                addresses[originalIndex].toLowerCase()\n            ) {\n              results[originalIndex] = ensName;\n            }\n          }\n        } catch (error) {\n          console.error(\n            'Error during batch ENS forward resolution verification:',\n            error,\n          );\n        }\n      }\n    } catch (error) {\n      console.error('Error resolving ENS names in batch:', error);\n    }\n  }\n\n  return results;\n};\n", "import type {\n  GetAddressReturnType,\n  UseAddressOptions,\n  UseQueryOptions,\n} from '@/identity/types';\nimport { getAddress } from '@/identity/utils/getAddress';\nimport { DEFAULT_QUERY_OPTIONS } from '@/internal/constants';\nimport { useQuery } from '@tanstack/react-query';\nimport { mainnet } from 'viem/chains';\n\nexport const useAddress = (\n  { name, chain = mainnet }: UseAddressOptions,\n  queryOptions?: UseQueryOptions<GetAddressReturnType>,\n) => {\n  const queryKey = ['useAddress', name, chain.id];\n\n  return useQuery<GetAddressReturnType>({\n    queryKey,\n    queryFn: () => getAddress({ name, chain }),\n    enabled: !!name,\n    ...DEFAULT_QUERY_OPTIONS,\n    // Use cacheTime as gcTime for backward compatibility\n    gcTime: queryOptions?.cacheTime,\n    ...queryOptions,\n  });\n};\n", "import { getAddresses } from '@/identity/utils/getAddresses';\nimport { DEFAULT_QUERY_OPTIONS } from '@/internal/constants';\nimport { useQuery } from '@tanstack/react-query';\nimport type {\n  GetAddressReturnType,\n  UseAddressesOptions,\n  UseQueryOptions,\n} from '../types';\n\n/**\n * A React hook that leverages the `@tanstack/react-query` for fetching and optionally caching\n * multiple Ethereum addresses from ENS names or Basenames in a single batch request.\n */\nexport const useAddresses = (\n  { names }: UseAddressesOptions,\n  queryOptions?: UseQueryOptions<GetAddressReturnType[]>,\n) => {\n  const namesKey = names.join(',');\n  const queryKey = ['useAddresses', namesKey];\n\n  return useQuery<GetAddressReturnType[]>({\n    queryKey,\n    queryFn: () => getAddresses({ names }),\n    enabled: !!names.length,\n    ...DEFAULT_QUERY_OPTIONS,\n    // Use cacheTime as gcTime for backward compatibility\n    gcTime: queryOptions?.cacheTime,\n    ...queryOptions,\n  });\n};\n", "import { getAvatars } from '@/identity/utils/getAvatars';\nimport { DEFAULT_QUERY_OPTIONS } from '@/internal/constants';\nimport { useQuery } from '@tanstack/react-query';\nimport { mainnet } from 'viem/chains';\nimport type {\n  GetAvatarReturnType,\n  UseAvatarsOptions,\n  UseQueryOptions,\n} from '../types';\n\n/**\n * A React hook that leverages the `@tanstack/react-query` for fetching and optionally caching\n * multiple Basenames or ENS avatars in a single batch request.\n */\nexport const useAvatars = (\n  { ensNames, chain = mainnet }: UseAvatarsOptions,\n  queryOptions?: UseQueryOptions<GetAvatarReturnType[]>,\n) => {\n  const namesKey = ensNames.join(',');\n  const queryKey = ['useAvatars', namesKey, chain.id];\n\n  return useQuery<GetAvatarReturnType[]>({\n    queryKey,\n    queryFn: () => getAvatars({ ensNames, chain }),\n    enabled: !!ensNames.length,\n    ...DEFAULT_QUERY_OPTIONS,\n    gcTime: queryOptions?.cacheTime,\n    ...queryOptions,\n  });\n};\n", "import { getNames } from '@/identity/utils/getNames';\nimport { DEFAULT_QUERY_OPTIONS } from '@/internal/constants';\nimport { useQuery } from '@tanstack/react-query';\nimport { mainnet } from 'viem/chains';\nimport type {\n  GetNameReturnType,\n  UseNamesOptions,\n  UseQueryOptions,\n} from '../types';\n\n/**\n * A React hook that leverages the `@tanstack/react-query` for fetching and optionally caching\n * multiple Basenames or ENS names in a single batch request.\n */\nexport const useNames = (\n  { addresses, chain = mainnet }: UseNamesOptions,\n  queryOptions?: UseQueryOptions<GetNameReturnType[]>,\n) => {\n  const addressesKey = addresses.join(',');\n  const queryKey = ['useNames', addressesKey, chain.id];\n\n  return useQuery<GetNameReturnType[]>({\n    queryKey,\n    queryFn: () => getNames({ addresses, chain }),\n    enabled: !!addresses.length,\n    ...DEFAULT_QUERY_OPTIONS,\n    // Use cacheTime as gcTime for backward compatibility\n    gcTime: queryOptions?.cacheTime,\n    ...queryOptions,\n  });\n};\n"],
  "mappings": "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",
  "names": ["AddressComponent"]
}
