import {
  baseAccount,
  coinbaseWallet
} from "./chunk-QARRE4OG.js";
import "./chunk-7AO4FBFE.js";
import "./chunk-FR7KSM5Q.js";
import "./chunk-ANJCMEYS.js";
import {
  COINBASE_VERIFIED_ACCOUNT_SCHEMA_ID,
  isBase,
  isEthereum
} from "./chunk-53EOX26Q.js";
import {
  DEFAULT_PRIVACY_URL,
  DEFAULT_TERMS_URL,
  ErrorEvent,
  clientMetaManager,
  dist_default,
  sendAnalyticsPayload,
  version
} from "./chunk-2YAJQTYP.js";
import "./chunk-T6DGKBO6.js";
import "./chunk-PGZVUQA3.js";
import "./chunk-64SD37WF.js";
import "./chunk-W54Q24SD.js";
import {
  OnchainKitContext,
  getOnchainKitConfig,
  setOnchainKitConfig,
  useOnchainKit
} from "./chunk-D3A4POTL.js";
import "./chunk-PD5WAEH4.js";
import {
  WagmiProvider,
  WagmiProviderNotFoundError,
  useConfig
} from "./chunk-5WJVUKOY.js";
import {
  ChainNotConfiguredError,
  cookieStorage,
  createConfig,
  createConnector,
  createStorage
} from "./chunk-XNSTLHSV.js";
import "./chunk-EDDRWZDP.js";
import "./chunk-RFGAV5EN.js";
import "./chunk-LWLUVSGB.js";
import {
  http
} from "./chunk-TE2KEVK5.js";
import {
  QueryClient,
  QueryClientProvider,
  useQueryClient
} from "./chunk-SYWZVBRI.js";
import {
  base,
  baseSepolia
} from "./chunk-73ADTDOL.js";
import "./chunk-IFKI425K.js";
import "./chunk-4BVTQS2C.js";
import "./chunk-2YXMKDAC.js";
import "./chunk-SBWNL4JE.js";
import {
  SwitchChainError,
  fromHex,
  getAddress,
  numberToHex
} from "./chunk-IR6OLA2F.js";
import "./chunk-NSDO7JQ5.js";
import "./chunk-CVLLH7Z4.js";
import {
  require_jsx_runtime
} from "./chunk-TLG7CTPL.js";
import {
  require_react
} from "./chunk-VT65UQWK.js";
import {
  __toESM
} from "./chunk-ONY6HBPH.js";

// node_modules/@coinbase/onchainkit/dist/OnchainKitProvider-C29aWJbj.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/DefaultOnchainKitProviders.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/core/createWagmiConfig.js
var createWagmiConfig = ({
  apiKey,
  appName,
  appLogoUrl,
  connectors = [
    coinbaseWallet({
      appName,
      appLogoUrl,
      preference: "all"
    })
  ]
}) => {
  return createConfig({
    chains: [base, baseSepolia],
    connectors,
    storage: createStorage({
      storage: cookieStorage
    }),
    ssr: true,
    transports: {
      [base.id]: apiKey ? http(`https://api.developer.coinbase.com/rpc/v1/base/${apiKey}`) : http(),
      [baseSepolia.id]: apiKey ? http(
        `https://api.developer.coinbase.com/rpc/v1/base-sepolia/${apiKey}`
      ) : http()
    }
  });
};

// node_modules/@coinbase/onchainkit/dist/internal/hooks/useProviderDependencies.js
var import_react = __toESM(require_react(), 1);
function useProviderDependencies() {
  let providedWagmiConfig = null;
  let providedQueryClient = null;
  try {
    providedWagmiConfig = useConfig();
  } catch (error) {
    if (!(error instanceof WagmiProviderNotFoundError)) {
      console.error("Error fetching WagmiProvider, using default:", error);
    }
  }
  try {
    providedQueryClient = useQueryClient();
  } catch (error) {
    if (!(error.message === "No QueryClient set, use QueryClientProvider to set one")) {
      console.error("Error fetching QueryClient, using default:", error);
    }
  }
  return (0, import_react.useMemo)(() => {
    return {
      providedWagmiConfig,
      providedQueryClient
    };
  }, [providedWagmiConfig, providedQueryClient]);
}

// node_modules/@coinbase/onchainkit/dist/DefaultOnchainKitProviders.js
function DefaultOnchainKitProviders({
  children,
  connectors
}) {
  const { providedWagmiConfig, providedQueryClient } = useProviderDependencies();
  return (0, import_jsx_runtime.jsx)(
    WagmiProviderWithDefault,
    {
      providedWagmiConfig,
      connectors,
      children: (0, import_jsx_runtime.jsx)(QueryClientProviderWithDefault, { providedQueryClient, children })
    }
  );
}
function WagmiProviderWithDefault({
  children,
  providedWagmiConfig,
  connectors
}) {
  const onchainKitConfig = useOnchainKit();
  const prevConnectorsRef = (0, import_react2.useRef)(connectors);
  const getWagmiConfig = (0, import_react2.useCallback)(() => {
    var _a, _b, _c, _d;
    if (providedWagmiConfig) return providedWagmiConfig;
    const appName = ((_b = (_a = onchainKitConfig.config) == null ? void 0 : _a.appearance) == null ? void 0 : _b.name) ?? void 0;
    const appLogoUrl = ((_d = (_c = onchainKitConfig.config) == null ? void 0 : _c.appearance) == null ? void 0 : _d.logo) ?? void 0;
    return createWagmiConfig({
      apiKey: onchainKitConfig.apiKey ?? void 0,
      appName,
      appLogoUrl,
      connectors: connectors ?? [
        baseAccount({
          appName,
          appLogoUrl
        })
      ]
    });
  }, [
    onchainKitConfig.apiKey,
    onchainKitConfig.config,
    connectors,
    providedWagmiConfig
  ]);
  const [config, setConfig] = (0, import_react2.useState)(() => {
    return getWagmiConfig();
  });
  (0, import_react2.useEffect)(() => {
    if (prevConnectorsRef.current !== connectors) {
      setConfig(getWagmiConfig());
      prevConnectorsRef.current = connectors;
    }
  }, [connectors, getWagmiConfig]);
  if (providedWagmiConfig) {
    return children;
  }
  return (0, import_jsx_runtime.jsx)(WagmiProvider, { config, children });
}
function QueryClientProviderWithDefault({
  children,
  providedQueryClient
}) {
  const queryClient = (0, import_react2.useMemo)(() => {
    return providedQueryClient || new QueryClient();
  }, [providedQueryClient]);
  if (providedQueryClient) return children;
  return (0, import_jsx_runtime.jsx)(QueryClientProvider, { client: queryClient, children });
}

// node_modules/@coinbase/onchainkit/dist/OnchainKitProviderBoundary.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var OnchainKitProviderBoundary = class extends import_react3.Component {
  constructor() {
    super(...arguments);
    this.state = {
      error: null
    };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  componentDidCatch(error, errorInfo) {
    console.error("Uncaught error:", error, errorInfo);
    sendAnalyticsPayload(ErrorEvent.ComponentError, {
      component: "OnchainKitProviderBoundary",
      error: error.message,
      metadata: {
        message: error.message,
        stack: errorInfo.componentStack
      }
    });
  }
  render() {
    if (this.state.error) {
      if (this.props.fallback) {
        const Fallback = this.props.fallback;
        return (0, import_jsx_runtime2.jsx)(Fallback, { error: this.state.error });
      }
      return (0, import_jsx_runtime2.jsx)("h1", { children: "Sorry, we had an unhandled error" });
    }
    return this.props.children;
  }
};

// node_modules/@coinbase/onchainkit/dist/internal/utils/checkHashLength.js
function checkHashLength(hash, length) {
  return new RegExp(`^0x[a-fA-F0-9]{${length}}$`).test(hash);
}

// node_modules/@coinbase/onchainkit/dist/utils/crypto.js
var getRandomValues = (size) => {
  const array = new Uint8Array(size);
  crypto.getRandomValues(array);
  return array;
};
var generateUUIDWithInsecureFallback = () => {
  if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  const bytes = getRandomValues(16);
  return bytes[0].toString(16).padStart(2, "0") + bytes[1].toString(16).padStart(2, "0") + bytes[2].toString(16).padStart(2, "0") + bytes[3].toString(16).padStart(2, "0") + "-" + bytes[4].toString(16).padStart(2, "0") + bytes[5].toString(16).padStart(2, "0") + "-" + (bytes[6] & 15 | 64).toString(16).padStart(2, "0") + // UUID version 4
  bytes[7].toString(16).padStart(2, "0") + "-" + (bytes[8] & 63 | 128).toString(16).padStart(2, "0") + // UUID variant
  bytes[9].toString(16).padStart(2, "0") + "-" + bytes[10].toString(16).padStart(2, "0") + bytes[11].toString(16).padStart(2, "0") + bytes[12].toString(16).padStart(2, "0") + bytes[13].toString(16).padStart(2, "0") + bytes[14].toString(16).padStart(2, "0") + bytes[15].toString(16).padStart(2, "0");
};

// node_modules/@farcaster/miniapp-wagmi-connector/dist/connector.js
farcasterMiniApp.type = "farcasterMiniApp";
var accountsChanged;
var chainChanged;
var disconnect;
function farcasterMiniApp() {
  return createConnector((config) => ({
    id: "farcaster",
    name: "Farcaster",
    rdns: "xyz.farcaster.MiniAppWallet",
    icon: "https://imagedelivery.net/BXluQx4ige9GuW0Ia56BHw/055c25d6-7fe7-4a49-abf9-49772021cf00/original",
    type: farcasterMiniApp.type,
    async connect({ chainId } = {}) {
      var _a, _b;
      const provider = await this.getProvider();
      const accounts = await provider.request({
        method: "eth_requestAccounts"
      });
      let targetChainId = chainId;
      if (!targetChainId) {
        const state = await ((_a = config.storage) == null ? void 0 : _a.getItem("state")) ?? {};
        const isChainSupported = config.chains.some((x) => x.id === state.chainId);
        if (isChainSupported)
          targetChainId = state.chainId;
        else
          targetChainId = (_b = config.chains[0]) == null ? void 0 : _b.id;
      }
      if (!targetChainId)
        throw new Error("No chains found on connector.");
      if (!accountsChanged) {
        accountsChanged = this.onAccountsChanged.bind(this);
        provider.on("accountsChanged", accountsChanged);
      }
      if (!chainChanged) {
        chainChanged = this.onChainChanged.bind(this);
        provider.on("chainChanged", chainChanged);
      }
      if (!disconnect) {
        disconnect = this.onDisconnect.bind(this);
        provider.on("disconnect", disconnect);
      }
      let currentChainId = await this.getChainId();
      if (targetChainId && currentChainId !== targetChainId) {
        const chain = await this.switchChain({ chainId: targetChainId });
        currentChainId = chain.id;
      }
      return {
        accounts: accounts.map((x) => getAddress(x)),
        chainId: currentChainId
      };
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect) {
        provider.removeListener("disconnect", disconnect);
        disconnect = void 0;
      }
    },
    async getAccounts() {
      const provider = await this.getProvider();
      const accounts = await provider.request({
        method: "eth_accounts"
      });
      return accounts.map((x) => getAddress(x));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const hexChainId = await provider.request({ method: "eth_chainId" });
      return fromHex(hexChainId, "number");
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ chainId }) {
      const provider = await this.getProvider();
      const chain = config.chains.find((x) => x.id === chainId);
      if (!chain) {
        throw new SwitchChainError(new ChainNotConfiguredError());
      }
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: numberToHex(chainId) }]
      });
      config.emitter.emit("change", { chainId });
      return chain;
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect() {
      config.emitter.emit("disconnect");
    },
    async getProvider() {
      return dist_default.wallet.ethProvider;
    }
  }));
}
var farcasterFrame = farcasterMiniApp;
farcasterFrame.type = "farcasterFrame";

// node_modules/@coinbase/onchainkit/dist/minikit/components/AutoConnect.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);

// node_modules/@coinbase/onchainkit/dist/OnchainKitProvider-C29aWJbj.js
var emptyContext = {};
var MiniKitContext = (0, import_react5.createContext)(emptyContext);
function OnchainKitProvider({
  address,
  analytics,
  apiKey,
  chain,
  children,
  config,
  projectId,
  rpcUrl,
  schemaId
}) {
  var _a;
  if (schemaId && !checkHashLength(schemaId, 64)) {
    throw Error('EAS schemaId must be 64 characters prefixed with "0x"');
  }
  const sessionId = (0, import_react5.useMemo)(() => generateUUIDWithInsecureFallback(), []);
  const isMiniKit = !!((_a = (0, import_react5.useContext)(MiniKitContext)) == null ? void 0 : _a.__isMiniKit);
  (0, import_react5.useEffect)(() => {
    if (clientMetaManager.isInitialized()) return;
    clientMetaManager.init({ isMiniKit });
  }, [isMiniKit]);
  const value = (0, import_react5.useMemo)(() => {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    const defaultPaymasterUrl = apiKey ? `https://api.developer.coinbase.com/rpc/v1/${chain.name.replace(" ", "-").toLowerCase()}/${apiKey}` : null;
    const onchainKitConfig = {
      address: address ?? null,
      apiKey: apiKey ?? null,
      chain,
      config: {
        analytics: analytics ?? true,
        analyticsUrl: (config == null ? void 0 : config.analyticsUrl) ?? null,
        appearance: {
          name: ((_a2 = config == null ? void 0 : config.appearance) == null ? void 0 : _a2.name) ?? "Dapp",
          logo: ((_b = config == null ? void 0 : config.appearance) == null ? void 0 : _b.logo) ?? "",
          mode: ((_c = config == null ? void 0 : config.appearance) == null ? void 0 : _c.mode) ?? "auto",
          theme: ((_d = config == null ? void 0 : config.appearance) == null ? void 0 : _d.theme) ?? "default"
        },
        paymaster: (config == null ? void 0 : config.paymaster) || defaultPaymasterUrl,
        wallet: {
          display: ((_e = config == null ? void 0 : config.wallet) == null ? void 0 : _e.display) ?? "classic",
          preference: ((_f = config == null ? void 0 : config.wallet) == null ? void 0 : _f.preference) ?? "all",
          signUpEnabled: ((_g = config == null ? void 0 : config.wallet) == null ? void 0 : _g.signUpEnabled) ?? true,
          termsUrl: ((_h = config == null ? void 0 : config.wallet) == null ? void 0 : _h.termsUrl) || DEFAULT_TERMS_URL,
          privacyUrl: ((_i = config == null ? void 0 : config.wallet) == null ? void 0 : _i.privacyUrl) || DEFAULT_PRIVACY_URL,
          supportedWallets: {
            rabby: ((_k = (_j = config == null ? void 0 : config.wallet) == null ? void 0 : _j.supportedWallets) == null ? void 0 : _k.rabby) ?? false,
            trust: ((_m = (_l = config == null ? void 0 : config.wallet) == null ? void 0 : _l.supportedWallets) == null ? void 0 : _m.trust) ?? false,
            frame: ((_o = (_n = config == null ? void 0 : config.wallet) == null ? void 0 : _n.supportedWallets) == null ? void 0 : _o.frame) ?? false
          }
        }
      },
      projectId: projectId ?? null,
      rpcUrl: rpcUrl ?? null,
      schemaId: schemaId ?? COINBASE_VERIFIED_ACCOUNT_SCHEMA_ID,
      sessionId
    };
    setOnchainKitConfig(onchainKitConfig);
    return onchainKitConfig;
  }, [
    address,
    analytics,
    apiKey,
    chain,
    config,
    projectId,
    rpcUrl,
    schemaId,
    sessionId
  ]);
  return (0, import_jsx_runtime4.jsx)(OnchainKitContext.Provider, { value, children: (0, import_jsx_runtime4.jsx)(DefaultOnchainKitProviders, { children: (0, import_jsx_runtime4.jsx)(OnchainKitProviderBoundary, { children }) }) });
}
export {
  OnchainKitProvider,
  getOnchainKitConfig,
  isBase,
  isEthereum,
  setOnchainKitConfig,
  useOnchainKit,
  version
};
//# sourceMappingURL=@coinbase_onchainkit.js.map
