{
  "version": 3,
  "sources": ["../../@noble/curves/src/nist.ts", "../../@noble/curves/src/p256.ts", "../../@noble/curves/src/abstract/bls.ts", "../../@noble/curves/src/abstract/tower.ts", "../../@noble/curves/src/bls12-381.ts"],
  "sourcesContent": ["/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256, sha384, sha512 } from '@noble/hashes/sha2.js';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\nimport { createHasher, type H2CHasher } from './abstract/hash-to-curve.ts';\nimport { Field } from './abstract/modular.ts';\nimport {\n  mapToCurveSimpleSWU,\n  type WeierstrassOpts,\n  type WeierstrassPointCons,\n} from './abstract/weierstrass.ts';\n\n// p = 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n - 1n\n// a = Fp256.create(BigInt('-3'));\nconst p256_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\n\n// p = 2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n\nconst p384_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt(\n    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'\n  ),\n  n: BigInt(\n    '0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'\n  ),\n  h: BigInt(1),\n  a: BigInt(\n    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc'\n  ),\n  b: BigInt(\n    '0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef'\n  ),\n  Gx: BigInt(\n    '0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'\n  ),\n  Gy: BigInt(\n    '0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'\n  ),\n};\n\n// p = 2n**521n - 1n\nconst p521_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt(\n    '0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n  ),\n  n: BigInt(\n    '0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'\n  ),\n  h: BigInt(1),\n  a: BigInt(\n    '0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc'\n  ),\n  b: BigInt(\n    '0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'\n  ),\n  Gx: BigInt(\n    '0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'\n  ),\n  Gy: BigInt(\n    '0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'\n  ),\n};\n\nconst Fp256 = Field(p256_CURVE.p);\nconst Fp384 = Field(p384_CURVE.p);\nconst Fp521 = Field(p521_CURVE.p);\ntype SwuOpts = {\n  A: bigint;\n  B: bigint;\n  Z: bigint;\n};\nfunction createSWU(Point: WeierstrassPointCons<bigint>, opts: SwuOpts) {\n  const map = mapToCurveSimpleSWU(Point.Fp, opts);\n  return (scalars: bigint[]) => map(scalars[0]);\n}\n\n/** NIST P256 (aka secp256r1, prime256v1) curve, ECDSA and ECDH methods. */\nexport const p256: CurveFnWithCreate = createCurve(\n  { ...p256_CURVE, Fp: Fp256, lowS: false },\n  sha256\n);\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */\nexport const p256_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() => {\n  return createHasher(\n    p256.Point,\n    createSWU(p256.Point, {\n      A: p256_CURVE.a,\n      B: p256_CURVE.b,\n      Z: p256.Point.Fp.create(BigInt('-10')),\n    }),\n    {\n      DST: 'P256_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n      p: p256_CURVE.p,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  );\n})();\n\n// export const p256_oprf: OPRF = createORPF({\n//   name: 'P256-SHA256',\n//   Point: p256.Point,\n//   hash: sha256,\n//   hashToGroup: p256_hasher.hashToCurve,\n//   hashToScalar: p256_hasher.hashToScalar,\n// });\n\n/** NIST P384 (aka secp384r1) curve, ECDSA and ECDH methods. */\nexport const p384: CurveFnWithCreate = createCurve(\n  { ...p384_CURVE, Fp: Fp384, lowS: false },\n  sha384\n);\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */\nexport const p384_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() => {\n  return createHasher(\n    p384.Point,\n    createSWU(p384.Point, {\n      A: p384_CURVE.a,\n      B: p384_CURVE.b,\n      Z: p384.Point.Fp.create(BigInt('-12')),\n    }),\n    {\n      DST: 'P384_XMD:SHA-384_SSWU_RO_',\n      encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',\n      p: p384_CURVE.p,\n      m: 1,\n      k: 192,\n      expand: 'xmd',\n      hash: sha384,\n    }\n  );\n})();\n\n// export const p384_oprf: OPRF = createORPF({\n//   name: 'P384-SHA384',\n//   Point: p384.Point,\n//   hash: sha384,\n//   hashToGroup: p384_hasher.hashToCurve,\n//   hashToScalar: p384_hasher.hashToScalar,\n// });\n\n// const Fn521 = Field(p521_CURVE.n, { allowedScalarLengths: [65, 66] });\n/** NIST P521 (aka secp521r1) curve, ECDSA and ECDH methods. */\nexport const p521: CurveFnWithCreate = createCurve(\n  { ...p521_CURVE, Fp: Fp521, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] },\n  sha512\n);\n\n/** @deprecated use `p256` for consistency with `p256_hasher` */\nexport const secp256r1: typeof p256 = p256;\n/** @deprecated use `p384` for consistency with `p384_hasher` */\nexport const secp384r1: typeof p384 = p384;\n/** @deprecated use `p521` for consistency with `p521_hasher` */\nexport const secp521r1: typeof p521 = p521;\n\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */\nexport const p521_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() => {\n  return createHasher(\n    p521.Point,\n    createSWU(p521.Point, {\n      A: p521_CURVE.a,\n      B: p521_CURVE.b,\n      Z: p521.Point.Fp.create(BigInt('-4')),\n    }),\n    {\n      DST: 'P521_XMD:SHA-512_SSWU_RO_',\n      encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',\n      p: p521_CURVE.p,\n      m: 1,\n      k: 256,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  );\n})();\n\n// export const p521_oprf: OPRF = createORPF({\n//   name: 'P521-SHA512',\n//   Point: p521.Point,\n//   hash: sha512,\n//   hashToGroup: p521_hasher.hashToCurve,\n//   hashToScalar: p521_hasher.hashToScalar, // produces L=98 just like in RFC\n// });\n", "/**\n * NIST secp256r1 aka p256.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type H2CMethod } from './abstract/hash-to-curve.ts';\nimport { p256_hasher, p256 as p256n } from './nist.ts';\n/** @deprecated use `import { p256 } from '@noble/curves/nist.js';` */\nexport const p256: typeof p256n = p256n;\n/** @deprecated use `import { p256 } from '@noble/curves/nist.js';` */\nexport const secp256r1: typeof p256n = p256n;\n/** @deprecated use `import { p256_hasher } from '@noble/curves/nist.js';` */\nexport const hashToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.hashToCurve)();\n/** @deprecated use `import { p256_hasher } from '@noble/curves/nist.js';` */\nexport const encodeToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() => p256_hasher.encodeToCurve)();\n", "/**\n * BLS != BLS.\n * The file implements BLS (Boneh-Lynn-Shacham) signatures.\n * Used in both BLS (Barreto-Lynn-Scott) and BN (Barreto-Naehrig)\n * families of pairing-friendly curves.\n * Consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\n * Pairing is used to aggregate and verify signatures.\n * There are two modes of operation:\n * - Long signatures:  X-byte keys + 2X-byte sigs (G1 keys + G2 sigs).\n * - Short signatures: 2X-byte keys + X-byte sigs (G2 keys + G1 sigs).\n * @module\n **/\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes,\n  ensureBytes,\n  memoized,\n  randomBytes,\n  type CHash,\n  type Hex,\n  type PrivKey,\n} from '../utils.ts';\nimport { normalizeZ } from './curve.ts';\nimport {\n  createHasher,\n  type H2CHasher,\n  type H2CHashOpts,\n  type H2COpts,\n  type H2CPointConstructor,\n  type htfBasicOpts,\n  type MapToCurve,\n} from './hash-to-curve.ts';\nimport { getMinHashLength, mapHashToField, type IField } from './modular.ts';\nimport type { Fp12, Fp12Bls, Fp2, Fp2Bls, Fp6Bls } from './tower.ts';\nimport {\n  _normFnElement,\n  weierstrassPoints,\n  type CurvePointsRes,\n  type CurvePointsType,\n  type WeierstrassPoint,\n  type WeierstrassPointCons,\n} from './weierstrass.ts';\n\ntype Fp = bigint; // Can be different field?\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\nexport type TwistType = 'multiplicative' | 'divisive';\n\nexport type ShortSignatureCoder<Fp> = {\n  fromBytes(bytes: Uint8Array): WeierstrassPoint<Fp>;\n  fromHex(hex: Hex): WeierstrassPoint<Fp>;\n  toBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n  toHex(point: WeierstrassPoint<Fp>): string;\n  /** @deprecated use `toBytes` */\n  toRawBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n};\n\nexport type SignatureCoder<Fp> = {\n  fromBytes(bytes: Uint8Array): WeierstrassPoint<Fp>;\n  fromHex(hex: Hex): WeierstrassPoint<Fp>;\n  toBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n  toHex(point: WeierstrassPoint<Fp>): string;\n  /** @deprecated use `toBytes` */\n  toRawBytes(point: WeierstrassPoint<Fp>): Uint8Array;\n};\n\nexport type BlsFields = {\n  Fp: IField<Fp>;\n  Fr: IField<bigint>;\n  Fp2: Fp2Bls;\n  Fp6: Fp6Bls;\n  Fp12: Fp12Bls;\n};\n\nexport type PostPrecomputePointAddFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2\n) => { Rx: Fp2; Ry: Fp2; Rz: Fp2 };\nexport type PostPrecomputeFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2,\n  pointAdd: PostPrecomputePointAddFn\n) => void;\nexport type BlsPairing = {\n  Fp12: Fp12Bls;\n  calcPairingPrecomputes: (p: WeierstrassPoint<Fp2>) => Precompute;\n  millerLoopBatch: (pairs: [Precompute, Fp, Fp][]) => Fp12;\n  pairing: (P: WeierstrassPoint<Fp>, Q: WeierstrassPoint<Fp2>, withFinalExponent?: boolean) => Fp12;\n  pairingBatch: (\n    pairs: { g1: WeierstrassPoint<Fp>; g2: WeierstrassPoint<Fp2> }[],\n    withFinalExponent?: boolean\n  ) => Fp12;\n};\n// TODO: replace CurveType with this? It doesn't contain r however and has postPrecompute\nexport type BlsPairingParams = {\n  // NOTE: MSB is always ignored and used as marker for length,\n  // otherwise leading zeros will be lost.\n  // Can be different from 'X' (seed) param!\n  ateLoopSize: bigint;\n  xNegative: boolean;\n  twistType: TwistType; // BLS12-381: Multiplicative, BN254: Divisive\n  // This is super ugly hack for untwist point in BN254 after miller loop\n  postPrecompute?: PostPrecomputeFn;\n};\nexport type CurveType = {\n  G1: CurvePointsType<Fp> & {\n    ShortSignature: SignatureCoder<Fp>;\n    mapToCurve: MapToCurve<Fp>;\n    htfDefaults: H2COpts;\n  };\n  G2: CurvePointsType<Fp2> & {\n    Signature: SignatureCoder<Fp2>;\n    mapToCurve: MapToCurve<Fp2>;\n    htfDefaults: H2COpts;\n  };\n  fields: BlsFields;\n  params: {\n    // NOTE: MSB is always ignored and used as marker for length,\n    // otherwise leading zeros will be lost.\n    // Can be different from 'X' (seed) param!\n    ateLoopSize: BlsPairingParams['ateLoopSize'];\n    xNegative: BlsPairingParams['xNegative'];\n    r: bigint; // TODO: remove\n    twistType: BlsPairingParams['twistType']; // BLS12-381: Multiplicative, BN254: Divisive\n  };\n  htfDefaults: H2COpts;\n  hash: CHash; // Because we need outputLen for DRBG\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n  // This is super ugly hack for untwist point in BN254 after miller loop\n  postPrecompute?: PostPrecomputeFn;\n};\n\ntype PrecomputeSingle = [Fp2, Fp2, Fp2][];\ntype Precompute = PrecomputeSingle[];\n\n/**\n * BLS consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n */\nexport interface BLSCurvePair {\n  longSignatures: BLSSigs<bigint, Fp2>;\n  shortSignatures: BLSSigs<Fp2, bigint>;\n  millerLoopBatch: BlsPairing['millerLoopBatch'];\n  pairing: BlsPairing['pairing'];\n  pairingBatch: BlsPairing['pairingBatch'];\n  G1: { Point: WeierstrassPointCons<bigint> } & H2CHasher<Fp>;\n  G2: { Point: WeierstrassPointCons<Fp2> } & H2CHasher<Fp2>;\n  fields: {\n    Fp: IField<Fp>;\n    Fp2: Fp2Bls;\n    Fp6: Fp6Bls;\n    Fp12: Fp12Bls;\n    Fr: IField<bigint>;\n  };\n  utils: {\n    randomSecretKey: () => Uint8Array;\n    /** @deprecated use randomSecretKey */\n    randomPrivateKey: () => Uint8Array;\n    calcPairingPrecomputes: BlsPairing['calcPairingPrecomputes'];\n  };\n}\n\nexport type CurveFn = BLSCurvePair & {\n  /** @deprecated use `longSignatures.getPublicKey` */\n  getPublicKey: (secretKey: PrivKey) => Uint8Array;\n  /** @deprecated use `shortSignatures.getPublicKey` */\n  getPublicKeyForShortSignatures: (secretKey: PrivKey) => Uint8Array;\n  /** @deprecated use `longSignatures.sign` */\n  sign: {\n    (message: Hex, secretKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (\n      message: WeierstrassPoint<Fp2>,\n      secretKey: PrivKey,\n      htfOpts?: htfBasicOpts\n    ): WeierstrassPoint<Fp2>;\n  };\n  /** @deprecated use `shortSignatures.sign` */\n  signShortSignature: {\n    (message: Hex, secretKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (\n      message: WeierstrassPoint<Fp>,\n      secretKey: PrivKey,\n      htfOpts?: htfBasicOpts\n    ): WeierstrassPoint<Fp>;\n  };\n  /** @deprecated use `longSignatures.verify` */\n  verify: (\n    signature: Hex | WeierstrassPoint<Fp2>,\n    message: Hex | WeierstrassPoint<Fp2>,\n    publicKey: Hex | WeierstrassPoint<Fp>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  /** @deprecated use `shortSignatures.verify` */\n  verifyShortSignature: (\n    signature: Hex | WeierstrassPoint<Fp>,\n    message: Hex | WeierstrassPoint<Fp>,\n    publicKey: Hex | WeierstrassPoint<Fp2>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  verifyBatch: (\n    signature: Hex | WeierstrassPoint<Fp2>,\n    messages: (Hex | WeierstrassPoint<Fp2>)[],\n    publicKeys: (Hex | WeierstrassPoint<Fp>)[],\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  /** @deprecated use `longSignatures.aggregatePublicKeys` */\n  aggregatePublicKeys: {\n    (publicKeys: Hex[]): Uint8Array;\n    (publicKeys: WeierstrassPoint<Fp>[]): WeierstrassPoint<Fp>;\n  };\n  /** @deprecated use `longSignatures.aggregateSignatures` */\n  aggregateSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: WeierstrassPoint<Fp2>[]): WeierstrassPoint<Fp2>;\n  };\n  /** @deprecated use `shortSignatures.aggregateSignatures` */\n  aggregateShortSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: WeierstrassPoint<Fp>[]): WeierstrassPoint<Fp>;\n  };\n  G1: CurvePointsRes<Fp> & H2CHasher<Fp>;\n  G2: CurvePointsRes<Fp2> & H2CHasher<Fp2>;\n  /** @deprecated use `longSignatures.Signature` */\n  Signature: SignatureCoder<Fp2>;\n  /** @deprecated use `shortSignatures.Signature` */\n  ShortSignature: ShortSignatureCoder<Fp>;\n  params: {\n    ateLoopSize: bigint;\n    r: bigint;\n    twistType: TwistType;\n    /** @deprecated */\n    G1b: bigint;\n    /** @deprecated */\n    G2b: Fp2;\n  };\n};\n\ntype BLSInput = Hex | Uint8Array;\nexport interface BLSSigs<P, S> {\n  getPublicKey(secretKey: PrivKey): WeierstrassPoint<P>;\n  sign(hashedMessage: WeierstrassPoint<S>, secretKey: PrivKey): WeierstrassPoint<S>;\n  verify(\n    signature: WeierstrassPoint<S> | BLSInput,\n    message: WeierstrassPoint<S>,\n    publicKey: WeierstrassPoint<P> | BLSInput\n  ): boolean;\n  verifyBatch: (\n    signature: WeierstrassPoint<S> | BLSInput,\n    messages: WeierstrassPoint<S>[],\n    publicKeys: (WeierstrassPoint<P> | BLSInput)[]\n  ) => boolean;\n  aggregatePublicKeys(publicKeys: (WeierstrassPoint<P> | BLSInput)[]): WeierstrassPoint<P>;\n  aggregateSignatures(signatures: (WeierstrassPoint<S> | BLSInput)[]): WeierstrassPoint<S>;\n  hash(message: Uint8Array, DST?: string | Uint8Array, hashOpts?: H2CHashOpts): WeierstrassPoint<S>;\n  Signature: SignatureCoder<S>;\n}\n\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a: bigint) {\n  const res = [];\n  // a>1 because of marker bit\n  for (; a > _1n; a >>= _1n) {\n    if ((a & _1n) === _0n) res.unshift(0);\n    else if ((a & _3n) === _3n) {\n      res.unshift(-1);\n      a += _1n;\n    } else res.unshift(1);\n  }\n  return res;\n}\n\nfunction aNonEmpty(arr: any[]) {\n  if (!Array.isArray(arr) || arr.length === 0) throw new Error('expected non-empty array');\n}\n\n// This should be enough for bn254, no need to export full stuff?\nfunction createBlsPairing(\n  fields: BlsFields,\n  G1: WeierstrassPointCons<Fp>,\n  G2: WeierstrassPointCons<Fp2>,\n  params: BlsPairingParams\n): BlsPairing {\n  const { Fp2, Fp12 } = fields;\n  const { twistType, ateLoopSize, xNegative, postPrecompute } = params;\n  type G1 = typeof G1.BASE;\n  type G2 = typeof G2.BASE;\n  // Applies sparse multiplication as line function\n  let lineFunction: (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) => Fp12;\n  if (twistType === 'multiplicative') {\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n  } else if (twistType === 'divisive') {\n    // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n    // precompute calculations.\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n  } else throw new Error('bls: unknown twist type');\n\n  const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n  function pointDouble(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2) {\n    const t0 = Fp2.sqr(Ry); // Ry²\n    const t1 = Fp2.sqr(Rz); // Rz²\n    const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n    const t3 = Fp2.mul(t2, _3n); // 3 * T2\n    const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n    const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n    const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n    const c2 = Fp2.neg(t4); // -T4 (-h)\n\n    ell.push([c0, c1, c2]);\n\n    Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n    Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n    Rz = Fp2.mul(t0, t4); // T0 * T4\n    return { Rx, Ry, Rz };\n  }\n  function pointAdd(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2, Qx: Fp2, Qy: Fp2) {\n    // Addition\n    const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n    const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n    const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n    const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n    const c2 = t1; // == Rx - Qx * Rz\n\n    ell.push([c0, c1, c2]);\n\n    const t2 = Fp2.sqr(t1); // T1²\n    const t3 = Fp2.mul(t2, t1); // T2 * T1\n    const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n    const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n    Rx = Fp2.mul(t1, t5); // T1 * T5\n    Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n    Rz = Fp2.mul(Rz, t3); // Rz * T3\n    return { Rx, Ry, Rz };\n  }\n\n  // Pre-compute coefficients for sparse multiplication\n  // Point addition and point double calculations is reused for coefficients\n  // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n  // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n  const ATE_NAF = NAfDecomposition(ateLoopSize);\n\n  const calcPairingPrecomputes = memoized((point: G2) => {\n    const p = point;\n    const { x, y } = p.toAffine();\n    // prettier-ignore\n    const Qx = x, Qy = y, negQy = Fp2.neg(y);\n    // prettier-ignore\n    let Rx = Qx, Ry = Qy, Rz = Fp2.ONE;\n    const ell: Precompute = [];\n    for (const bit of ATE_NAF) {\n      const cur: PrecomputeSingle = [];\n      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));\n      if (bit) ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n      ell.push(cur);\n    }\n    if (postPrecompute) {\n      const last = ell[ell.length - 1];\n      postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n    }\n    return ell;\n  });\n\n  // Main pairing logic is here. Computes product of miller loops + final exponentiate\n  // Applies calculated precomputes\n  type MillerInput = [Precompute, Fp, Fp][];\n  function millerLoopBatch(pairs: MillerInput, withFinalExponent: boolean = false) {\n    let f12 = Fp12.ONE;\n    if (pairs.length) {\n      const ellLen = pairs[0][0].length;\n      for (let i = 0; i < ellLen; i++) {\n        f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n        // NOTE: we apply multiple pairings in parallel here\n        for (const [ell, Px, Py] of pairs) {\n          for (const [c0, c1, c2] of ell[i]) f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n        }\n      }\n    }\n    if (xNegative) f12 = Fp12.conjugate(f12);\n    return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n  }\n  type PairingInput = { g1: G1; g2: G2 };\n  // Calculates product of multiple pairings\n  // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n  function pairingBatch(pairs: PairingInput[], withFinalExponent: boolean = true) {\n    const res: MillerInput = [];\n    // Cache precomputed toAffine for all points\n    normalizeZ(\n      G1,\n      pairs.map(({ g1 }) => g1)\n    );\n    normalizeZ(\n      G2,\n      pairs.map(({ g2 }) => g2)\n    );\n    for (const { g1, g2 } of pairs) {\n      if (g1.is0() || g2.is0()) throw new Error('pairing is not available for ZERO point');\n      // This uses toAffine inside\n      g1.assertValidity();\n      g2.assertValidity();\n      const Qa = g1.toAffine();\n      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n    }\n    return millerLoopBatch(res, withFinalExponent);\n  }\n  // Calculates bilinear pairing\n  function pairing(Q: G1, P: G2, withFinalExponent: boolean = true): Fp12 {\n    return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);\n  }\n  return {\n    Fp12, // NOTE: we re-export Fp12 here because pairing results are Fp12!\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    calcPairingPrecomputes,\n  };\n}\n\nfunction createBlsSig<P, S>(\n  blsPairing: BlsPairing,\n  PubCurve: CurvePointsRes<P> & H2CHasher<P>,\n  SigCurve: CurvePointsRes<S> & H2CHasher<S>,\n  SignatureCoder: SignatureCoder<S>,\n  isSigG1: boolean\n): BLSSigs<P, S> {\n  const { Fp12, pairingBatch } = blsPairing;\n  type PubPoint = WeierstrassPoint<P>;\n  type SigPoint = WeierstrassPoint<S>;\n  function normPub(point: PubPoint | BLSInput): PubPoint {\n    return point instanceof PubCurve.Point ? (point as PubPoint) : PubCurve.Point.fromHex(point);\n  }\n  function normSig(point: SigPoint | BLSInput): SigPoint {\n    return point instanceof SigCurve.Point ? (point as SigPoint) : SigCurve.Point.fromHex(point);\n  }\n  function amsg(m: unknown): SigPoint {\n    if (!(m instanceof SigCurve.Point))\n      throw new Error(`expected valid message hashed to ${!isSigG1 ? 'G2' : 'G1'} curve`);\n    return m as SigPoint;\n  }\n\n  type G1 = CurvePointsRes<Fp>['Point']['BASE'];\n  type G2 = CurvePointsRes<Fp2>['Point']['BASE'];\n  type PairingInput = { g1: G1; g2: G2 };\n  // What matters here is what point pairing API accepts as G1 or G2, not actual size or names\n  const pair: (a: PubPoint, b: SigPoint) => PairingInput = !isSigG1\n    ? (a: PubPoint, b: SigPoint) => ({ g1: a, g2: b }) as PairingInput\n    : (a: PubPoint, b: SigPoint) => ({ g1: b, g2: a }) as PairingInput;\n  return {\n    // P = pk x G\n    getPublicKey(secretKey: PrivKey): PubPoint {\n      // TODO: replace with\n      // const sec = PubCurve.Point.Fn.fromBytes(secretKey);\n      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);\n      return PubCurve.Point.BASE.multiply(sec);\n    },\n    // S = pk x H(m)\n    sign(message: SigPoint, secretKey: PrivKey, unusedArg?: any): SigPoint {\n      if (unusedArg != null) throw new Error('sign() expects 2 arguments');\n      // TODO: replace with\n      // PubCurve.Point.Fn.fromBytes(secretKey)\n      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);\n      amsg(message).assertValidity();\n      return message.multiply(sec);\n    },\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(P, H(m)) == e(G, S)\n    // e(S, G) == e(H(m), P)\n    verify(\n      signature: SigPoint | BLSInput,\n      message: SigPoint,\n      publicKey: PubPoint | BLSInput,\n      unusedArg?: any\n    ): boolean {\n      if (unusedArg != null) throw new Error('verify() expects 3 arguments');\n      signature = normSig(signature);\n      publicKey = normPub(publicKey);\n      const P = publicKey.negate();\n      const G = PubCurve.Point.BASE;\n      const Hm = amsg(message);\n      const S = signature;\n      // This code was changed in 1.9.x:\n      // Before it was G.negate() in G2, now it's always pubKey.negate\n      // e(P, -Q)===e(-P, Q)==e(P, Q)^-1. Negate can be done anywhere (as long it is done once per pair).\n      // We just moving sign, but since pairing is multiplicative, we doing X * X^-1 = 1\n      const exp = pairingBatch([pair(P, Hm), pair(G, S)]);\n      return Fp12.eql(exp, Fp12.ONE);\n    },\n    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n    verifyBatch(\n      signature: SigPoint | BLSInput,\n      messages: SigPoint[],\n      publicKeys: (PubPoint | BLSInput)[]\n    ): boolean {\n      aNonEmpty(messages);\n      if (publicKeys.length !== messages.length)\n        throw new Error('amount of public keys and messages should be equal');\n      const sig = normSig(signature);\n      const nMessages = messages;\n      const nPublicKeys = publicKeys.map(normPub);\n      // NOTE: this works only for exact same object\n      const messagePubKeyMap = new Map<SigPoint, PubPoint[]>();\n      for (let i = 0; i < nPublicKeys.length; i++) {\n        const pub = nPublicKeys[i];\n        const msg = nMessages[i];\n        let keys = messagePubKeyMap.get(msg);\n        if (keys === undefined) {\n          keys = [];\n          messagePubKeyMap.set(msg, keys);\n        }\n        keys.push(pub);\n      }\n      const paired = [];\n      const G = PubCurve.Point.BASE;\n      try {\n        for (const [msg, keys] of messagePubKeyMap) {\n          const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n          paired.push(pair(groupPublicKey, msg));\n        }\n        paired.push(pair(G.negate(), sig));\n        return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n      } catch {\n        return false;\n      }\n    },\n    // Adds a bunch of public key points together.\n    // pk1 + pk2 + pk3 = pkA\n    aggregatePublicKeys(publicKeys: (PubPoint | BLSInput)[]): PubPoint {\n      aNonEmpty(publicKeys);\n      publicKeys = publicKeys.map((pub) => normPub(pub));\n      const agg = (publicKeys as PubPoint[]).reduce((sum, p) => sum.add(p), PubCurve.Point.ZERO);\n      agg.assertValidity();\n      return agg;\n    },\n\n    // Adds a bunch of signature points together.\n    // pk1 + pk2 + pk3 = pkA\n    aggregateSignatures(signatures: (SigPoint | BLSInput)[]): SigPoint {\n      aNonEmpty(signatures);\n      signatures = signatures.map((sig) => normSig(sig));\n      const agg = (signatures as SigPoint[]).reduce((sum, s) => sum.add(s), SigCurve.Point.ZERO);\n      agg.assertValidity();\n      return agg;\n    },\n\n    hash(messageBytes: Uint8Array, DST?: string | Uint8Array): SigPoint {\n      abytes(messageBytes);\n      const opts = DST ? { DST } : undefined;\n      return SigCurve.hashToCurve(messageBytes, opts) as SigPoint;\n    },\n    Signature: SignatureCoder,\n  };\n}\n\n// G1_Point: ProjConstructor<bigint>, G2_Point: ProjConstructor<Fp2>,\nexport function bls(CURVE: CurveType): CurveFn {\n  // Fields are specific for curve, so for now we'll need to pass them with opts\n  const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n  // Point on G1 curve: (x, y)\n  const G1_ = weierstrassPoints(CURVE.G1);\n  const G1 = Object.assign(\n    G1_,\n    createHasher(G1_.Point, CURVE.G1.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G1.htfDefaults,\n    })\n  );\n  // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n  const G2_ = weierstrassPoints(CURVE.G2);\n  const G2 = Object.assign(\n    G2_,\n    createHasher(G2_.Point as H2CPointConstructor<Fp2>, CURVE.G2.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G2.htfDefaults,\n    })\n  );\n  type G1 = typeof G1.Point.BASE;\n  type G2 = typeof G2.Point.BASE;\n\n  const pairingRes = createBlsPairing(CURVE.fields, G1.Point, G2.Point, {\n    ...CURVE.params,\n    postPrecompute: CURVE.postPrecompute,\n  });\n\n  const { millerLoopBatch, pairing, pairingBatch, calcPairingPrecomputes } = pairingRes;\n  const longSignatures = createBlsSig(pairingRes, G1, G2, CURVE.G2.Signature, false);\n  const shortSignatures = createBlsSig(pairingRes, G2, G1, CURVE.G1.ShortSignature, true);\n\n  const rand = CURVE.randomBytes || randomBytes;\n  const randomSecretKey = (): Uint8Array => {\n    const length = getMinHashLength(Fr.ORDER);\n    return mapHashToField(rand(length), Fr.ORDER);\n  };\n  const utils = {\n    randomSecretKey,\n    randomPrivateKey: randomSecretKey,\n    calcPairingPrecomputes,\n  };\n\n  // LEGACY code\n  type G1Hex = Hex | G1;\n  type G2Hex = Hex | G2;\n\n  const { ShortSignature } = CURVE.G1;\n  const { Signature } = CURVE.G2;\n\n  function normP1Hash(point: G1Hex, htfOpts?: htfBasicOpts): G1 {\n    return point instanceof G1.Point\n      ? point\n      : shortSignatures.hash(ensureBytes('point', point), htfOpts?.DST);\n  }\n  function normP2Hash(point: G2Hex, htfOpts?: htfBasicOpts): G2 {\n    return point instanceof G2.Point\n      ? point\n      : longSignatures.hash(ensureBytes('point', point), htfOpts?.DST);\n  }\n\n  function getPublicKey(privateKey: PrivKey): Uint8Array {\n    return longSignatures.getPublicKey(privateKey).toBytes(true);\n  }\n  function getPublicKeyForShortSignatures(privateKey: PrivKey): Uint8Array {\n    return shortSignatures.getPublicKey(privateKey).toBytes(true);\n  }\n  function sign(message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n  function sign(message: G2, privateKey: PrivKey, htfOpts?: htfBasicOpts): G2;\n  function sign(message: G2Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array | G2 {\n    const Hm = normP2Hash(message, htfOpts);\n    const S = longSignatures.sign(Hm, privateKey);\n    return message instanceof G2.Point ? S : Signature.toBytes(S);\n  }\n  function signShortSignature(\n    message: Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array;\n  function signShortSignature(message: G1, privateKey: PrivKey, htfOpts?: htfBasicOpts): G1;\n  function signShortSignature(\n    message: G1Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array | G1 {\n    const Hm = normP1Hash(message, htfOpts);\n    const S = shortSignatures.sign(Hm, privateKey);\n    return message instanceof G1.Point ? S : ShortSignature.toBytes(S);\n  }\n  function verify(\n    signature: G2Hex,\n    message: G2Hex,\n    publicKey: G1Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = normP2Hash(message, htfOpts);\n    return longSignatures.verify(signature, Hm, publicKey);\n  }\n  function verifyShortSignature(\n    signature: G1Hex,\n    message: G1Hex,\n    publicKey: G2Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = normP1Hash(message, htfOpts);\n    return shortSignatures.verify(signature, Hm, publicKey);\n  }\n  function aggregatePublicKeys(publicKeys: Hex[]): Uint8Array;\n  function aggregatePublicKeys(publicKeys: G1[]): G1;\n  function aggregatePublicKeys(publicKeys: G1Hex[]): Uint8Array | G1 {\n    const agg = longSignatures.aggregatePublicKeys(publicKeys);\n    return publicKeys[0] instanceof G1.Point ? agg : agg.toBytes(true);\n  }\n  function aggregateSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateSignatures(signatures: G2[]): G2;\n  function aggregateSignatures(signatures: G2Hex[]): Uint8Array | G2 {\n    const agg = longSignatures.aggregateSignatures(signatures);\n    return signatures[0] instanceof G2.Point ? agg : Signature.toBytes(agg);\n  }\n  function aggregateShortSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateShortSignatures(signatures: G1[]): G1;\n  function aggregateShortSignatures(signatures: G1Hex[]): Uint8Array | G1 {\n    const agg = shortSignatures.aggregateSignatures(signatures);\n    return signatures[0] instanceof G1.Point ? agg : ShortSignature.toBytes(agg);\n  }\n  function verifyBatch(\n    signature: G2Hex,\n    messages: G2Hex[],\n    publicKeys: G1Hex[],\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const Hm = messages.map((m) => normP2Hash(m, htfOpts));\n    return longSignatures.verifyBatch(signature, Hm, publicKeys);\n  }\n\n  G1.Point.BASE.precompute(4);\n\n  return {\n    longSignatures,\n    shortSignatures,\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    verifyBatch,\n    fields: {\n      Fr,\n      Fp,\n      Fp2,\n      Fp6,\n      Fp12,\n    },\n    params: {\n      ateLoopSize: CURVE.params.ateLoopSize,\n      twistType: CURVE.params.twistType,\n      // deprecated\n      r: CURVE.params.r,\n      G1b: CURVE.G1.b,\n      G2b: CURVE.G2.b,\n    },\n    utils,\n\n    // deprecated\n    getPublicKey,\n    getPublicKeyForShortSignatures,\n    sign,\n    signShortSignature,\n    verify,\n    verifyShortSignature,\n    aggregatePublicKeys,\n    aggregateSignatures,\n    aggregateShortSignatures,\n    G1,\n    G2,\n    Signature,\n    ShortSignature,\n  };\n}\n", "/**\n * Towered extension fields.\n * Rather than implementing a massive 12th-degree extension directly, it is more efficient\n * to build it up from smaller extensions: a tower of extensions.\n *\n * For BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\n * on top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\n *\n * For more info: \"Pairings for beginners\" by Costello, section 7.3.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitGet, bitLen, concatBytes, notImplemented } from '../utils.ts';\nimport * as mod from './modular.ts';\nimport type { WeierstrassPoint, WeierstrassPointCons } from './weierstrass.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\n// Fp₂ over complex plane\nexport type BigintTuple = [bigint, bigint];\nexport type Fp = bigint;\n// Finite extension field over irreducible polynominal.\n// Fp(u) / (u² - β) where β = -1\nexport type Fp2 = { c0: bigint; c1: bigint };\nexport type BigintSix = [bigint, bigint, bigint, bigint, bigint, bigint];\nexport type Fp6 = { c0: Fp2; c1: Fp2; c2: Fp2 };\nexport type Fp12 = { c0: Fp6; c1: Fp6 }; // Fp₁₂ = Fp₆² => Fp₂³, Fp₆(w) / (w² - γ) where γ = v\n// prettier-ignore\nexport type BigintTwelve = [\n  bigint, bigint, bigint, bigint, bigint, bigint,\n  bigint, bigint, bigint, bigint, bigint, bigint\n];\n\nexport type Fp2Bls = mod.IField<Fp2> & {\n  Fp: mod.IField<Fp>;\n  frobeniusMap(num: Fp2, power: number): Fp2;\n  fromBigTuple(num: BigintTuple): Fp2;\n  mulByB: (num: Fp2) => Fp2;\n  mulByNonresidue: (num: Fp2) => Fp2;\n  reim: (num: Fp2) => { re: Fp; im: Fp };\n  Fp4Square: (a: Fp2, b: Fp2) => { first: Fp2; second: Fp2 };\n  NONRESIDUE: Fp2;\n};\n\nexport type Fp6Bls = mod.IField<Fp6> & {\n  Fp2: Fp2Bls;\n  frobeniusMap(num: Fp6, power: number): Fp6;\n  fromBigSix: (tuple: BigintSix) => Fp6;\n  mul1(num: Fp6, b1: Fp2): Fp6;\n  mul01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\n  mulByFp2(lhs: Fp6, rhs: Fp2): Fp6;\n  mulByNonresidue: (num: Fp6) => Fp6;\n};\n\nexport type Fp12Bls = mod.IField<Fp12> & {\n  Fp6: Fp6Bls;\n  frobeniusMap(num: Fp12, power: number): Fp12;\n  fromBigTwelve: (t: BigintTwelve) => Fp12;\n  mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n  mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n  mulByFp2(lhs: Fp12, rhs: Fp2): Fp12;\n  conjugate(num: Fp12): Fp12;\n  finalExponentiate(num: Fp12): Fp12;\n  _cyclotomicSquare(num: Fp12): Fp12;\n  _cyclotomicExp(num: Fp12, n: bigint): Fp12;\n};\n\nfunction calcFrobeniusCoefficients<T>(\n  Fp: mod.IField<T>,\n  nonResidue: T,\n  modulus: bigint,\n  degree: number,\n  num: number = 1,\n  divisor?: number\n) {\n  const _divisor = BigInt(divisor === undefined ? degree : divisor);\n  const towerModulus: any = modulus ** BigInt(degree);\n  const res: T[][] = [];\n  for (let i = 0; i < num; i++) {\n    const a = BigInt(i + 1);\n    const powers: T[] = [];\n    for (let j = 0, qPower = _1n; j < degree; j++) {\n      const power = ((a * qPower - a) / _divisor) % towerModulus;\n      powers.push(Fp.pow(nonResidue, power));\n      qPower *= modulus;\n    }\n    res.push(powers);\n  }\n  return res;\n}\n\n// This works same at least for bls12-381, bn254 and bls12-377\nexport function psiFrobenius(\n  Fp: mod.IField<Fp>,\n  Fp2: Fp2Bls,\n  base: Fp2\n): {\n  psi: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  psi2: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  G2psi: (c: WeierstrassPointCons<Fp2>, P: WeierstrassPoint<Fp2>) => WeierstrassPoint<Fp2>;\n  G2psi2: (c: WeierstrassPointCons<Fp2>, P: WeierstrassPoint<Fp2>) => WeierstrassPoint<Fp2>;\n  PSI_X: Fp2;\n  PSI_Y: Fp2;\n  PSI2_X: Fp2;\n  PSI2_Y: Fp2;\n} {\n  // GLV endomorphism Ψ(P)\n  const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\n  const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\n  function psi(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    // This x10 faster than previous version in bls12-381\n    const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\n    const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\n    return [x2, y2];\n  }\n  // Ψ²(P) endomorphism (psi2(x) = psi(psi(x)))\n  const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\n  // This equals -1, which causes y to be Fp2.neg(y).\n  // But not sure if there are case when this is not true?\n  const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\n  if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE))) throw new Error('psiFrobenius: PSI2_Y!==-1');\n  function psi2(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];\n  }\n  // Map points\n  const mapAffine =\n    <T>(fn: (x: T, y: T) => [T, T]) =>\n    (c: WeierstrassPointCons<T>, P: WeierstrassPoint<T>) => {\n      const affine = P.toAffine();\n      const p = fn(affine.x, affine.y);\n      return c.fromAffine({ x: p[0], y: p[1] });\n    };\n  const G2psi = mapAffine(psi);\n  const G2psi2 = mapAffine(psi2);\n  return { psi, psi2, G2psi, G2psi2, PSI_X, PSI_Y, PSI2_X, PSI2_Y };\n}\n\nexport type Tower12Opts = {\n  ORDER: bigint;\n  X_LEN: number;\n  NONRESIDUE?: Fp;\n  FP2_NONRESIDUE: BigintTuple;\n  Fp2sqrt?: (num: Fp2) => Fp2;\n  Fp2mulByB: (num: Fp2) => Fp2;\n  Fp12finalExponentiate: (num: Fp12) => Fp12;\n};\n\nconst Fp2fromBigTuple = (Fp: mod.IField<bigint>, tuple: BigintTuple | bigint[]) => {\n  if (tuple.length !== 2) throw new Error('invalid tuple');\n  const fps = tuple.map((n) => Fp.create(n)) as BigintTuple;\n  return { c0: fps[0], c1: fps[1] };\n};\n\nclass _Field2 implements mod.IField<Fp2> {\n  readonly ORDER: bigint;\n  readonly BITS: number;\n  readonly BYTES: number;\n  readonly isLE: boolean;\n  readonly MASK = _1n;\n\n  readonly ZERO: Fp2;\n  readonly ONE: Fp2;\n  readonly Fp: mod.IField<bigint>;\n\n  readonly NONRESIDUE: Fp2;\n  readonly mulByB: Tower12Opts['Fp2mulByB'];\n  readonly Fp_NONRESIDUE: bigint;\n  readonly Fp_div2: bigint;\n  readonly FROBENIUS_COEFFICIENTS: Fp[];\n\n  constructor(\n    Fp: mod.IField<bigint>,\n    opts: Partial<{\n      NONRESIDUE: bigint;\n      FP2_NONRESIDUE: BigintTuple;\n      Fp2mulByB: Tower12Opts['Fp2mulByB'];\n    }> = {}\n  ) {\n    const ORDER = Fp.ORDER;\n    const FP2_ORDER = ORDER * ORDER;\n    this.Fp = Fp;\n    this.ORDER = FP2_ORDER;\n    this.BITS = bitLen(FP2_ORDER);\n    this.BYTES = Math.ceil(bitLen(FP2_ORDER) / 8);\n    this.isLE = Fp.isLE;\n    this.ZERO = { c0: Fp.ZERO, c1: Fp.ZERO };\n    this.ONE = { c0: Fp.ONE, c1: Fp.ZERO };\n\n    this.Fp_NONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\n    this.Fp_div2 = Fp.div(Fp.ONE, _2n); // 1/2\n    this.NONRESIDUE = Fp2fromBigTuple(Fp, opts.FP2_NONRESIDUE!);\n    // const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\n    this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, this.Fp_NONRESIDUE, Fp.ORDER, 2)[0];\n    this.mulByB = opts.Fp2mulByB!;\n    Object.seal(this);\n  }\n  fromBigTuple(tuple: BigintTuple) {\n    return Fp2fromBigTuple(this.Fp, tuple);\n  }\n  create(num: Fp2) {\n    return num;\n  }\n  isValid({ c0, c1 }: Fp2) {\n    function isValidC(num: bigint, ORDER: bigint) {\n      return typeof num === 'bigint' && _0n <= num && num < ORDER;\n    }\n    return isValidC(c0, this.ORDER) && isValidC(c1, this.ORDER);\n  }\n  is0({ c0, c1 }: Fp2) {\n    return this.Fp.is0(c0) && this.Fp.is0(c1);\n  }\n  isValidNot0(num: Fp2) {\n    return !this.is0(num) && this.isValid(num);\n  }\n  eql({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) {\n    return this.Fp.eql(c0, r0) && this.Fp.eql(c1, r1);\n  }\n  neg({ c0, c1 }: Fp2) {\n    return { c0: this.Fp.neg(c0), c1: this.Fp.neg(c1) };\n  }\n  pow(num: Fp2, power: bigint): Fp2 {\n    return mod.FpPow(this, num, power);\n  }\n  invertBatch(nums: Fp2[]): Fp2[] {\n    return mod.FpInvertBatch(this, nums);\n  }\n  // Normalized\n  add(f1: Fp2, f2: Fp2): Fp2 {\n    const { c0, c1 } = f1;\n    const { c0: r0, c1: r1 } = f2;\n    return {\n      c0: this.Fp.add(c0, r0),\n      c1: this.Fp.add(c1, r1),\n    };\n  }\n  sub({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) {\n    return {\n      c0: this.Fp.sub(c0, r0),\n      c1: this.Fp.sub(c1, r1),\n    };\n  }\n  mul({ c0, c1 }: Fp2, rhs: Fp2) {\n    const { Fp } = this;\n    if (typeof rhs === 'bigint') return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\n    // (a+bi)(c+di) = (ac−bd) + (ad+bc)i\n    const { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp.mul(c0, r0); // c0 * o0\n    let t2 = Fp.mul(c1, r1); // c1 * o1\n    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n    const o0 = Fp.sub(t1, t2);\n    const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n    return { c0: o0, c1: o1 };\n  }\n  sqr({ c0, c1 }: Fp2) {\n    const { Fp } = this;\n    const a = Fp.add(c0, c1);\n    const b = Fp.sub(c0, c1);\n    const c = Fp.add(c0, c0);\n    return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\n  }\n  // NonNormalized stuff\n  addN(a: Fp2, b: Fp2): Fp2 {\n    return this.add(a, b);\n  }\n  subN(a: Fp2, b: Fp2): Fp2 {\n    return this.sub(a, b);\n  }\n  mulN(a: Fp2, b: Fp2): Fp2 {\n    return this.mul(a, b);\n  }\n  sqrN(a: Fp2): Fp2 {\n    return this.sqr(a);\n  }\n  // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n  div(lhs: Fp2, rhs: Fp2): Fp2 {\n    const { Fp } = this;\n    // @ts-ignore\n    return this.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));\n  }\n  inv({ c0: a, c1: b }: Fp2): Fp2 {\n    // We wish to find the multiplicative inverse of a nonzero\n    // element a + bu in Fp2. We leverage an identity\n    //\n    // (a + bu)(a - bu) = a² + b²\n    //\n    // which holds because u² = -1. This can be rewritten as\n    //\n    // (a + bu)(a - bu)/(a² + b²) = 1\n    //\n    // because a² + b² = 0 has no nonzero solutions for (a, b).\n    // This gives that (a - bu)/(a² + b²) is the inverse\n    // of (a + bu). Importantly, this can be computing using\n    // only a single inversion in Fp.\n    const { Fp } = this;\n    const factor = Fp.inv(Fp.create(a * a + b * b));\n    return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\n  }\n  sqrt(num: Fp2) {\n    // This is generic for all quadratic extensions (Fp2)\n    const { Fp } = this;\n    const Fp2 = this;\n    const { c0, c1 } = num;\n    if (Fp.is0(c1)) {\n      // if c0 is quadratic residue\n      if (mod.FpLegendre(Fp, c0) === 1) return Fp2.create({ c0: Fp.sqrt(c0), c1: Fp.ZERO });\n      else return Fp2.create({ c0: Fp.ZERO, c1: Fp.sqrt(Fp.div(c0, this.Fp_NONRESIDUE)) });\n    }\n    const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), this.Fp_NONRESIDUE)));\n    let d = Fp.mul(Fp.add(a, c0), this.Fp_div2);\n    const legendre = mod.FpLegendre(Fp, d);\n    // -1, Quadratic non residue\n    if (legendre === -1) d = Fp.sub(d, a);\n    const a0 = Fp.sqrt(d);\n    const candidateSqrt = Fp2.create({ c0: a0, c1: Fp.div(Fp.mul(c1, this.Fp_div2), a0) });\n    if (!Fp2.eql(Fp2.sqr(candidateSqrt), num)) throw new Error('Cannot find square root');\n    // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\n    const x1 = candidateSqrt;\n    const x2 = Fp2.neg(x1);\n    const { re: re1, im: im1 } = Fp2.reim(x1);\n    const { re: re2, im: im2 } = Fp2.reim(x2);\n    if (im1 > im2 || (im1 === im2 && re1 > re2)) return x1;\n    return x2;\n  }\n  // Same as sgn0_m_eq_2 in RFC 9380\n  isOdd(x: Fp2) {\n    const { re: x0, im: x1 } = this.reim(x);\n    const sign_0 = x0 % _2n;\n    const zero_0 = x0 === _0n;\n    const sign_1 = x1 % _2n;\n    return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\n  }\n  // Bytes util\n  fromBytes(b: Uint8Array): Fp2 {\n    const { Fp } = this;\n    if (b.length !== this.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n    return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\n  }\n  toBytes({ c0, c1 }: Fp2) {\n    return concatBytes(this.Fp.toBytes(c0), this.Fp.toBytes(c1));\n  }\n  cmov({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2, c: boolean) {\n    return {\n      c0: this.Fp.cmov(c0, r0, c),\n      c1: this.Fp.cmov(c1, r1, c),\n    };\n  }\n  reim({ c0, c1 }: Fp2) {\n    return { re: c0, im: c1 };\n  }\n  Fp4Square(a: Fp2, b: Fp2): { first: Fp2; second: Fp2 } {\n    const Fp2 = this;\n    const a2 = Fp2.sqr(a);\n    const b2 = Fp2.sqr(b);\n    return {\n      first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b² * Nonresidue + a²\n      second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b)² - a² - b²\n    };\n  }\n  // multiply by u + 1\n  mulByNonresidue({ c0, c1 }: Fp2) {\n    return this.mul({ c0, c1 }, this.NONRESIDUE);\n  }\n  frobeniusMap({ c0, c1 }: Fp2, power: number): Fp2 {\n    return {\n      c0,\n      c1: this.Fp.mul(c1, this.FROBENIUS_COEFFICIENTS[power % 2]),\n    };\n  }\n}\n\nclass _Field6 implements Fp6Bls {\n  readonly ORDER: bigint;\n  readonly BITS: number;\n  readonly BYTES: number;\n  readonly isLE: boolean;\n  readonly MASK = _1n;\n\n  readonly ZERO: Fp6;\n  readonly ONE: Fp6;\n  readonly Fp2: Fp2Bls;\n  readonly FROBENIUS_COEFFICIENTS_1: Fp2[];\n  readonly FROBENIUS_COEFFICIENTS_2: Fp2[];\n\n  constructor(Fp2: Fp2Bls) {\n    this.Fp2 = Fp2;\n    this.ORDER = Fp2.ORDER; // TODO: unused, but need to verify\n    this.BITS = 3 * Fp2.BITS;\n    this.BYTES = 3 * Fp2.BYTES;\n    this.isLE = Fp2.isLE;\n    this.ZERO = { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO };\n    this.ONE = { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO };\n    const { Fp } = Fp2;\n    const frob = calcFrobeniusCoefficients(Fp2, Fp2.NONRESIDUE, Fp.ORDER, 6, 2, 3);\n    this.FROBENIUS_COEFFICIENTS_1 = frob[0];\n    this.FROBENIUS_COEFFICIENTS_2 = frob[1];\n    Object.seal(this);\n  }\n  add({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.add(c0, r0),\n      c1: Fp2.add(c1, r1),\n      c2: Fp2.add(c2, r2),\n    };\n  }\n  sub({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.sub(c0, r0),\n      c1: Fp2.sub(c1, r1),\n      c2: Fp2.sub(c2, r2),\n    };\n  }\n  mul({ c0, c1, c2 }: Fp6, rhs: Fp6 | bigint) {\n    const { Fp2 } = this;\n    if (typeof rhs === 'bigint') {\n      return {\n        c0: Fp2.mul(c0, rhs),\n        c1: Fp2.mul(c1, rhs),\n        c2: Fp2.mul(c2, rhs),\n      };\n    }\n    const { c0: r0, c1: r1, c2: r2 } = rhs;\n    const t0 = Fp2.mul(c0, r0); // c0 * o0\n    const t1 = Fp2.mul(c1, r1); // c1 * o1\n    const t2 = Fp2.mul(c2, r2); // c2 * o2\n    return {\n      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n      c0: Fp2.add(\n        t0,\n        Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))\n      ),\n      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n      c1: Fp2.add(\n        Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)),\n        Fp2.mulByNonresidue(t2)\n      ),\n      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n      c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\n    };\n  }\n  sqr({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    let t0 = Fp2.sqr(c0); // c0²\n    let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n    let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n    let t4 = Fp2.sqr(c2); // c2²\n    return {\n      c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\n      c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\n      // T1 + (c0 - c1 + c2)² + T3 - T0 - T4\n      c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\n    };\n  }\n  addN(a: Fp6, b: Fp6): Fp6 {\n    return this.add(a, b);\n  }\n  subN(a: Fp6, b: Fp6): Fp6 {\n    return this.sub(a, b);\n  }\n  mulN(a: Fp6, b: Fp6): Fp6 {\n    return this.mul(a, b);\n  }\n  sqrN(a: Fp6): Fp6 {\n    return this.sqr(a);\n  }\n\n  create(num: Fp6) {\n    return num;\n  }\n\n  isValid({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    return Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2);\n  }\n  is0({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    return Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2);\n  }\n  isValidNot0(num: Fp6) {\n    return !this.is0(num) && this.isValid(num);\n  }\n  neg({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    return { c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) };\n  }\n  eql({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) {\n    const { Fp2 } = this;\n    return Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2);\n  }\n  sqrt(_: Fp6) {\n    return notImplemented();\n  }\n  // Do we need division by bigint at all? Should be done via order:\n  div(lhs: Fp6, rhs: Fp6) {\n    const { Fp2 } = this;\n    const { Fp } = Fp2;\n    return this.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));\n  }\n  pow(num: Fp6, power: Fp): Fp6 {\n    return mod.FpPow(this, num, power);\n  }\n  invertBatch(nums: Fp6[]): Fp6[] {\n    return mod.FpInvertBatch(this, nums);\n  }\n\n  inv({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0² - c2 * c1 * (u + 1)\n    let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2² * (u + 1) - c0 * c1\n    let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1² - c0 * c2\n    // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n    let t4 = Fp2.inv(\n      Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0))\n    );\n    return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\n  }\n  // Bytes utils\n  fromBytes(b: Uint8Array): Fp6 {\n    const { Fp2 } = this;\n    if (b.length !== this.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n    const B2 = Fp2.BYTES;\n    return {\n      c0: Fp2.fromBytes(b.subarray(0, B2)),\n      c1: Fp2.fromBytes(b.subarray(B2, B2 * 2)),\n      c2: Fp2.fromBytes(b.subarray(2 * B2)),\n    };\n  }\n  toBytes({ c0, c1, c2 }: Fp6): Uint8Array {\n    const { Fp2 } = this;\n    return concatBytes(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2));\n  }\n  cmov({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6, c: boolean) {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.cmov(c0, r0, c),\n      c1: Fp2.cmov(c1, r1, c),\n      c2: Fp2.cmov(c2, r2, c),\n    };\n  }\n  fromBigSix(t: BigintSix): Fp6 {\n    const { Fp2 } = this;\n    if (!Array.isArray(t) || t.length !== 6) throw new Error('invalid Fp6 usage');\n    return {\n      c0: Fp2.fromBigTuple(t.slice(0, 2) as BigintTuple),\n      c1: Fp2.fromBigTuple(t.slice(2, 4) as BigintTuple),\n      c2: Fp2.fromBigTuple(t.slice(4, 6) as BigintTuple),\n    };\n  }\n  frobeniusMap({ c0, c1, c2 }: Fp6, power: number) {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.frobeniusMap(c0, power),\n      c1: Fp2.mul(Fp2.frobeniusMap(c1, power), this.FROBENIUS_COEFFICIENTS_1[power % 6]),\n      c2: Fp2.mul(Fp2.frobeniusMap(c2, power), this.FROBENIUS_COEFFICIENTS_2[power % 6]),\n    };\n  }\n  mulByFp2({ c0, c1, c2 }: Fp6, rhs: Fp2): Fp6 {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.mul(c0, rhs),\n      c1: Fp2.mul(c1, rhs),\n      c2: Fp2.mul(c2, rhs),\n    };\n  }\n  mulByNonresidue({ c0, c1, c2 }: Fp6) {\n    const { Fp2 } = this;\n    return { c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 };\n  }\n  // Sparse multiplication\n  mul1({ c0, c1, c2 }: Fp6, b1: Fp2): Fp6 {\n    const { Fp2 } = this;\n    return {\n      c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n      c1: Fp2.mul(c0, b1),\n      c2: Fp2.mul(c1, b1),\n    };\n  }\n  // Sparse multiplication\n  mul01({ c0, c1, c2 }: Fp6, b0: Fp2, b1: Fp2): Fp6 {\n    const { Fp2 } = this;\n    let t0 = Fp2.mul(c0, b0); // c0 * b0\n    let t1 = Fp2.mul(c1, b1); // c1 * b1\n    return {\n      // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n      c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n      // (b0 + b1) * (c0 + c1) - T0 - T1\n      c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n      // (c0 + c2) * b0 - T0 + T1\n      c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\n    };\n  }\n}\n\nclass _Field12 implements Fp12Bls {\n  readonly ORDER: bigint;\n  readonly BITS: number;\n  readonly BYTES: number;\n  readonly isLE: boolean;\n  readonly MASK = _1n;\n\n  readonly ZERO: Fp12;\n  readonly ONE: Fp12;\n\n  readonly Fp6: Fp6Bls;\n  readonly FROBENIUS_COEFFICIENTS: Fp2[];\n  readonly X_LEN: number;\n  readonly finalExponentiate: Tower12Opts['Fp12finalExponentiate'];\n\n  constructor(Fp6: Fp6Bls, opts: Tower12Opts) {\n    const { Fp2 } = Fp6;\n    const { Fp } = Fp2;\n    this.Fp6 = Fp6;\n\n    this.ORDER = Fp2.ORDER; // TODO: verify if it's unuesd\n    this.BITS = 2 * Fp6.BITS;\n    this.BYTES = 2 * Fp6.BYTES;\n    this.isLE = Fp6.isLE;\n    this.ZERO = { c0: Fp6.ZERO, c1: Fp6.ZERO };\n    this.ONE = { c0: Fp6.ONE, c1: Fp6.ZERO };\n\n    this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(\n      Fp2,\n      Fp2.NONRESIDUE,\n      Fp.ORDER,\n      12,\n      1,\n      6\n    )[0];\n    this.X_LEN = opts.X_LEN;\n    this.finalExponentiate = opts.Fp12finalExponentiate;\n  }\n  create(num: Fp12) {\n    return num;\n  }\n  isValid({ c0, c1 }: Fp12) {\n    const { Fp6 } = this;\n    return Fp6.isValid(c0) && Fp6.isValid(c1);\n  }\n  is0({ c0, c1 }: Fp12) {\n    const { Fp6 } = this;\n    return Fp6.is0(c0) && Fp6.is0(c1);\n  }\n  isValidNot0(num: Fp12) {\n    return !this.is0(num) && this.isValid(num);\n  }\n  neg({ c0, c1 }: Fp12) {\n    const { Fp6 } = this;\n    return { c0: Fp6.neg(c0), c1: Fp6.neg(c1) };\n  }\n  eql({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) {\n    const { Fp6 } = this;\n    return Fp6.eql(c0, r0) && Fp6.eql(c1, r1);\n  }\n  sqrt(_: any): any {\n    notImplemented();\n  }\n  inv({ c0, c1 }: Fp12) {\n    const { Fp6 } = this;\n    let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0² - c1² * v)\n    return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\n  }\n  div(lhs: Fp12, rhs: Fp12) {\n    const { Fp6 } = this;\n    const { Fp2 } = Fp6;\n    const { Fp } = Fp2;\n    return this.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));\n  }\n  pow(num: Fp12, power: bigint): Fp12 {\n    return mod.FpPow(this, num, power);\n  }\n  invertBatch(nums: Fp12[]): Fp12[] {\n    return mod.FpInvertBatch(this, nums);\n  }\n\n  // Normalized\n  add({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) {\n    const { Fp6 } = this;\n    return {\n      c0: Fp6.add(c0, r0),\n      c1: Fp6.add(c1, r1),\n    };\n  }\n  sub({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) {\n    const { Fp6 } = this;\n    return {\n      c0: Fp6.sub(c0, r0),\n      c1: Fp6.sub(c1, r1),\n    };\n  }\n  mul({ c0, c1 }: Fp12, rhs: Fp12 | bigint) {\n    const { Fp6 } = this;\n    if (typeof rhs === 'bigint') return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\n    let { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp6.mul(c0, r0); // c0 * r0\n    let t2 = Fp6.mul(c1, r1); // c1 * r1\n    return {\n      c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\n      // (c0 + c1) * (r0 + r1) - (T1 + T2)\n      c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\n    };\n  }\n  sqr({ c0, c1 }: Fp12) {\n    const { Fp6 } = this;\n    let ab = Fp6.mul(c0, c1); // c0 * c1\n    return {\n      // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n      c0: Fp6.sub(\n        Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab),\n        Fp6.mulByNonresidue(ab)\n      ),\n      c1: Fp6.add(ab, ab),\n    }; // AB + AB\n  }\n  // NonNormalized stuff\n  addN(a: Fp12, b: Fp12): Fp12 {\n    return this.add(a, b);\n  }\n  subN(a: Fp12, b: Fp12): Fp12 {\n    return this.sub(a, b);\n  }\n  mulN(a: Fp12, b: Fp12): Fp12 {\n    return this.mul(a, b);\n  }\n  sqrN(a: Fp12): Fp12 {\n    return this.sqr(a);\n  }\n\n  // Bytes utils\n  fromBytes(b: Uint8Array): Fp12 {\n    const { Fp6 } = this;\n    if (b.length !== this.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n    return {\n      c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n      c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\n    };\n  }\n  toBytes({ c0, c1 }: Fp12): Uint8Array {\n    const { Fp6 } = this;\n    return concatBytes(Fp6.toBytes(c0), Fp6.toBytes(c1));\n  }\n  cmov({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12, c: boolean) {\n    const { Fp6 } = this;\n    return {\n      c0: Fp6.cmov(c0, r0, c),\n      c1: Fp6.cmov(c1, r1, c),\n    };\n  }\n  // Utils\n  // toString() {\n  //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');\n  // },\n  // fromTuple(c: [Fp6, Fp6]) {\n  //   return new Fp12(...c);\n  // }\n  fromBigTwelve(t: BigintTwelve): Fp12 {\n    const { Fp6 } = this;\n    return {\n      c0: Fp6.fromBigSix(t.slice(0, 6) as BigintSix),\n      c1: Fp6.fromBigSix(t.slice(6, 12) as BigintSix),\n    };\n  }\n  // Raises to q**i -th power\n  frobeniusMap(lhs: Fp12, power: number) {\n    const { Fp6 } = this;\n    const { Fp2 } = Fp6;\n    const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\n    const coeff = this.FROBENIUS_COEFFICIENTS[power % 12];\n    return {\n      c0: Fp6.frobeniusMap(lhs.c0, power),\n      c1: Fp6.create({\n        c0: Fp2.mul(c0, coeff),\n        c1: Fp2.mul(c1, coeff),\n        c2: Fp2.mul(c2, coeff),\n      }),\n    };\n  }\n  mulByFp2({ c0, c1 }: Fp12, rhs: Fp2): Fp12 {\n    const { Fp6 } = this;\n    return {\n      c0: Fp6.mulByFp2(c0, rhs),\n      c1: Fp6.mulByFp2(c1, rhs),\n    };\n  }\n  conjugate({ c0, c1 }: Fp12): Fp12 {\n    return { c0, c1: this.Fp6.neg(c1) };\n  }\n  // Sparse multiplication\n  mul014({ c0, c1 }: Fp12, o0: Fp2, o1: Fp2, o4: Fp2) {\n    const { Fp6 } = this;\n    const { Fp2 } = Fp6;\n    let t0 = Fp6.mul01(c0, o0, o1);\n    let t1 = Fp6.mul1(c1, o4);\n    return {\n      c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\n      // (c1 + c0) * [o0, o1+o4] - T0 - T1\n      c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\n    };\n  }\n  mul034({ c0, c1 }: Fp12, o0: Fp2, o3: Fp2, o4: Fp2) {\n    const { Fp6 } = this;\n    const { Fp2 } = Fp6;\n    const a = Fp6.create({\n      c0: Fp2.mul(c0.c0, o0),\n      c1: Fp2.mul(c0.c1, o0),\n      c2: Fp2.mul(c0.c2, o0),\n    });\n    const b = Fp6.mul01(c1, o3, o4);\n    const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\n    return {\n      c0: Fp6.add(Fp6.mulByNonresidue(b), a),\n      c1: Fp6.sub(e, Fp6.add(a, b)),\n    };\n  }\n\n  // A cyclotomic group is a subgroup of Fp^n defined by\n  //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n  // The result of any pairing is in a cyclotomic subgroup\n  // https://eprint.iacr.org/2009/565.pdf\n  // https://eprint.iacr.org/2010/354.pdf\n  _cyclotomicSquare({ c0, c1 }: Fp12): Fp12 {\n    const { Fp6 } = this;\n    const { Fp2 } = Fp6;\n    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\n    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\n    const { first: t3, second: t4 } = Fp2.Fp4Square(c0c0, c1c1);\n    const { first: t5, second: t6 } = Fp2.Fp4Square(c1c0, c0c2);\n    const { first: t7, second: t8 } = Fp2.Fp4Square(c0c1, c1c2);\n    const t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\n    return {\n      c0: Fp6.create({\n        c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3), // 2 * (T3 - c0c0)  + T3\n        c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5), // 2 * (T5 - c0c1)  + T5\n        c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7),\n      }), // 2 * (T7 - c0c2)  + T7\n      c1: Fp6.create({\n        c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9), // 2 * (T9 + c1c0) + T9\n        c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4), // 2 * (T4 + c1c1) + T4\n        c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6),\n      }),\n    }; // 2 * (T6 + c1c2) + T6\n  }\n  // https://eprint.iacr.org/2009/565.pdf\n  _cyclotomicExp(num: Fp12, n: bigint): Fp12 {\n    let z = this.ONE;\n    for (let i = this.X_LEN - 1; i >= 0; i--) {\n      z = this._cyclotomicSquare(z);\n      if (bitGet(n, i)) z = this.mul(z, num);\n    }\n    return z;\n  }\n}\n\nexport function tower12(opts: Tower12Opts): {\n  Fp: Readonly<mod.IField<bigint> & Required<Pick<mod.IField<bigint>, 'isOdd'>>>;\n  Fp2: Fp2Bls;\n  Fp6: Fp6Bls;\n  Fp12: Fp12Bls;\n} {\n  const Fp = mod.Field(opts.ORDER);\n  const Fp2 = new _Field2(Fp, opts);\n  const Fp6 = new _Field6(Fp2);\n  const Fp12 = new _Field12(Fp6, opts);\n  return { Fp, Fp2, Fp6, Fp12 };\n}\n", "/**\n * bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\n\n* Construct zk-SNARKs at the ~120-bit security, as per [Barbulescu-Duquesne 2017](https://hal.science/hal-01534101/file/main.pdf)\n* Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\nthe Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\n\nBLS can mean 2 different things:\n\n* Barreto-Lynn-Scott: BLS12, a Pairing Friendly Elliptic Curve\n* Boneh-Lynn-Shacham: A Signature Scheme.\n\n### Summary\n\n1. BLS Relies on expensive bilinear pairing\n2. Secret Keys: 32 bytes\n3. Public Keys: 48 OR 96 bytes - big-endian x coordinate of point on G1 OR G2 curve\n4. Signatures: 96 OR 48 bytes - big-endian x coordinate of point on G2 OR G1 curve\n5. The 12 stands for the Embedding degree.\n\nModes of operation:\n\n* Long signatures:  48-byte keys + 96-byte sigs (G1 keys + G2 sigs).\n* Short signatures: 96-byte keys + 48-byte sigs (G2 keys + G1 sigs).\n\n### Formulas\n\n- `P = pk x G` - public keys\n- `S = pk x H(m)` - signing, uses hash-to-curve on m\n- `e(P, H(m)) == e(G, S)` - verification using pairings\n- `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\n\n### Curves\n\nG1 is ordinary elliptic curve. G2 is extension field curve, think \"over complex numbers\".\n\n- G1: y² = x³ + 4\n- G2: y² = x³ + 4(u + 1) where u = √−1; r-order subgroup of E'(Fp²), M-type twist\n\n### Towers\n\nPairing G1 + G2 produces element in Fp₁₂, 12-degree polynomial.\nFp₁₂ is usually implemented using tower of lower-degree polynomials for speed.\n\n- Fp₁₂ = Fp₆² => Fp₂³\n- Fp(u) / (u² - β) where β = -1\n- Fp₂(v) / (v³ - ξ) where ξ = u + 1\n- Fp₆(w) / (w² - γ) where γ = v\n- Fp²[u] = Fp/u²+1\n- Fp⁶[v] = Fp²/v³-1-u\n- Fp¹²[w] = Fp⁶/w²-v\n\n### Params\n\n* Embedding degree (k): 12\n* Seed is sometimes named x or t\n* t = -15132376222941642752\n* p = (t-1)² * (t⁴-t²+1)/3 + t\n* r = t⁴-t²+1\n* Ate loop size: X\n\nTo verify curve parameters, see\n[pairing-friendly-curves spec](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11).\nBasic math is done over finite fields over p.\nMore complicated math is done over polynominal extension fields.\n\n### Compatibility and notes\n1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC.\nFilecoin uses little endian byte arrays for secret keys - make sure to reverse byte order.\n2. Make sure to correctly select mode: \"long signature\" or \"short signature\".\n3. Compatible with specs:\n   RFC 9380,\n   [cfrg-pairing-friendly-curves-11](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11),\n   [cfrg-bls-signature-05](https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/).\n\n *\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { bls, type CurveFn } from './abstract/bls.ts';\nimport { Field, type IField } from './abstract/modular.ts';\nimport {\n  abytes,\n  bitLen,\n  bitMask,\n  bytesToHex,\n  bytesToNumberBE,\n  concatBytes,\n  ensureBytes,\n  numberToBytesBE,\n  type Hex,\n} from './utils.ts';\n// Types\nimport { isogenyMap } from './abstract/hash-to-curve.ts';\nimport type { BigintTuple, Fp, Fp12, Fp2, Fp6 } from './abstract/tower.ts';\nimport { psiFrobenius, tower12 } from './abstract/tower.ts';\nimport {\n  mapToCurveSimpleSWU,\n  type AffinePoint,\n  type WeierstrassOpts,\n  type WeierstrassPoint,\n  type WeierstrassPointCons,\n} from './abstract/weierstrass.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\n// To verify math:\n// https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11\n\n// The BLS parameter x (seed) for BLS12-381. NOTE: it is negative!\n// x = -2^63 - 2^62 - 2^60 - 2^57 - 2^48 - 2^16\nconst BLS_X = BigInt('0xd201000000010000');\n// t = x (called differently in different places)\n// const t = -BLS_X;\nconst BLS_X_LEN = bitLen(BLS_X);\n\n// a=0, b=4\n// P is characteristic of field Fp, in which curve calculations are done.\n// p = (t-1)² * (t⁴-t²+1)/3 + t\n// bls12_381_Fp = (t-1n)**2n * (t**4n - t**2n + 1n) / 3n + t\n// r*h is curve order, amount of points on curve,\n// where r is order of prime subgroup and h is cofactor.\n// r = t⁴-t²+1\n// r = (t**4n - t**2n + 1n)\n// cofactor h of G1: (t - 1)²/3\n// cofactorG1 = (t-1n)**2n/3n\n// x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n// y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\nconst bls12_381_CURVE_G1: WeierstrassOpts<bigint> = {\n  p: BigInt(\n    '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'\n  ),\n  n: BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'),\n  h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),\n  a: _0n,\n  b: _4n,\n  Gx: BigInt(\n    '0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'\n  ),\n  Gy: BigInt(\n    '0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'\n  ),\n};\n\n// CURVE FIELDS\nexport const bls12_381_Fr: IField<bigint> = Field(bls12_381_CURVE_G1.n, {\n  modFromBytes: true,\n  isLE: true,\n});\nconst { Fp, Fp2, Fp6, Fp12 } = tower12({\n  ORDER: bls12_381_CURVE_G1.p,\n  X_LEN: BLS_X_LEN,\n  // Finite extension field over irreducible polynominal.\n  // Fp(u) / (u² - β) where β = -1\n  FP2_NONRESIDUE: [_1n, _1n],\n  Fp2mulByB: ({ c0, c1 }) => {\n    const t0 = Fp.mul(c0, _4n); // 4 * c0\n    const t1 = Fp.mul(c1, _4n); // 4 * c1\n    // (T0-T1) + (T0+T1)*i\n    return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };\n  },\n  Fp12finalExponentiate: (num) => {\n    const x = BLS_X;\n    // this^(q⁶) / this\n    const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\n    // t0^(q²) * t0\n    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\n    const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\n    const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\n    const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\n    const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\n    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\n    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\n    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\n    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\n    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\n    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\n    // (t2 * t5)^(q²) * (t4 * t1)^(q³) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\n    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\n  },\n});\n\n// GLV endomorphism Ψ(P), for fast cofactor clearing\nconst { G2psi, G2psi2 } = psiFrobenius(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE)); // 1/(u+1)\n\n/**\n * Default hash_to_field / hash-to-curve for BLS.\n * m: 1 for G1, 2 for G2\n * k: target security level in bits\n * hash: any function, e.g. BBS+ uses BLAKE2: see [github](https://github.com/hyperledger/aries-framework-go/issues/2247).\n * Parameter values come from [section 8.8.2 of RFC 9380](https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2).\n */\nconst htfDefaults = Object.freeze({\n  DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n  encodeDST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n  p: Fp.ORDER,\n  m: 2,\n  k: 128,\n  expand: 'xmd',\n  hash: sha256,\n});\n\n// a=0, b=4\n// cofactor h of G2\n// (t^8 - 4t^7 + 5t^6 - 4t^4 + 6t^3 - 4t^2 - 4t + 13)/9\n// cofactorG2 = (t**8n - 4n*t**7n + 5n*t**6n - 4n*t**4n + 6n*t**3n - 4n*t**2n - 4n*t+13n)/9n\n// x = 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758*u + 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n// y = 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582*u + 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\nconst bls12_381_CURVE_G2 = {\n  p: Fp2.ORDER,\n  n: bls12_381_CURVE_G1.n,\n  h: BigInt(\n    '0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'\n  ),\n  a: Fp2.ZERO,\n  b: Fp2.fromBigTuple([_4n, _4n]),\n  Gx: Fp2.fromBigTuple([\n    BigInt(\n      '0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'\n    ),\n    BigInt(\n      '0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e'\n    ),\n  ]),\n  Gy: Fp2.fromBigTuple([\n    BigInt(\n      '0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'\n    ),\n    BigInt(\n      '0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be'\n    ),\n  ]),\n};\n\n// Encoding utils\n// Compressed point of infinity\n// Set compressed & point-at-infinity bits\nconst COMPZERO = setMask(Fp.toBytes(_0n), { infinity: true, compressed: true });\n\nfunction parseMask(bytes: Uint8Array) {\n  // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\n  bytes = bytes.slice();\n  const mask = bytes[0] & 0b1110_0000;\n  const compressed = !!((mask >> 7) & 1); // compression bit (0b1000_0000)\n  const infinity = !!((mask >> 6) & 1); // point at infinity bit (0b0100_0000)\n  const sort = !!((mask >> 5) & 1); // sort bit (0b0010_0000)\n  bytes[0] &= 0b0001_1111; // clear mask (zero first 3 bits)\n  return { compressed, infinity, sort, value: bytes };\n}\n\nfunction setMask(\n  bytes: Uint8Array,\n  mask: { compressed?: boolean; infinity?: boolean; sort?: boolean }\n) {\n  if (bytes[0] & 0b1110_0000) throw new Error('setMask: non-empty mask');\n  if (mask.compressed) bytes[0] |= 0b1000_0000;\n  if (mask.infinity) bytes[0] |= 0b0100_0000;\n  if (mask.sort) bytes[0] |= 0b0010_0000;\n  return bytes;\n}\n\nfunction pointG1ToBytes(\n  _c: WeierstrassPointCons<Fp>,\n  point: WeierstrassPoint<Fp>,\n  isComp: boolean\n) {\n  const { BYTES: L, ORDER: P } = Fp;\n  const is0 = point.is0();\n  const { x, y } = point.toAffine();\n  if (isComp) {\n    if (is0) return COMPZERO.slice();\n    const sort = Boolean((y * _2n) / P);\n    return setMask(numberToBytesBE(x, L), { compressed: true, sort });\n  } else {\n    if (is0) {\n      return concatBytes(Uint8Array.of(0x40), new Uint8Array(2 * L - 1));\n    } else {\n      return concatBytes(numberToBytesBE(x, L), numberToBytesBE(y, L));\n    }\n  }\n}\n\nfunction signatureG1ToBytes(point: WeierstrassPoint<Fp>) {\n  point.assertValidity();\n  const { BYTES: L, ORDER: P } = Fp;\n  const { x, y } = point.toAffine();\n  if (point.is0()) return COMPZERO.slice();\n  const sort = Boolean((y * _2n) / P);\n  return setMask(numberToBytesBE(x, L), { compressed: true, sort });\n}\n\nfunction pointG1FromBytes(bytes: Uint8Array): AffinePoint<Fp> {\n  const { compressed, infinity, sort, value } = parseMask(bytes);\n  const { BYTES: L, ORDER: P } = Fp;\n  if (value.length === 48 && compressed) {\n    const compressedValue = bytesToNumberBE(value);\n    // Zero\n    const x = Fp.create(compressedValue & bitMask(Fp.BITS));\n    if (infinity) {\n      if (x !== _0n) throw new Error('invalid G1 point: non-empty, at infinity, with compression');\n      return { x: _0n, y: _0n };\n    }\n    const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381_CURVE_G1.b)); // y² = x³ + b\n    let y = Fp.sqrt(right);\n    if (!y) throw new Error('invalid G1 point: compressed point');\n    if ((y * _2n) / P !== BigInt(sort)) y = Fp.neg(y);\n    return { x: Fp.create(x), y: Fp.create(y) };\n  } else if (value.length === 96 && !compressed) {\n    // Check if the infinity flag is set\n    const x = bytesToNumberBE(value.subarray(0, L));\n    const y = bytesToNumberBE(value.subarray(L));\n    if (infinity) {\n      if (x !== _0n || y !== _0n) throw new Error('G1: non-empty point at infinity');\n      return bls12_381.G1.Point.ZERO.toAffine();\n    }\n    return { x: Fp.create(x), y: Fp.create(y) };\n  } else {\n    throw new Error('invalid G1 point: expected 48/96 bytes');\n  }\n}\n\nfunction signatureG1FromBytes(hex: Hex): WeierstrassPoint<Fp> {\n  const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex, 48));\n  const P = Fp.ORDER;\n  const Point = bls12_381.G1.Point;\n  const compressedValue = bytesToNumberBE(value);\n  // Zero\n  if (infinity) return Point.ZERO;\n  const x = Fp.create(compressedValue & bitMask(Fp.BITS));\n  const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381_CURVE_G1.b)); // y² = x³ + b\n  let y = Fp.sqrt(right);\n  if (!y) throw new Error('invalid G1 point: compressed');\n  const aflag = BigInt(sort);\n  if ((y * _2n) / P !== aflag) y = Fp.neg(y);\n  const point = Point.fromAffine({ x, y });\n  point.assertValidity();\n  return point;\n}\n\nfunction pointG2ToBytes(\n  _c: WeierstrassPointCons<Fp2>,\n  point: WeierstrassPoint<Fp2>,\n  isComp: boolean\n) {\n  const { BYTES: L, ORDER: P } = Fp;\n  const is0 = point.is0();\n  const { x, y } = point.toAffine();\n  if (isComp) {\n    if (is0) return concatBytes(COMPZERO, numberToBytesBE(_0n, L));\n    const flag = Boolean(y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P);\n    return concatBytes(\n      setMask(numberToBytesBE(x.c1, L), { compressed: true, sort: flag }),\n      numberToBytesBE(x.c0, L)\n    );\n  } else {\n    if (is0) return concatBytes(Uint8Array.of(0x40), new Uint8Array(4 * L - 1));\n    const { re: x0, im: x1 } = Fp2.reim(x);\n    const { re: y0, im: y1 } = Fp2.reim(y);\n    return concatBytes(\n      numberToBytesBE(x1, L),\n      numberToBytesBE(x0, L),\n      numberToBytesBE(y1, L),\n      numberToBytesBE(y0, L)\n    );\n  }\n}\n\nfunction signatureG2ToBytes(point: WeierstrassPoint<Fp2>) {\n  point.assertValidity();\n  const { BYTES: L } = Fp;\n  if (point.is0()) return concatBytes(COMPZERO, numberToBytesBE(_0n, L));\n  const { x, y } = point.toAffine();\n  const { re: x0, im: x1 } = Fp2.reim(x);\n  const { re: y0, im: y1 } = Fp2.reim(y);\n  const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\n  const sort = Boolean((tmp / Fp.ORDER) & _1n);\n  const z2 = x0;\n  return concatBytes(\n    setMask(numberToBytesBE(x1, L), { sort, compressed: true }),\n    numberToBytesBE(z2, L)\n  );\n}\n\nfunction pointG2FromBytes(bytes: Uint8Array): AffinePoint<Fp2> {\n  const { BYTES: L, ORDER: P } = Fp;\n  const { compressed, infinity, sort, value } = parseMask(bytes);\n  if (\n    (!compressed && !infinity && sort) || // 00100000\n    (!compressed && infinity && sort) || // 01100000\n    (sort && infinity && compressed) // 11100000\n  ) {\n    throw new Error('invalid encoding flag: ' + (bytes[0] & 0b1110_0000));\n  }\n  const slc = (b: Uint8Array, from: number, to?: number) => bytesToNumberBE(b.slice(from, to));\n  if (value.length === 96 && compressed) {\n    if (infinity) {\n      // check that all bytes are 0\n      if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n        throw new Error('invalid G2 point: compressed');\n      }\n      return { x: Fp2.ZERO, y: Fp2.ZERO };\n    }\n    const x_1 = slc(value, 0, L);\n    const x_0 = slc(value, L, 2 * L);\n    const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });\n    const right = Fp2.add(Fp2.pow(x, _3n), bls12_381_CURVE_G2.b); // y² = x³ + 4 * (u+1) = x³ + b\n    let y = Fp2.sqrt(right);\n    const Y_bit = y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P ? _1n : _0n;\n    y = sort && Y_bit > 0 ? y : Fp2.neg(y);\n    return { x, y };\n  } else if (value.length === 192 && !compressed) {\n    if (infinity) {\n      if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n        throw new Error('invalid G2 point: uncompressed');\n      }\n      return { x: Fp2.ZERO, y: Fp2.ZERO };\n    }\n    const x1 = slc(value, 0 * L, 1 * L);\n    const x0 = slc(value, 1 * L, 2 * L);\n    const y1 = slc(value, 2 * L, 3 * L);\n    const y0 = slc(value, 3 * L, 4 * L);\n    return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };\n  } else {\n    throw new Error('invalid G2 point: expected 96/192 bytes');\n  }\n}\n\nfunction signatureG2FromBytes(hex: Hex) {\n  const { ORDER: P } = Fp;\n  // TODO: Optimize, it's very slow because of sqrt.\n  const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex));\n  const Point = bls12_381.G2.Point;\n  const half = value.length / 2;\n  if (half !== 48 && half !== 96)\n    throw new Error('invalid compressed signature length, expected 96/192 bytes');\n  const z1 = bytesToNumberBE(value.slice(0, half));\n  const z2 = bytesToNumberBE(value.slice(half));\n  // Indicates the infinity point\n  if (infinity) return Point.ZERO;\n  const x1 = Fp.create(z1 & bitMask(Fp.BITS));\n  const x2 = Fp.create(z2);\n  const x = Fp2.create({ c0: x2, c1: x1 });\n  const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381_CURVE_G2.b); // y² = x³ + 4\n  // The slow part\n  let y = Fp2.sqrt(y2);\n  if (!y) throw new Error('Failed to find a square root');\n\n  // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n  // If y1 happens to be zero, then use the bit of y0\n  const { re: y0, im: y1 } = Fp2.reim(y);\n  const aflag1 = BigInt(sort);\n  const isGreater = y1 > _0n && (y1 * _2n) / P !== aflag1;\n  const is0 = y1 === _0n && (y0 * _2n) / P !== aflag1;\n  if (isGreater || is0) y = Fp2.neg(y);\n  const point = Point.fromAffine({ x, y });\n  point.assertValidity();\n  return point;\n}\n\n/**\n * bls12-381 pairing-friendly curve.\n * @example\n * import { bls12_381 as bls } from '@noble/curves/bls12-381';\n * // G1 keys, G2 signatures\n * const privateKey = '67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c';\n * const message = '64726e3da8';\n * const publicKey = bls.getPublicKey(privateKey);\n * const signature = bls.sign(message, privateKey);\n * const isValid = bls.verify(signature, message, publicKey);\n */\nexport const bls12_381: CurveFn = bls({\n  // Fields\n  fields: {\n    Fp,\n    Fp2,\n    Fp6,\n    Fp12,\n    Fr: bls12_381_Fr,\n  },\n  // G1: y² = x³ + 4\n  G1: {\n    ...bls12_381_CURVE_G1,\n    Fp,\n    htfDefaults: { ...htfDefaults, m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    // Checks is the point resides in prime-order subgroup.\n    // point.isTorsionFree() should return true for valid points\n    // It returns false for shitty points.\n    // https://eprint.iacr.org/2021/1130.pdf\n    isTorsionFree: (c, point): boolean => {\n      // GLV endomorphism ψ(P)\n      const beta = BigInt(\n        '0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'\n      );\n      const phi = new c(Fp.mul(point.X, beta), point.Y, point.Z);\n      // TODO: unroll\n      const xP = point.multiplyUnsafe(BLS_X).negate(); // [x]P\n      const u2P = xP.multiplyUnsafe(BLS_X); // [u2]P\n      return u2P.equals(phi);\n    },\n    // Clear cofactor of G1\n    // https://eprint.iacr.org/2019/403\n    clearCofactor: (_c, point) => {\n      // return this.multiplyUnsafe(CURVE.h);\n      return point.multiplyUnsafe(BLS_X).add(point); // x*P + P\n    },\n    mapToCurve: mapToG1,\n    fromBytes: pointG1FromBytes,\n    toBytes: pointG1ToBytes,\n    ShortSignature: {\n      fromBytes(bytes: Uint8Array) {\n        abytes(bytes);\n        return signatureG1FromBytes(bytes);\n      },\n      fromHex(hex: Hex): WeierstrassPoint<Fp> {\n        return signatureG1FromBytes(hex);\n      },\n      toBytes(point: WeierstrassPoint<Fp>) {\n        return signatureG1ToBytes(point);\n      },\n      toRawBytes(point: WeierstrassPoint<Fp>) {\n        return signatureG1ToBytes(point);\n      },\n      toHex(point: WeierstrassPoint<Fp>) {\n        return bytesToHex(signatureG1ToBytes(point));\n      },\n    },\n  },\n  G2: {\n    ...bls12_381_CURVE_G2,\n    Fp: Fp2,\n    // https://datatracker.ietf.org/doc/html/rfc9380#name-clearing-the-cofactor\n    // https://datatracker.ietf.org/doc/html/rfc9380#name-cofactor-clearing-for-bls12\n    hEff: BigInt(\n      '0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'\n    ),\n    htfDefaults: { ...htfDefaults },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    mapToCurve: mapToG2,\n    // Checks is the point resides in prime-order subgroup.\n    // point.isTorsionFree() should return true for valid points\n    // It returns false for shitty points.\n    // https://eprint.iacr.org/2021/1130.pdf\n    // Older version: https://eprint.iacr.org/2019/814.pdf\n    isTorsionFree: (c, P): boolean => {\n      return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P)); // ψ(P) == [u](P)\n    },\n    // Maps the point into the prime-order subgroup G2.\n    // clear_cofactor_bls12381_g2 from RFC 9380.\n    // https://eprint.iacr.org/2017/419.pdf\n    // prettier-ignore\n    clearCofactor: (c, P) => {\n      const x = BLS_X;\n      let t1 = P.multiplyUnsafe(x).negate();  // [-x]P\n      let t2 = G2psi(c, P);                   // Ψ(P)\n      let t3 = P.double();                    // 2P\n      t3 = G2psi2(c, t3);                     // Ψ²(2P)\n      t3 = t3.subtract(t2);                   // Ψ²(2P) - Ψ(P)\n      t2 = t1.add(t2);                        // [-x]P + Ψ(P)\n      t2 = t2.multiplyUnsafe(x).negate();     // [x²]P - [x]Ψ(P)\n      t3 = t3.add(t2);                        // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P)\n      t3 = t3.subtract(t1);                   // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P\n      const Q = t3.subtract(P);               // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P - 1P\n      return Q;                               // [x²-x-1]P + [x-1]Ψ(P) + Ψ²(2P)\n    },\n    fromBytes: pointG2FromBytes,\n    toBytes: pointG2ToBytes,\n    Signature: {\n      fromBytes(bytes: Uint8Array): WeierstrassPoint<Fp2> {\n        abytes(bytes);\n        return signatureG2FromBytes(bytes);\n      },\n      fromHex(hex: Hex): WeierstrassPoint<Fp2> {\n        return signatureG2FromBytes(hex);\n      },\n      toBytes(point: WeierstrassPoint<Fp2>) {\n        return signatureG2ToBytes(point);\n      },\n      toRawBytes(point: WeierstrassPoint<Fp2>) {\n        return signatureG2ToBytes(point);\n      },\n      toHex(point: WeierstrassPoint<Fp2>) {\n        return bytesToHex(signatureG2ToBytes(point));\n      },\n    },\n  },\n  params: {\n    ateLoopSize: BLS_X, // The BLS parameter x for BLS12-381\n    r: bls12_381_CURVE_G1.n, // order; z⁴ − z² + 1; CURVE.n from other curves\n    xNegative: true,\n    twistType: 'multiplicative',\n  },\n  htfDefaults,\n  hash: sha256,\n});\n\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\nconst isogenyMapG2 = isogenyMap(\n  Fp2,\n  [\n    // xNum\n    [\n      [\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n      ],\n      [\n        '0x0',\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a',\n      ],\n      [\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d',\n      ],\n      [\n        '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',\n        '0x0',\n      ],\n    ],\n    // xDen\n    [\n      [\n        '0x0',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63',\n      ],\n      [\n        '0xc',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f',\n      ],\n      ['0x1', '0x0'], // LAST 1\n    ],\n    // yNum\n    [\n      [\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n      ],\n      [\n        '0x0',\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be',\n      ],\n      [\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f',\n      ],\n      [\n        '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',\n        '0x0',\n      ],\n    ],\n    // yDen\n    [\n      [\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n      ],\n      [\n        '0x0',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3',\n      ],\n      [\n        '0x12',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99',\n      ],\n      ['0x1', '0x0'], // LAST 1\n    ],\n  ].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt) as BigintTuple))) as [\n    Fp2[],\n    Fp2[],\n    Fp2[],\n    Fp2[],\n  ]\n);\n// 11-isogeny map from E' to E\nconst isogenyMapG1 = isogenyMap(\n  Fp,\n  [\n    // xNum\n    [\n      '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',\n      '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',\n      '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',\n      '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',\n      '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',\n      '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',\n      '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',\n      '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',\n      '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',\n      '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',\n      '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',\n      '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229',\n    ],\n    // xDen\n    [\n      '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',\n      '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',\n      '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',\n      '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',\n      '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',\n      '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',\n      '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',\n      '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',\n      '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',\n      '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n      '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',\n      '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',\n      '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',\n      '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',\n      '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',\n      '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',\n      '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',\n      '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',\n      '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',\n      '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',\n      '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',\n      '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',\n      '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',\n      '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',\n      '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',\n      '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604',\n    ],\n    // yDen\n    [\n      '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',\n      '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',\n      '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',\n      '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',\n      '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',\n      '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',\n      '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',\n      '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',\n      '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',\n      '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',\n      '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',\n      '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',\n      '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',\n      '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',\n      '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n  ].map((i) => i.map((j) => BigInt(j))) as [Fp[], Fp[], Fp[], Fp[]]\n);\n\n// Optimized SWU Map - Fp to G1\nconst G1_SWU = mapToCurveSimpleSWU(Fp, {\n  A: Fp.create(\n    BigInt(\n      '0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d'\n    )\n  ),\n  B: Fp.create(\n    BigInt(\n      '0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0'\n    )\n  ),\n  Z: Fp.create(BigInt(11)),\n});\n// SWU Map - Fp2 to G2': y² = x³ + 240i * x + 1012 + 1012i\nconst G2_SWU = mapToCurveSimpleSWU(Fp2, {\n  A: Fp2.create({ c0: Fp.create(_0n), c1: Fp.create(BigInt(240)) }), // A' = 240 * I\n  B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }), // B' = 1012 * (1 + I)\n  Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) }), // Z: -(2 + I)\n});\n\nfunction mapToG1(scalars: bigint[]) {\n  const { x, y } = G1_SWU(Fp.create(scalars[0]));\n  return isogenyMapG1(x, y);\n}\nfunction mapToG2(scalars: bigint[]) {\n  const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars as BigintTuple));\n  return isogenyMapG2(x, y);\n}\n"],
  "mappings": "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",
  "names": ["p256", "Fp2", "Fp12", "msg", "Fp", "Fp6", "_0n", "_1n", "_2n", "_3n", "Fp", "Fp2", "G2psi", "G2psi2", "Fp6", "Fp12", "_0n", "_1n", "_2n", "_3n"]
}
