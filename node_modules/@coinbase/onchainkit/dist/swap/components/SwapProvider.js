import { jsx } from "react/jsx-runtime";
import { RequestContext } from "../../core/network/constants.js";
import { createContext, useContext, useState, useEffect, useCallback } from "react";
import { base } from "viem/chains";
import { useAccount, useSwitchChain, useConfig, useSendTransaction } from "wagmi";
import { useSendCalls } from "wagmi/experimental";
import { buildSwapTransaction } from "../../api/buildSwapTransaction.js";
import { getSwapQuote } from "../../api/getSwapQuote.js";
import { useAnalytics } from "../../core/analytics/hooks/useAnalytics.js";
import { SwapEvent } from "../../core/analytics/types.js";
import { useCapabilitiesSafe } from "../../internal/hooks/useCapabilitiesSafe.js";
import { useLifecycleStatus } from "../../internal/hooks/useLifecycleStatus.js";
import { useValue } from "../../internal/hooks/useValue.js";
import { formatTokenAmount } from "../../internal/utils/formatTokenAmount.js";
import { GENERIC_ERROR_MESSAGE } from "../../transaction/constants.js";
import { isUserRejectedRequestError } from "../../transaction/utils/isUserRejectedRequestError.js";
import { useOnchainKit } from "../../useOnchainKit.js";
import { FALLBACK_DEFAULT_MAX_SLIPPAGE } from "../constants.js";
import { useAwaitCalls } from "../hooks/useAwaitCalls.js";
import { useFromTo } from "../hooks/useFromTo.js";
import { useResetInputs } from "../hooks/useResetInputs.js";
import { isSwapError } from "../utils/isSwapError.js";
import { processSwapTransaction } from "../utils/processSwapTransaction.js";
const emptyContext = {};
const SwapContext = createContext(emptyContext);
function useSwapContext() {
  const context = useContext(SwapContext);
  if (context === emptyContext) {
    throw new Error("useSwapContext must be used within a Swap component");
  }
  return context;
}
function SwapProvider({
  children,
  config = {
    maxSlippage: FALLBACK_DEFAULT_MAX_SLIPPAGE
  },
  experimental,
  isSponsored,
  onError,
  onStatus,
  onSuccess
}) {
  var _a, _b;
  const { config: { paymaster } = { paymaster: void 0 } } = useOnchainKit();
  const { address, chainId } = useAccount();
  const { switchChainAsync } = useSwitchChain();
  const { useAggregator } = experimental;
  const accountConfig = useConfig();
  const walletCapabilities = useCapabilitiesSafe({
    chainId: base.id
  });
  const [lifecycleStatus, updateLifecycleStatus] = useLifecycleStatus({
    statusName: "init",
    statusData: {
      isMissingRequiredField: true,
      maxSlippage: config.maxSlippage
    }
  });
  const [isToastVisible, setIsToastVisible] = useState(false);
  const [transactionHash, setTransactionHash] = useState("");
  const [hasHandledSuccess, setHasHandledSuccess] = useState(false);
  const { from, to } = useFromTo(address);
  const { sendTransactionAsync } = useSendTransaction();
  const { sendCallsAsync } = useSendCalls();
  const resetInputs = useResetInputs({ from, to });
  const awaitCallsStatus = useAwaitCalls({
    accountConfig,
    lifecycleStatus,
    updateLifecycleStatus
  });
  const { sendAnalytics } = useAnalytics();
  useEffect(() => {
    var _a2, _b2, _c, _d;
    if (lifecycleStatus.statusName === "error") {
      onError == null ? void 0 : onError(lifecycleStatus.statusData);
      sendAnalytics(SwapEvent.SwapFailure, {
        error: lifecycleStatus.statusData.error,
        metadata: lifecycleStatus.statusData
      });
    }
    if (lifecycleStatus.statusName === "success") {
      onSuccess == null ? void 0 : onSuccess(lifecycleStatus.statusData.transactionReceipt);
      setTransactionHash(
        (_a2 = lifecycleStatus.statusData) == null ? void 0 : _a2.transactionReceipt.transactionHash
      );
      setHasHandledSuccess(true);
      setIsToastVisible(true);
      sendAnalytics(SwapEvent.SwapSuccess, {
        paymaster: !!paymaster,
        transactionHash: (_b2 = lifecycleStatus.statusData.transactionReceipt) == null ? void 0 : _b2.transactionHash,
        address: address || "",
        amount: Number(from.amount),
        from: ((_c = from.token) == null ? void 0 : _c.symbol) || "",
        to: ((_d = to.token) == null ? void 0 : _d.symbol) || ""
      });
    }
    onStatus == null ? void 0 : onStatus(lifecycleStatus);
  }, [
    onError,
    onStatus,
    onSuccess,
    lifecycleStatus,
    lifecycleStatus.statusData,
    // Keep statusData, so that the effect runs when it changes
    lifecycleStatus.statusName,
    // Keep statusName, so that the effect runs when it changes
    sendAnalytics,
    paymaster,
    from.amount,
    (_a = from.token) == null ? void 0 : _a.symbol,
    (_b = to.token) == null ? void 0 : _b.symbol,
    address
  ]);
  useEffect(() => {
    if (lifecycleStatus.statusName === "init" && hasHandledSuccess) {
      setHasHandledSuccess(false);
      resetInputs();
    }
  }, [hasHandledSuccess, lifecycleStatus.statusName, resetInputs]);
  useEffect(() => {
    if (lifecycleStatus.statusName === "transactionApproved" && lifecycleStatus.statusData.transactionType === "Batched") {
      awaitCallsStatus();
    }
  }, [
    awaitCallsStatus,
    lifecycleStatus,
    lifecycleStatus.statusData,
    lifecycleStatus.statusName
  ]);
  useEffect(() => {
    if (lifecycleStatus.statusName === "success" && hasHandledSuccess) {
      updateLifecycleStatus({
        statusName: "init",
        statusData: {
          isMissingRequiredField: true,
          maxSlippage: config.maxSlippage
        }
      });
    }
  }, [
    config.maxSlippage,
    hasHandledSuccess,
    lifecycleStatus.statusName,
    updateLifecycleStatus
  ]);
  const handleToggle = useCallback(() => {
    var _a2, _b2;
    from.setAmount(to.amount);
    to.setAmount(from.amount);
    (_a2 = from.setToken) == null ? void 0 : _a2.call(from, to.token);
    (_b2 = to.setToken) == null ? void 0 : _b2.call(to, from.token);
    updateLifecycleStatus({
      statusName: "amountChange",
      statusData: {
        amountFrom: from.amount,
        amountTo: to.amount,
        tokenFrom: from.token,
        tokenTo: to.token,
        // token is missing
        isMissingRequiredField: !from.token || !to.token || !from.amount || !to.amount
      }
    });
  }, [from, to, updateLifecycleStatus]);
  const handleAmountChange = useCallback(
    async (type, amount, sToken, dToken) => {
      const source = type === "from" ? from : to;
      const destination = type === "from" ? to : from;
      source.token = sToken ?? source.token;
      destination.token = dToken ?? destination.token;
      if (source.token === void 0 || destination.token === void 0) {
        updateLifecycleStatus({
          statusName: "amountChange",
          statusData: {
            amountFrom: from.amount,
            amountTo: to.amount,
            tokenFrom: from.token,
            tokenTo: to.token,
            // token is missing
            isMissingRequiredField: true
          }
        });
        return;
      }
      if (amount === "" || amount === "." || Number.parseFloat(amount) === 0) {
        destination.setAmount("");
        destination.setAmountUSD("");
        source.setAmountUSD("");
        return;
      }
      destination.setLoading(true);
      updateLifecycleStatus({
        statusName: "amountChange",
        statusData: {
          // when fetching quote, the previous
          // amount is irrelevant
          amountFrom: type === "from" ? amount : "",
          amountTo: type === "to" ? amount : "",
          tokenFrom: from.token,
          tokenTo: to.token,
          // when fetching quote, the destination
          // amount is missing
          isMissingRequiredField: true
        }
      });
      try {
        const maxSlippage = lifecycleStatus.statusData.maxSlippage;
        const response = await getSwapQuote(
          {
            amount,
            amountReference: "from",
            from: source.token,
            maxSlippage: String(maxSlippage),
            to: destination.token,
            useAggregator
          },
          RequestContext.Swap
        );
        if (isSwapError(response)) {
          updateLifecycleStatus({
            statusName: "error",
            statusData: {
              code: response.code,
              error: response.error,
              message: ""
            }
          });
          return;
        }
        const formattedAmount = formatTokenAmount(
          response.toAmount,
          response.to.decimals
        );
        destination.setAmountUSD(response.toAmountUSD);
        destination.setAmount(formattedAmount);
        source.setAmountUSD(response.fromAmountUSD);
        updateLifecycleStatus({
          statusName: "amountChange",
          statusData: {
            amountFrom: type === "from" ? amount : formattedAmount,
            amountTo: type === "to" ? amount : formattedAmount,
            tokenFrom: from.token,
            tokenTo: to.token,
            // if quote was fetched successfully, we
            // have all required fields
            isMissingRequiredField: !formattedAmount
          }
        });
      } catch (err) {
        updateLifecycleStatus({
          statusName: "error",
          statusData: {
            code: "TmSPc01",
            // Transaction module SwapProvider component 01 error
            error: JSON.stringify(err),
            message: ""
          }
        });
      } finally {
        destination.setLoading(false);
      }
    },
    [from, to, lifecycleStatus, updateLifecycleStatus, useAggregator]
  );
  const handleSubmit = useCallback(async () => {
    if (!address || !from.token || !to.token || !from.amount) {
      return;
    }
    try {
      sendAnalytics(SwapEvent.SwapInitiated, {
        amount: Number(from.amount)
      });
      const maxSlippage = lifecycleStatus.statusData.maxSlippage;
      const response = await buildSwapTransaction(
        {
          amount: from.amount,
          fromAddress: address,
          from: from.token,
          maxSlippage: String(maxSlippage),
          to: to.token,
          useAggregator
        },
        RequestContext.Swap
      );
      if (isSwapError(response)) {
        updateLifecycleStatus({
          statusName: "error",
          statusData: {
            code: response.code,
            error: response.error,
            message: response.message
          }
        });
        return;
      }
      await processSwapTransaction({
        chainId,
        config: accountConfig,
        isSponsored,
        paymaster: paymaster || "",
        sendCallsAsync,
        sendTransactionAsync,
        swapTransaction: response,
        switchChainAsync,
        updateLifecycleStatus,
        useAggregator,
        walletCapabilities
      });
    } catch (err) {
      const errorMessage = isUserRejectedRequestError(err) ? "Request denied." : GENERIC_ERROR_MESSAGE;
      updateLifecycleStatus({
        statusName: "error",
        statusData: {
          code: "TmSPc02",
          // Transaction module SwapProvider component 02 error
          error: JSON.stringify(err),
          message: errorMessage
        }
      });
    }
  }, [
    accountConfig,
    address,
    chainId,
    from.amount,
    from.token,
    isSponsored,
    lifecycleStatus,
    paymaster,
    sendCallsAsync,
    sendTransactionAsync,
    switchChainAsync,
    to.token,
    updateLifecycleStatus,
    useAggregator,
    walletCapabilities,
    sendAnalytics
  ]);
  const value = useValue({
    address,
    config,
    from,
    handleAmountChange,
    handleToggle,
    handleSubmit,
    lifecycleStatus,
    updateLifecycleStatus,
    to,
    isToastVisible,
    setIsToastVisible,
    setTransactionHash,
    transactionHash
  });
  return /* @__PURE__ */ jsx(SwapContext.Provider, { value, children });
}
export {
  SwapContext,
  SwapProvider,
  useSwapContext
};
//# sourceMappingURL=SwapProvider.js.map
