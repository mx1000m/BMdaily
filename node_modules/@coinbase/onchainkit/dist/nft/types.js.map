{"version":3,"file":"types.js","sources":["../../src/nft/types.ts"],"sourcesContent":["import type { UseQueryOptions } from '@tanstack/react-query';\nimport type { ReactNode } from 'react';\nimport type { Address, Hex, TransactionReceipt } from 'viem';\nimport type {\n  ContractType,\n  GetMintDetailsParams,\n  GetTokenDetailsParams,\n  NFTError,\n  NFTPrice,\n} from '../api/types';\nimport type { LifecycleStatusUpdate } from '../internal/types';\nimport type { Call } from '../transaction/types';\n\nexport enum MediaType {\n  Image = 'image',\n  Video = 'video',\n  Audio = 'audio',\n  Unknown = 'unknown',\n}\n\n/**\n * Lifecycle Provider\n */\nexport enum LifecycleType {\n  VIEW = 'view',\n  MINT = 'mint',\n}\n\nexport type NFTLifecycleProviderReact = {\n  type: LifecycleType;\n  onError?: (error: NFTError) => void;\n  onStatus?: (lifecycleStatus: LifecycleStatus) => void;\n  onSuccess?: (transactionReceipt?: TransactionReceipt) => void;\n  children: ReactNode;\n};\n\nexport type NFTLifecycleContextType = {\n  type: LifecycleType;\n  lifecycleStatus: LifecycleStatus;\n  updateLifecycleStatus: (\n    status: LifecycleStatusUpdate<LifecycleStatus>,\n  ) => void;\n};\n\n/**\n * NFT Provider\n */\nexport type NFTContextType = {\n  contractAddress: `0x${string}`;\n  tokenId?: string;\n  /** Optional boolean to determine if the mint is sponsored by paymaster */\n  isSponsored?: boolean;\n  quantity: number;\n  setQuantity: (quantity: string) => void;\n  buildMintTransaction?: BuildMintTransaction;\n} & NFTData;\n\nexport type NFTProviderReact = {\n  children: ReactNode;\n  contractAddress: `0x${string}`;\n  tokenId?: string;\n  /** Optional boolean to determine if the mint is sponsored by paymaster */\n  isSponsored?: boolean;\n  useNFTData: UseNFTData;\n  buildMintTransaction?: BuildMintTransaction;\n};\n\n/**\n * Note: exported as public Type\n */\nexport type UseNFTData = (\n  /** Contract address of the NFT */\n  contractAddress: Hex,\n  /** Token ID of the NFT */\n  tokenId?: string,\n) => NFTData | NFTError;\n\n/**\n * Note: exported as public Type\n */\nexport type NFTData = {\n  /** required for NFTTitle and NFTCollectionTitle */\n  name?: string;\n  /** not currently used */\n  description?: string;\n  /** required for NFTMedia */\n  imageUrl?: string;\n  /** required for NFTMedia (audio and video types) */\n  animationUrl?: string;\n  /** supported mimeTypes:\n   * image = image/*\n   * video = video/*\n   * audio = audio/* | application/*\n   */\n  /** required for NFTLastSoldPrice */\n  lastSoldPrice?: NFTPrice;\n  /** required for NFTMedia (falls back to image) */\n  mimeType?: string;\n\n  /** required for NFTOwner */\n  ownerAddress?: `0x${string}`;\n  /** not currently used */\n  contractType?: ContractType;\n  /** required for NFTMintDate */\n  mintDate?: Date;\n  /** required for NFTAssetCost, NftTotalCost */\n  price?: NFTPrice;\n  /** required for NFTTotalCost */\n  mintFee?: NFTPrice;\n  /** required for NFTCreator */\n  creatorAddress?: Hex;\n  /** required for NFTMintButton */\n  maxMintsPerWallet?: number;\n  /** required for NFTMintButton */\n  isEligibleToMint?: boolean;\n  /** required for NFTMinters */\n  totalOwners?: string;\n  /** required for NFTMinters */\n  recentOwners?: Address[];\n  /** required for default BuildMintTransaction implementation */\n  network?: string;\n};\n\n/**\n * Note: exported as public Type\n */\nexport type BuildMintTransaction = (\n  props: BuildMintTransactionDataProps,\n) => Promise<Call[]>;\n\nexport type BuildMintTransactionDataProps = {\n  /** Contract address of the NFT */\n  contractAddress: Hex;\n  /** Address of the taker */\n  takerAddress: Address;\n  /** Token ID of the NFT */\n  tokenId?: string;\n  /** Quantity of the NFT to mint */\n  quantity: number;\n  /** Network of the NFT */\n  network?: string;\n};\n\n/**\n * Note: exported as public Type\n */\nexport type UseTokenDetailsParams<T> = GetTokenDetailsParams & {\n  queryOptions?: Omit<UseQueryOptions<T>, 'queryKey' | 'queryFn'>;\n};\n\n/**\n * Note: exported as public Type\n */\nexport type UseMintDetailsParams<T> = GetMintDetailsParams & {\n  queryOptions?: Omit<UseQueryOptions<T>, 'queryKey' | 'queryFn'>;\n};\n\nexport type NFTReact = {\n  children: ReactNode;\n  className?: string;\n};\n\n/**\n * Note: exported as public Type\n */\nexport type NFTCardReact = {\n  children?: React.ReactNode;\n  /** Optional className override for top div element. */\n  className?: string;\n  /** Contract address of the NFT */\n  contractAddress: Hex;\n  /** Required Token ID of the NFT */\n  tokenId: string;\n  /** Optional hook to override the default useNftData hook */\n  useNFTData?: UseNFTData;\n  /** An optional callback function that handles errors within the provider. */\n  onError?: (error: NFTError) => void;\n  /** An optional callback function that exposes the component lifecycle state */\n  onStatus?: (lifecycleStatus: LifecycleStatus) => void;\n  /** card will not pass transactionReceipt */\n  onSuccess?: (transactionReceipt?: TransactionReceipt) => void;\n};\n\n/**\n * Note: exported as public Type\n */\nexport type NFTCardDefaultReact = Omit<NFTCardReact, 'children'>;\n\n/**\n * Note: exported as public Type\n * NFTMint must be used if the NFTMintButton is included\n */\nexport type NFTMintCardReact = {\n  children?: ReactNode;\n  /** Optional className override for top div element. */\n  className?: string;\n  /** Contract address of the NFT */\n  contractAddress: Hex;\n  /** Token ID of the NFT only required for ERC1155 */\n  tokenId?: string;\n  /** Optional boolean to determine if the mint is sponsored by paymaster */\n  isSponsored?: boolean;\n  /** Optional hook to override the default useNFTData hook */\n  useNFTData?: UseNFTData;\n  /** Optional function to override the default function that builds the mint transaction */\n  buildMintTransaction?: BuildMintTransaction;\n  /** An optional callback function that handles errors within the provider. */\n  onError?: (error: NFTError) => void;\n  /** An optional callback function that exposes the component lifecycle state */\n  onStatus?: (lifecycleStatus: LifecycleStatus) => void;\n  /** mint will pass transactionReceipt */\n  onSuccess?: (transactionReceipt?: TransactionReceipt) => void;\n};\n\n/**\n * Note: exported as public Type\n */\nexport type NFTMintCardDefaultReact = Omit<NFTMintCardReact, 'children'>;\n\nexport type LifecycleStatus =\n  | {\n      statusName: 'init';\n      statusData: null;\n    }\n  | {\n      statusName: 'error';\n      statusData: NFTError;\n    }\n  | {\n      statusName: 'mediaLoading';\n      statusData: {\n        mediaType: MediaType;\n        mediaUrl: string;\n      };\n    }\n  | {\n      statusName: 'mediaLoaded';\n      statusData: null;\n    }\n  | {\n      statusName: 'transactionPending'; // if the mutation is currently executing\n      statusData: null;\n    }\n  | {\n      statusName: 'transactionLegacyExecuted';\n      statusData: {\n        transactionHashList: Address[];\n      };\n    }\n  | {\n      statusName: 'success'; // NFTCard success state represents media loaded, NFTMintCard success state represents successful Mint\n      statusData: {\n        transactionReceipts?: TransactionReceipt[];\n      };\n    };\n"],"names":["MediaType","LifecycleType"],"mappings":"AAaY,IAAA,8BAAAA,eAAL;AACLA,aAAA,OAAQ,IAAA;AACRA,aAAA,OAAQ,IAAA;AACRA,aAAA,OAAQ,IAAA;AACRA,aAAA,SAAU,IAAA;AAJAA,SAAAA;AAAA,GAAA,aAAA,CAAA,CAAA;AAUA,IAAA,kCAAAC,mBAAL;AACLA,iBAAA,MAAO,IAAA;AACPA,iBAAA,MAAO,IAAA;AAFGA,SAAAA;AAAA,GAAA,iBAAA,CAAA,CAAA;"}