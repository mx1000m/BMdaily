import { jsx } from "react/jsx-runtime";
import { RequestContext } from "../../../../core/network/constants.js";
import { useLifecycleStatus } from "../../../../internal/hooks/useLifecycleStatus.js";
import { usePriceQuote } from "../../../../internal/hooks/usePriceQuote.js";
import { useValue } from "../../../../internal/hooks/useValue.js";
import { isApiError } from "../../../../internal/utils/isApiResponseError.js";
import { truncateDecimalPlaces } from "../../../../internal/utils/truncateDecimalPlaces.js";
import { createContext, useContext, useState, useMemo, useEffect, useCallback } from "react";
import { formatUnits } from "viem";
import { useAccount } from "wagmi";
import { usePortfolio } from "../../../hooks/usePortfolio.js";
import { useRecipientState } from "../hooks/useRecipientState.js";
const emptyContext = {};
const SendContext = createContext(emptyContext);
function useSendContext() {
  const sendContext = useContext(SendContext);
  if (sendContext === emptyContext) {
    throw new Error("useSendContext must be used within a SendProvider");
  }
  return sendContext;
}
function SendProvider({ children }) {
  var _a;
  const [selectedToken, setSelectedToken] = useState(null);
  const [selectedInputType, setSelectedInputType] = useState(
    "crypto"
  );
  const [fiatAmount, setFiatAmount] = useState(null);
  const [cryptoAmount, setCryptoAmount] = useState(null);
  const {
    recipientState,
    updateRecipientInput,
    validateRecipientInput,
    selectRecipient,
    deselectRecipient
  } = useRecipientState();
  const [lifecycleStatus, updateLifecycleStatus] = useLifecycleStatus({
    statusName: "init",
    statusData: {
      isMissingRequiredField: true
    }
  });
  const hasSufficientBalance = useMemo(() => {
    if (!selectedToken) {
      return false;
    }
    if (selectedInputType === "fiat") {
      return Number(fiatAmount) <= selectedToken.fiatBalance;
    }
    return Number(cryptoAmount) <= Number(
      formatUnits(
        BigInt(selectedToken.cryptoBalance),
        selectedToken.decimals
      )
    );
  }, [selectedInputType, selectedToken, cryptoAmount, fiatAmount]);
  const { address } = useAccount();
  const { data: portfolioData } = usePortfolio(
    { address },
    RequestContext.Wallet
  );
  const ethHolding = (_a = portfolioData == null ? void 0 : portfolioData.tokenBalances) == null ? void 0 : _a.find(
    (token) => token.address === ""
  );
  const ethBalance = ethHolding ? Number(formatUnits(BigInt(ethHolding.cryptoBalance), ethHolding.decimals)) : 0;
  const isInitialized = ethBalance !== void 0;
  useEffect(() => {
    if (!ethBalance || ethBalance === 0) {
      updateLifecycleStatus({
        statusName: "fundingWallet",
        statusData: {
          isMissingRequiredField: true
        }
      });
      return;
    }
    updateLifecycleStatus({
      statusName: "selectingAddress",
      statusData: {
        isMissingRequiredField: true
      }
    });
  }, [ethBalance, updateLifecycleStatus]);
  const { isLoading: exchangeRateLoading, data: exchangeRateData } = usePriceQuote(
    {
      token: (selectedToken == null ? void 0 : selectedToken.address) === "" ? "ETH" : selectedToken == null ? void 0 : selectedToken.address
    },
    RequestContext.Wallet
  );
  const exchangeRate = useMemo(() => {
    if (!exchangeRateData || isApiError(exchangeRateData) || exchangeRateData.priceQuotes.length === 0) {
      return 0;
    }
    return 1 / Number(exchangeRateData.priceQuotes[0].price);
  }, [exchangeRateData]);
  const handleTokenSelection = useCallback(
    (token) => {
      setSelectedToken(token);
      updateLifecycleStatus({
        statusName: "amountChange",
        statusData: {
          isMissingRequiredField: true,
          sufficientBalance: false
        }
      });
    },
    [updateLifecycleStatus]
  );
  const handleResetTokenSelection = useCallback(() => {
    setSelectedToken(null);
    setFiatAmount(null);
    setCryptoAmount(null);
    updateLifecycleStatus({
      statusName: "selectingToken",
      statusData: {
        isMissingRequiredField: true
      }
    });
  }, [updateLifecycleStatus]);
  const handleFiatAmountChange = useCallback(
    (value2) => {
      setFiatAmount(value2);
      updateLifecycleStatus({
        statusName: "amountChange",
        statusData: {
          isMissingRequiredField: true,
          sufficientBalance: hasSufficientBalance
        }
      });
    },
    [updateLifecycleStatus, hasSufficientBalance]
  );
  const handleCryptoAmountChange = useCallback(
    (value2) => {
      const truncatedValue = truncateDecimalPlaces(value2, 8);
      setCryptoAmount(truncatedValue);
      updateLifecycleStatus({
        statusName: "amountChange",
        statusData: {
          isMissingRequiredField: true,
          sufficientBalance: hasSufficientBalance
        }
      });
    },
    [updateLifecycleStatus, hasSufficientBalance]
  );
  const value = useValue({
    isInitialized,
    lifecycleStatus,
    updateLifecycleStatus,
    ethBalance,
    recipientState,
    updateRecipientInput,
    validateRecipientInput,
    selectRecipient,
    deselectRecipient,
    selectedToken,
    handleTokenSelection,
    handleResetTokenSelection,
    fiatAmount,
    handleFiatAmountChange,
    cryptoAmount,
    handleCryptoAmountChange,
    exchangeRate,
    exchangeRateLoading,
    selectedInputType,
    setSelectedInputType
  });
  return /* @__PURE__ */ jsx(SendContext.Provider, { value, children });
}
export {
  SendProvider,
  useSendContext
};
//# sourceMappingURL=SendProvider.js.map
