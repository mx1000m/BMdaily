import { jsx } from "react/jsx-runtime";
import { useLifecycleStatus } from "../../internal/hooks/useLifecycleStatus.js";
import { openPopup } from "../../internal/utils/openPopup.js";
import { createContext, useContext, useState, useRef, useCallback, useEffect } from "react";
import { base } from "viem/chains";
import { useAccount, useConnect, useSwitchChain, useWaitForTransactionReceipt } from "wagmi";
import { coinbaseWallet } from "wagmi/connectors";
import { useWriteContracts, useCallsStatus } from "wagmi/experimental";
import { useAnalytics } from "../../core/analytics/hooks/useAnalytics.js";
import { CheckoutEvent } from "../../core/analytics/types.js";
import { useValue } from "../../internal/hooks/useValue.js";
import { isUserRejectedRequestError } from "../../transaction/utils/isUserRejectedRequestError.js";
import { useOnchainKit } from "../../useOnchainKit.js";
import { useIsWalletACoinbaseSmartWallet } from "../../wallet/hooks/useIsWalletACoinbaseSmartWallet.js";
import { CHECKOUT_LIFECYCLESTATUS, GENERIC_ERROR_MESSAGE, CheckoutErrorCode, USER_REJECTED_ERROR, NO_CONNECTED_ADDRESS_ERROR, NO_CONTRACTS_ERROR } from "../constants.js";
import { useCommerceContracts } from "../hooks/useCommerceContracts.js";
import { ONRAMP_POPUP_WIDTH, ONRAMP_POPUP_HEIGHT } from "../../fund/constants.js";
import { normalizeTransactionId, normalizeStatus } from "../../internal/utils/normalizeWagmi.js";
const emptyContext = {};
const CheckoutContext = createContext(emptyContext);
function useCheckoutContext() {
  const context = useContext(CheckoutContext);
  if (context === emptyContext) {
    throw new Error(
      "useCheckoutContext must be used within a Checkout component"
    );
  }
  return context;
}
function CheckoutProvider({
  chargeHandler,
  children,
  isSponsored,
  onStatus,
  productId
}) {
  var _a, _b;
  const {
    config: { appearance, paymaster } = {
      appearance: { name: void 0, logo: void 0 },
      paymaster: void 0
    }
  } = useOnchainKit();
  const { address, chainId, isConnected } = useAccount();
  const { connectAsync } = useConnect();
  const { switchChainAsync } = useSwitchChain();
  const [chargeId, setChargeId] = useState("");
  const [transactionId, setTransactionId] = useState("");
  const [errorMessage, setErrorMessage] = useState("");
  const isSmartWallet = useIsWalletACoinbaseSmartWallet();
  const { sendAnalytics } = useAnalytics();
  const fetchedDataUseEffect = useRef(false);
  const fetchedDataHandleSubmit = useRef(false);
  const userRejectedRef = useRef(false);
  const contractsRef = useRef();
  const insufficientBalanceRef = useRef(false);
  const priceInUSDCRef = useRef("");
  const [lifecycleStatus, updateLifecycleStatus] = useLifecycleStatus({
    statusName: CHECKOUT_LIFECYCLESTATUS.INIT,
    statusData: {}
  });
  const fetchContracts = useCommerceContracts({
    chargeHandler,
    productId
  });
  const fetchData = useCallback(
    async (address2) => {
      updateLifecycleStatus({
        statusName: CHECKOUT_LIFECYCLESTATUS.FETCHING_DATA,
        statusData: {}
      });
      const {
        contracts,
        chargeId: hydratedChargeId,
        insufficientBalance,
        priceInUSDC,
        error
      } = await fetchContracts(address2);
      if (error) {
        setErrorMessage(GENERIC_ERROR_MESSAGE);
        updateLifecycleStatus({
          statusName: CHECKOUT_LIFECYCLESTATUS.ERROR,
          statusData: {
            code: CheckoutErrorCode.UNEXPECTED_ERROR,
            error: error.name,
            message: error.message
          }
        });
        return;
      }
      setChargeId(hydratedChargeId);
      contractsRef.current = contracts;
      insufficientBalanceRef.current = insufficientBalance;
      priceInUSDCRef.current = priceInUSDC;
      updateLifecycleStatus({
        statusName: CHECKOUT_LIFECYCLESTATUS.READY,
        statusData: {
          chargeId,
          contracts: contractsRef.current || []
        }
      });
    },
    [chargeId, fetchContracts, updateLifecycleStatus]
  );
  const { status, writeContractsAsync } = useWriteContracts({
    /* v8 ignore start */
    mutation: {
      onSuccess: (data2) => {
        setTransactionId(normalizeTransactionId(data2));
      }
    }
    /* v8 ignore stop */
  });
  const { data } = useCallsStatus({
    id: transactionId,
    query: {
      /* v8 ignore next 5 */
      refetchInterval: (query) => {
        var _a2;
        return normalizeStatus((_a2 = query.state.data) == null ? void 0 : _a2.status) === "success" ? false : 1e3;
      },
      enabled: !!transactionId
    }
  });
  const transactionHash = (_b = (_a = data == null ? void 0 : data.receipts) == null ? void 0 : _a[0]) == null ? void 0 : _b.transactionHash;
  const { data: receipt } = useWaitForTransactionReceipt({
    hash: transactionHash
  });
  useEffect(() => {
    onStatus == null ? void 0 : onStatus(lifecycleStatus);
  }, [
    lifecycleStatus,
    lifecycleStatus.statusData,
    // Keep statusData, so that the effect runs when it changes
    lifecycleStatus.statusName,
    // Keep statusName, so that the effect runs when it changes
    onStatus
  ]);
  useEffect(() => {
    if (status === "pending") {
      updateLifecycleStatus({
        statusName: CHECKOUT_LIFECYCLESTATUS.PENDING,
        statusData: {}
      });
    }
  }, [status, updateLifecycleStatus]);
  useEffect(() => {
    if (!receipt) {
      return;
    }
    updateLifecycleStatus({
      statusName: CHECKOUT_LIFECYCLESTATUS.SUCCESS,
      statusData: {
        transactionReceipts: [receipt],
        chargeId,
        receiptUrl: `https://commerce.coinbase.com/pay/${chargeId}/receipt`
      }
    });
  }, [chargeId, receipt, updateLifecycleStatus]);
  useEffect(() => {
    if (lifecycleStatus.statusName === CHECKOUT_LIFECYCLESTATUS.INIT && address && !fetchedDataHandleSubmit.current) {
      fetchedDataUseEffect.current = true;
      fetchData(address);
    }
  }, [address, fetchData, lifecycleStatus]);
  const handleAnalytics = useCallback(
    (event, data2) => {
      sendAnalytics(event, data2);
    },
    [sendAnalytics]
  );
  const handleSubmit = useCallback(async () => {
    var _a2;
    try {
      handleAnalytics(CheckoutEvent.CheckoutInitiated, {
        address,
        amount: Number(priceInUSDCRef.current),
        productId: productId || ""
      });
      if (lifecycleStatus.statusName === CHECKOUT_LIFECYCLESTATUS.SUCCESS) {
        window.open(
          `https://commerce.coinbase.com/pay/${chargeId}/receipt`,
          "_blank",
          "noopener,noreferrer"
        );
        return;
      }
      if (errorMessage === USER_REJECTED_ERROR) {
        setErrorMessage("");
      }
      let connectedAddress = address;
      let connectedChainId = chainId;
      if (!isConnected || !isSmartWallet) {
        fetchedDataHandleSubmit.current = true;
        const { accounts, chainId: _connectedChainId } = await connectAsync({
          /* v8 ignore next 5 */
          connector: coinbaseWallet({
            appName: (appearance == null ? void 0 : appearance.name) ?? void 0,
            appLogoUrl: (appearance == null ? void 0 : appearance.logo) ?? void 0,
            preference: "smartWalletOnly"
          })
        });
        connectedAddress = accounts[0];
        connectedChainId = _connectedChainId;
      }
      if (!connectedAddress) {
        setErrorMessage(GENERIC_ERROR_MESSAGE);
        updateLifecycleStatus({
          statusName: CHECKOUT_LIFECYCLESTATUS.ERROR,
          statusData: {
            code: CheckoutErrorCode.UNEXPECTED_ERROR,
            error: NO_CONNECTED_ADDRESS_ERROR,
            message: NO_CONNECTED_ADDRESS_ERROR
          }
        });
        return;
      }
      if (!fetchedDataUseEffect.current && !userRejectedRef.current) {
        await fetchData(connectedAddress);
      }
      if (connectedChainId !== base.id) {
        await switchChainAsync({ chainId: base.id });
      }
      if (insufficientBalanceRef.current && priceInUSDCRef.current) {
        openPopup({
          url: `https://keys.coinbase.com/fund?asset=USDC&chainId=8453&presetCryptoAmount=${priceInUSDCRef.current}`,
          target: "_blank",
          height: ONRAMP_POPUP_HEIGHT,
          width: ONRAMP_POPUP_WIDTH
        });
        insufficientBalanceRef.current = false;
        priceInUSDCRef.current = void 0;
        fetchedDataUseEffect.current = false;
        return;
      }
      if (!contractsRef.current || contractsRef.current.length === 0) {
        setErrorMessage(GENERIC_ERROR_MESSAGE);
        updateLifecycleStatus({
          statusName: CHECKOUT_LIFECYCLESTATUS.ERROR,
          statusData: {
            code: CheckoutErrorCode.UNEXPECTED_ERROR,
            error: NO_CONTRACTS_ERROR,
            message: NO_CONTRACTS_ERROR
          }
        });
        return;
      }
      await writeContractsAsync({
        contracts: contractsRef.current,
        capabilities: isSponsored && paymaster ? {
          paymasterService: {
            url: paymaster
          }
        } : void 0
      });
    } catch (error) {
      handleAnalytics(CheckoutEvent.CheckoutFailure, {
        error: error instanceof Error ? error.message : "Checkout failed",
        metadata: { error: JSON.stringify(error) }
      });
      const isUserRejectedError = ((_a2 = error.message) == null ? void 0 : _a2.includes("User denied connection request")) || isUserRejectedRequestError(error);
      const errorCode = isUserRejectedError ? CheckoutErrorCode.USER_REJECTED_ERROR : CheckoutErrorCode.UNEXPECTED_ERROR;
      const errorMessage2 = isUserRejectedError ? USER_REJECTED_ERROR : GENERIC_ERROR_MESSAGE;
      if (isUserRejectedError) {
        userRejectedRef.current = true;
      }
      setErrorMessage(errorMessage2);
      updateLifecycleStatus({
        statusName: CHECKOUT_LIFECYCLESTATUS.ERROR,
        statusData: {
          code: errorCode,
          error: JSON.stringify(error),
          message: errorMessage2
        }
      });
    }
  }, [
    address,
    appearance,
    chainId,
    chargeId,
    connectAsync,
    errorMessage,
    fetchData,
    isConnected,
    isSmartWallet,
    isSponsored,
    lifecycleStatus.statusName,
    paymaster,
    switchChainAsync,
    updateLifecycleStatus,
    writeContractsAsync,
    handleAnalytics,
    productId
  ]);
  const value = useValue({
    errorMessage,
    lifecycleStatus,
    onSubmit: handleSubmit,
    updateLifecycleStatus
  });
  return /* @__PURE__ */ jsx(CheckoutContext.Provider, { value, children });
}
export {
  CheckoutContext,
  CheckoutProvider,
  useCheckoutContext
};
//# sourceMappingURL=CheckoutProvider.js.map
