import { jsx } from "react/jsx-runtime";
import { useLifecycleStatus } from "../../internal/hooks/useLifecycleStatus.js";
import { useValue } from "../../internal/hooks/useValue.js";
import { GENERIC_ERROR_MESSAGE } from "../../transaction/constants.js";
import { isUserRejectedRequestError } from "../../transaction/utils/isUserRejectedRequestError.js";
import { createContext, useEffect, useContext } from "react";
import { useSignTypedData, useSignMessage } from "wagmi";
import { MessageType } from "../types.js";
import { validateMessage } from "../utils/validateMessage.js";
const EMPTY_CONTEXT = {};
const SignatureContext = createContext(EMPTY_CONTEXT);
function useSignatureContext() {
  const context = useContext(SignatureContext);
  if (context === EMPTY_CONTEXT) {
    throw new Error(
      "useSignatureContext must be used within a SignatureProvider"
    );
  }
  return context;
}
function SignatureProvider({
  children,
  onSuccess,
  onError,
  onStatus,
  domain,
  types,
  message,
  primaryType,
  resetAfter
}) {
  const { signTypedDataAsync, reset: resetSignTypedData } = useSignTypedData();
  const { signMessageAsync, reset: resetSignMessage } = useSignMessage();
  const [lifecycleStatus, updateLifecycleStatus] = useLifecycleStatus({
    statusName: "init",
    statusData: null
  });
  useEffect(() => {
    onStatus == null ? void 0 : onStatus(lifecycleStatus);
  }, [lifecycleStatus, onStatus]);
  useEffect(() => {
    if (lifecycleStatus.statusName === "success" && resetAfter) {
      const timeoutId = setTimeout(() => {
        resetSignMessage();
        resetSignTypedData();
        updateLifecycleStatus({
          statusName: "init",
          statusData: null
        });
      }, resetAfter);
      return () => clearTimeout(timeoutId);
    }
  }, [
    updateLifecycleStatus,
    lifecycleStatus,
    resetAfter,
    resetSignMessage,
    resetSignTypedData
  ]);
  async function handleSignTypedData({
    domain: domain2,
    types: types2,
    message: message2,
    primaryType: primaryType2
  }) {
    const signature = await signTypedDataAsync({
      domain: domain2,
      types: types2,
      message: message2,
      primaryType: primaryType2
    });
    updateLifecycleStatus({
      statusName: "success",
      statusData: {
        signature
      }
    });
    onSuccess == null ? void 0 : onSuccess(signature);
  }
  async function handleSignMessage({ message: message2 }) {
    const signature = await signMessageAsync({ message: message2 });
    updateLifecycleStatus({
      statusName: "success",
      statusData: {
        signature
      }
    });
    onSuccess == null ? void 0 : onSuccess(signature);
  }
  function handleError(err) {
    const errorMessage = isUserRejectedRequestError(err) ? "Request denied." : GENERIC_ERROR_MESSAGE;
    updateLifecycleStatus({
      statusName: "error",
      statusData: {
        code: "SmSPc01",
        // Signature module SignatureProvider component 01 error
        error: JSON.stringify(err),
        message: errorMessage
      }
    });
    onError == null ? void 0 : onError(err);
  }
  async function handleSign() {
    updateLifecycleStatus({
      statusName: "pending"
    });
    try {
      const validatedMessage = validateMessage({
        domain,
        types,
        message,
        primaryType
      });
      if (validatedMessage.type === MessageType.TYPED_DATA) {
        await handleSignTypedData(validatedMessage.data);
      } else if (validatedMessage.type === MessageType.SIGNABLE_MESSAGE) {
        await handleSignMessage(validatedMessage.data);
      } else if (validatedMessage.type === MessageType.INVALID) {
        throw new Error("Invalid message data");
      }
    } catch (err) {
      handleError(err);
    }
  }
  const value = useValue({
    lifecycleStatus,
    handleSign
  });
  return /* @__PURE__ */ jsx(SignatureContext.Provider, { value, children });
}
export {
  SignatureProvider,
  useSignatureContext
};
//# sourceMappingURL=SignatureProvider.js.map
