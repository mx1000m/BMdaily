'use client';
import { jsx, jsxs } from "react/jsx-runtime";
import { getTruncatedAmount } from "../utils/getTruncatedAmount.js";
import { Skeleton } from "../../internal/components/Skeleton.js";
import { useCallback, useMemo } from "react";
import { useAccount } from "wagmi";
import { EarnBalance } from "./EarnBalance.js";
import { useEarnContext } from "./EarnProvider.js";
function WithdrawBalance({ className }) {
  const {
    depositedBalance,
    depositedBalanceStatus: status,
    setWithdrawAmount,
    vaultToken
  } = useEarnContext();
  const { address } = useAccount();
  const handleMaxPress = useCallback(() => {
    if (depositedBalance) {
      setWithdrawAmount(depositedBalance);
    }
  }, [depositedBalance, setWithdrawAmount]);
  const balance = useMemo(() => {
    if (!depositedBalance) {
      return "0";
    }
    return getTruncatedAmount(depositedBalance.toString(), 4);
  }, [depositedBalance]);
  const title = useMemo(() => {
    if (!address) {
      return "Wallet not connected";
    }
    if (!vaultToken) {
      return /* @__PURE__ */ jsx(Skeleton, { className: "h-6 w-24" });
    }
    if (status === "pending") {
      return /* @__PURE__ */ jsxs("div", { className: "flex gap-1", children: [
        /* @__PURE__ */ jsx(Skeleton, { className: "!bg-[var(--ock-bg-alternate-active)] h-6 w-12" }),
        /* @__PURE__ */ jsx("span", { children: vaultToken == null ? void 0 : vaultToken.symbol })
      ] });
    }
    return `${balance} ${vaultToken == null ? void 0 : vaultToken.symbol}`;
  }, [balance, vaultToken, address, status]);
  const subtitle = useMemo(() => {
    if (!address) {
      return "Connect wallet to withdraw";
    }
    return "Available to withdraw";
  }, [address]);
  return /* @__PURE__ */ jsx(
    EarnBalance,
    {
      className,
      title,
      subtitle,
      onActionPress: handleMaxPress,
      showAction: balance !== "0"
    }
  );
}
export {
  WithdrawBalance
};
//# sourceMappingURL=WithdrawBalance.js.map
