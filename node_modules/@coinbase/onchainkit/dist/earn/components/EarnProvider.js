'use client';
import { jsx } from "react/jsx-runtime";
import { useBuildDepositToMorphoTx } from "../hooks/useBuildDepositToMorphoTx.js";
import { getToken } from "../utils/getToken.js";
import { useLifecycleStatus } from "../../internal/hooks/useLifecycleStatus.js";
import { useValue } from "../../internal/hooks/useValue.js";
import { useGetTokenBalance } from "../../wallet/hooks/useGetTokenBalance.js";
import { createContext, useState, useEffect, useCallback, useMemo, useContext } from "react";
import { useAccount } from "wagmi";
import { useBuildWithdrawFromMorphoTx } from "../hooks/useBuildWithdrawFromMorphoTx.js";
import { useMorphoVault } from "../hooks/useMorphoVault.js";
const EarnContext = createContext(void 0);
function EarnProvider({
  vaultAddress,
  children,
  isSponsored,
  onError,
  onStatus,
  onSuccess
}) {
  if (!vaultAddress) {
    throw new Error(
      "vaultAddress is required. For a list of vaults, see: https://app.morpho.org/base/earn"
    );
  }
  const [lifecycleStatus, updateLifecycleStatus] = useLifecycleStatus({
    statusName: "init",
    statusData: null
  });
  const { address } = useAccount();
  const [withdrawAmount, setWithdrawAmount] = useState("");
  const [depositAmount, setDepositAmount] = useState("");
  useEffect(() => {
    var _a, _b;
    if (lifecycleStatus.statusName === "error") {
      onError == null ? void 0 : onError(lifecycleStatus.statusData);
    }
    if ((lifecycleStatus == null ? void 0 : lifecycleStatus.statusName) === "success") {
      onSuccess == null ? void 0 : onSuccess((_b = (_a = lifecycleStatus == null ? void 0 : lifecycleStatus.statusData) == null ? void 0 : _a.transactionReceipts) == null ? void 0 : _b[0]);
    }
    onStatus == null ? void 0 : onStatus(lifecycleStatus);
  }, [lifecycleStatus, onStatus, onError, onSuccess]);
  const {
    asset,
    balance: depositedBalance,
    balanceStatus: depositedBalanceStatus,
    refetchBalance: refetchDepositedBalance,
    totalApy,
    nativeApy,
    vaultFee,
    vaultName,
    deposits,
    liquidity,
    rewards,
    error
  } = useMorphoVault({
    vaultAddress,
    recipientAddress: address
  });
  const vaultToken = asset ? getToken({
    address: asset.address,
    symbol: asset.symbol,
    name: asset.symbol,
    decimals: asset.decimals
  }) : void 0;
  const {
    convertedBalance: walletBalance,
    status: walletBalanceStatus,
    refetch: refetchWalletBalance
  } = useGetTokenBalance(address, vaultToken);
  const { calls: depositCalls } = useBuildDepositToMorphoTx({
    vaultAddress,
    amount: depositAmount,
    recipientAddress: address
  });
  const { calls: withdrawCalls } = useBuildWithdrawFromMorphoTx({
    vaultAddress,
    amount: withdrawAmount,
    recipientAddress: address,
    tokenDecimals: vaultToken == null ? void 0 : vaultToken.decimals
  });
  const handleDepositAmount = useCallback(
    async (amount) => {
      updateLifecycleStatus({
        statusName: "amountChange",
        statusData: { amount, token: vaultToken }
      });
      setDepositAmount(amount);
    },
    [updateLifecycleStatus, vaultToken]
  );
  const handleWithdrawAmount = useCallback(
    async (amount) => {
      updateLifecycleStatus({
        statusName: "amountChange",
        statusData: { amount, token: vaultToken }
      });
      setWithdrawAmount(amount);
    },
    [updateLifecycleStatus, vaultToken]
  );
  const depositAmountError = useMemo(() => {
    if (!depositAmount) {
      return null;
    }
    if (Number(depositAmount) <= 0) {
      return "Must be greater than 0";
    }
    if (Number(depositAmount) > Number(walletBalance)) {
      return "Amount exceeds the balance";
    }
    return null;
  }, [depositAmount, walletBalance]);
  const withdrawAmountError = useMemo(() => {
    if (!withdrawAmount) {
      return null;
    }
    if (Number(withdrawAmount) === 0) {
      return "Must be greater than 0";
    }
    if (Number(withdrawAmount) > Number(depositedBalance)) {
      return "Amount exceeds the balance";
    }
    return null;
  }, [withdrawAmount, depositedBalance]);
  const value = useValue({
    error,
    recipientAddress: address,
    vaultAddress,
    vaultToken,
    vaultName,
    deposits,
    liquidity,
    depositedBalance,
    depositedBalanceStatus,
    refetchDepositedBalance,
    depositAmount,
    setDepositAmount: handleDepositAmount,
    depositAmountError,
    withdrawAmount,
    setWithdrawAmount: handleWithdrawAmount,
    withdrawAmountError,
    walletBalance,
    walletBalanceStatus,
    refetchWalletBalance,
    apy: totalApy,
    nativeApy,
    vaultFee,
    rewards,
    // TODO: update when we have logic to fetch interest
    interestEarned: "",
    withdrawCalls,
    depositCalls,
    lifecycleStatus,
    updateLifecycleStatus,
    isSponsored
  });
  return /* @__PURE__ */ jsx(EarnContext.Provider, { value, children });
}
function useEarnContext() {
  const context = useContext(EarnContext);
  if (!context) {
    throw new Error("useEarnContext must be used within an EarnProvider");
  }
  return context;
}
export {
  EarnProvider,
  useEarnContext
};
//# sourceMappingURL=EarnProvider.js.map
