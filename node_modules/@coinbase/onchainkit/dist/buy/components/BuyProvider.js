'use client';
import { jsx } from "react/jsx-runtime";
import { RequestContext } from "../../core/network/constants.js";
import { useLifecycleStatus } from "../../internal/hooks/useLifecycleStatus.js";
import { createContext, useContext, useState, useEffect, useCallback } from "react";
import { base } from "viem/chains";
import { useAccount, useSwitchChain, useConfig, useSendTransaction } from "wagmi";
import { useSendCalls } from "wagmi/experimental";
import { buildSwapTransaction } from "../../api/buildSwapTransaction.js";
import { useAnalytics } from "../../core/analytics/hooks/useAnalytics.js";
import { BuyEvent } from "../../core/analytics/types.js";
import { useCapabilitiesSafe } from "../../internal/hooks/useCapabilitiesSafe.js";
import { useValue } from "../../internal/hooks/useValue.js";
import { FALLBACK_DEFAULT_MAX_SLIPPAGE } from "../../swap/constants.js";
import { useAwaitCalls } from "../../swap/hooks/useAwaitCalls.js";
import { isSwapError } from "../../swap/utils/isSwapError.js";
import { processSwapTransaction } from "../../swap/utils/processSwapTransaction.js";
import { GENERIC_ERROR_MESSAGE } from "../../transaction/constants.js";
import { isUserRejectedRequestError } from "../../transaction/utils/isUserRejectedRequestError.js";
import { useOnchainKit } from "../../useOnchainKit.js";
import { useBuyTokens } from "../hooks/useBuyTokens.js";
import { useOnrampEventListeners } from "../hooks/useOnrampEventListeners.js";
import { usePopupMonitor } from "../hooks/usePopupMonitor.js";
import { useResetBuyInputs } from "../hooks/useResetBuyInputs.js";
import { getBuyQuote } from "../utils/getBuyQuote.js";
import { validateQuote } from "../utils/validateQuote.js";
const emptyContext = {};
const BuyContext = createContext(emptyContext);
function useBuyContext() {
  const context = useContext(BuyContext);
  if (context === emptyContext) {
    throw new Error("useBuyContext must be used within a Buy component");
  }
  return context;
}
function BuyProvider({
  children,
  config = {
    maxSlippage: FALLBACK_DEFAULT_MAX_SLIPPAGE
  },
  disabled,
  experimental,
  isSponsored,
  onError,
  onStatus,
  onSuccess,
  toToken,
  fromToken
}) {
  const { config: { paymaster } = { paymaster: void 0 }, projectId } = useOnchainKit();
  const { address, chainId } = useAccount();
  const { switchChainAsync } = useSwitchChain();
  const { useAggregator } = experimental;
  const accountConfig = useConfig();
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const walletCapabilities = useCapabilitiesSafe({
    chainId: base.id
  });
  const [lifecycleStatus, updateLifecycleStatus] = useLifecycleStatus({
    statusName: "init",
    statusData: {
      isMissingRequiredField: true,
      maxSlippage: config.maxSlippage
    }
  });
  const [transactionHash, setTransactionHash] = useState("");
  const [hasHandledSuccess, setHasHandledSuccess] = useState(false);
  const { from, fromETH, fromUSDC, to } = useBuyTokens(
    toToken,
    fromToken,
    address
  );
  const { sendTransactionAsync } = useSendTransaction();
  const { sendCallsAsync } = useSendCalls();
  const resetInputs = useResetBuyInputs({ fromETH, fromUSDC, from, to });
  const awaitCallsStatus = useAwaitCalls({
    accountConfig,
    lifecycleStatus,
    updateLifecycleStatus
  });
  const { onPopupClose } = useOnrampEventListeners({
    updateLifecycleStatus,
    maxSlippage: config.maxSlippage,
    lifecycleStatus
  });
  const { startPopupMonitor } = usePopupMonitor(onPopupClose);
  const { sendAnalytics } = useAnalytics();
  useEffect(() => {
    var _a, _b, _c;
    if (lifecycleStatus.statusName === "error") {
      onError == null ? void 0 : onError(lifecycleStatus.statusData);
    }
    if (lifecycleStatus.statusName === "success") {
      onSuccess == null ? void 0 : onSuccess(lifecycleStatus == null ? void 0 : lifecycleStatus.statusData.transactionReceipt);
      const txHash = (_a = lifecycleStatus.statusData.transactionReceipt) == null ? void 0 : _a.transactionHash;
      setTransactionHash(txHash);
      setHasHandledSuccess(true);
      sendAnalytics(BuyEvent.BuySuccess, {
        address,
        amount: Number(from == null ? void 0 : from.amount),
        from: (_b = from == null ? void 0 : from.token) == null ? void 0 : _b.address,
        paymaster: !!paymaster,
        to: (_c = to == null ? void 0 : to.token) == null ? void 0 : _c.address,
        transactionHash: txHash
      });
    }
    onStatus == null ? void 0 : onStatus(lifecycleStatus);
  }, [
    onError,
    onStatus,
    onSuccess,
    lifecycleStatus,
    lifecycleStatus.statusData,
    // Keep statusData, so that the effect runs when it changes
    lifecycleStatus.statusName,
    // Keep statusName, so that the effect runs when it changes
    from,
    to,
    address,
    paymaster,
    sendAnalytics
  ]);
  useEffect(() => {
    if (!projectId) {
      console.error(
        "Project ID is required for this component, please set the projectId in the OnchainKitProvider"
      );
    }
  }, [projectId]);
  useEffect(() => {
    if (lifecycleStatus.statusName === "init" && hasHandledSuccess) {
      setHasHandledSuccess(false);
      resetInputs();
    }
  }, [hasHandledSuccess, lifecycleStatus.statusName, resetInputs]);
  useEffect(() => {
    if (lifecycleStatus.statusName === "transactionApproved" && lifecycleStatus.statusData.transactionType === "Batched") {
      awaitCallsStatus();
    }
  }, [
    awaitCallsStatus,
    lifecycleStatus,
    lifecycleStatus.statusData,
    lifecycleStatus.statusName
  ]);
  useEffect(() => {
    let timer;
    if (lifecycleStatus.statusName === "success" && hasHandledSuccess) {
      timer = setTimeout(() => {
        updateLifecycleStatus({
          statusName: "init",
          statusData: {
            isMissingRequiredField: true,
            maxSlippage: config.maxSlippage
          }
        });
      }, 3e3);
    }
    return () => {
      if (timer) {
        return clearTimeout(timer);
      }
    };
  }, [
    config.maxSlippage,
    hasHandledSuccess,
    lifecycleStatus.statusName,
    updateLifecycleStatus
  ]);
  const handleAmountChange = useCallback(
    async (amount) => {
      if (to.token === void 0 || fromETH.token === void 0 || fromUSDC.token === void 0) {
        updateLifecycleStatus({
          statusName: "amountChange",
          statusData: {
            amountETH: fromETH.amount,
            amountUSDC: fromUSDC.amount,
            amountTo: to.amount,
            tokenTo: to.token,
            isMissingRequiredField: true
          }
        });
        return;
      }
      if (amount === "" || amount === "." || Number.parseFloat(amount) === 0) {
        to.setAmount("");
        to.setAmountUSD("");
        fromETH.setAmountUSD("");
        fromUSDC.setAmountUSD("");
        from == null ? void 0 : from.setAmountUSD("");
        return;
      }
      fromETH.setLoading(true);
      fromUSDC.setLoading(true);
      from == null ? void 0 : from.setLoading(true);
      updateLifecycleStatus({
        statusName: "amountChange",
        statusData: {
          // when fetching quote, the previous
          // amount is irrelevant
          amountTo: amount,
          amountETH: "",
          amountUSDC: "",
          amountFrom: "",
          tokenFromETH: fromETH.token,
          tokenFromUSDC: fromUSDC.token,
          tokenFrom: from == null ? void 0 : from.token,
          tokenTo: to.token,
          // when fetching quote, the destination
          // amount is missing
          isMissingRequiredField: true
        }
      });
      try {
        const maxSlippage = lifecycleStatus.statusData.maxSlippage;
        const {
          response: responseETH,
          formattedFromAmount: formattedAmountETH
        } = await getBuyQuote({
          amount,
          from: fromETH.token,
          maxSlippage: String(maxSlippage),
          to: to.token,
          useAggregator,
          fromSwapUnit: fromETH
        });
        const {
          response: responseUSDC,
          formattedFromAmount: formattedAmountUSDC
        } = await getBuyQuote({
          amount,
          from: fromUSDC.token,
          maxSlippage: String(maxSlippage),
          to: to.token,
          useAggregator,
          fromSwapUnit: fromUSDC
        });
        const {
          response: responseFrom,
          formattedFromAmount: formattedAmountFrom
        } = await getBuyQuote({
          amount,
          from: from == null ? void 0 : from.token,
          maxSlippage: String(maxSlippage),
          to: to.token,
          useAggregator,
          fromSwapUnit: from
        });
        const { isValid } = validateQuote({
          to,
          responseETH,
          responseUSDC,
          responseFrom,
          updateLifecycleStatus
        });
        if (!isValid) {
          return;
        }
        updateLifecycleStatus({
          statusName: "amountChange",
          statusData: {
            amountETH: formattedAmountETH,
            amountUSDC: formattedAmountUSDC,
            amountFrom: formattedAmountFrom || "",
            amountTo: amount,
            tokenFromETH: fromETH.token,
            tokenFromUSDC: fromUSDC.token,
            tokenFrom: from == null ? void 0 : from.token,
            tokenTo: to.token,
            // if quote was fetched successfully, we
            // have all required fields
            isMissingRequiredField: !formattedAmountETH
          }
        });
      } catch (err) {
        sendAnalytics(BuyEvent.BuyFailure, {
          error: err instanceof Error ? err.message : String(err),
          metadata: { amount }
        });
        updateLifecycleStatus({
          statusName: "error",
          statusData: {
            code: "TmBPc02",
            // Transaction module BuyProvider component 01 error
            error: JSON.stringify(err),
            message: ""
          }
        });
      } finally {
        fromETH.setLoading(false);
        fromUSDC.setLoading(false);
        from == null ? void 0 : from.setLoading(false);
      }
    },
    [
      to,
      from,
      fromETH,
      fromUSDC,
      useAggregator,
      updateLifecycleStatus,
      lifecycleStatus.statusData.maxSlippage,
      sendAnalytics
    ]
  );
  const handleSubmit = useCallback(
    async (from2) => {
      if (!address || !from2.token || !to.token || !from2.amount) {
        return;
      }
      try {
        sendAnalytics(BuyEvent.BuyInitiated, {
          amount: Number(from2.amount),
          token: from2.token.symbol
        });
        const maxSlippage = lifecycleStatus.statusData.maxSlippage;
        const response = await buildSwapTransaction(
          {
            amount: from2.amount,
            fromAddress: address,
            from: from2.token,
            maxSlippage: String(maxSlippage),
            to: to.token,
            useAggregator
          },
          RequestContext.Buy
        );
        if (isSwapError(response)) {
          updateLifecycleStatus({
            statusName: "error",
            statusData: {
              code: response.code,
              error: response.error,
              message: response.message
            }
          });
          return;
        }
        await processSwapTransaction({
          chainId,
          config: accountConfig,
          isSponsored,
          paymaster: paymaster || "",
          sendCallsAsync,
          sendTransactionAsync,
          swapTransaction: response,
          switchChainAsync,
          updateLifecycleStatus,
          useAggregator,
          walletCapabilities
        });
      } catch (err) {
        sendAnalytics(BuyEvent.BuyFailure, {
          error: err instanceof Error ? err.message : String(err),
          metadata: {
            token: from2.token.symbol,
            amount: from2.amount
          }
        });
        const errorMessage = isUserRejectedRequestError(err) ? "Request denied." : GENERIC_ERROR_MESSAGE;
        updateLifecycleStatus({
          statusName: "error",
          statusData: {
            code: "TmBPc03",
            error: JSON.stringify(err),
            message: errorMessage
          }
        });
      }
    },
    [
      accountConfig,
      address,
      chainId,
      isSponsored,
      lifecycleStatus,
      paymaster,
      sendCallsAsync,
      sendTransactionAsync,
      switchChainAsync,
      to.token,
      updateLifecycleStatus,
      useAggregator,
      walletCapabilities,
      sendAnalytics
    ]
  );
  const value = useValue({
    address,
    config,
    disabled,
    from,
    fromETH,
    fromUSDC,
    handleAmountChange,
    handleSubmit,
    lifecycleStatus,
    updateLifecycleStatus,
    to,
    setTransactionHash,
    transactionHash,
    isDropdownOpen,
    setIsDropdownOpen,
    toToken,
    fromToken,
    startPopupMonitor
  });
  return /* @__PURE__ */ jsx(BuyContext.Provider, { value, children });
}
export {
  BuyContext,
  BuyProvider,
  useBuyContext
};
//# sourceMappingURL=BuyProvider.js.map
