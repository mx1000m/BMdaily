{"version":3,"file":"getBuyQuote.js","sources":["../../../src/buy/utils/getBuyQuote.ts"],"sourcesContent":["import { getSwapQuote } from '@/api/getSwapQuote';\nimport type { GetSwapQuoteParams, GetSwapQuoteResponse } from '@/api/types';\nimport { RequestContext } from '@/core/network/constants';\nimport { formatTokenAmount } from '@/internal/utils/formatTokenAmount';\nimport type { SwapError, SwapUnit } from '../../swap/types';\nimport { isSwapError } from '../../swap/utils/isSwapError';\nimport type { Token } from '../../token';\nimport type { GetBuyQuoteResponse } from '../types';\n\n/**\n * Parameters for getting a buy quote, extending GetSwapQuoteParams but omitting 'from'\n */\ntype GetBuyQuoteParams = Omit<GetSwapQuoteParams, 'from'> & {\n  /** Optional swap unit for the 'from' token */\n  fromSwapUnit?: SwapUnit;\n  /** Optional 'from' token */\n  from?: Token;\n};\n\n/**\n * Fetches a quote for a swap, but only if the from and to tokens are different.\n */\nexport async function getBuyQuote({\n  amount,\n  from,\n  maxSlippage,\n  to,\n  useAggregator,\n  fromSwapUnit,\n}: GetBuyQuoteParams): Promise<GetBuyQuoteResponse> {\n  // only fetch quote if the from token is provided\n  if (!from) {\n    return { response: undefined, formattedFromAmount: '', error: undefined };\n  }\n\n  let response: GetSwapQuoteResponse | undefined;\n  // only fetch quote if the from and to tokens are different\n  if (to?.symbol !== from?.symbol) {\n    // switching to and from here\n    // instead of getting a quote for how much of X do we need to sell to get the input token amount\n    // we can get a quote for how much of X we will receive if we sell the input token amount\n    response = await getSwapQuote(\n      {\n        amount,\n        amountReference: 'from',\n        from: to,\n        maxSlippage,\n        to: from,\n        useAggregator,\n      },\n      RequestContext.Buy,\n    );\n  }\n\n  let formattedFromAmount = '';\n  if (response && !isSwapError(response)) {\n    formattedFromAmount = response?.toAmount\n      ? formatTokenAmount(response.toAmount, response.to.decimals)\n      : '';\n\n    fromSwapUnit?.setAmountUSD(response?.toAmountUSD || '');\n    fromSwapUnit?.setAmount(formattedFromAmount || '');\n  }\n\n  let error: SwapError | undefined;\n  if (isSwapError(response)) {\n    error = response;\n    response = undefined;\n  }\n\n  return { response, formattedFromAmount, error };\n}\n"],"names":[],"mappings":";;;;AAsBA,eAAsB,YAAY;AAAA,EAChC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAoD;AAElD,MAAI,CAAC,MAAM;AACT,WAAO,EAAE,UAAU,QAAW,qBAAqB,IAAI,OAAO,OAAU;AAAA,EAAA;AAGtE,MAAA;AAEA,OAAA,yBAAI,aAAW,6BAAM,SAAQ;AAI/B,eAAW,MAAM;AAAA,MACf;AAAA,QACE;AAAA,QACA,iBAAiB;AAAA,QACjB,MAAM;AAAA,QACN;AAAA,QACA,IAAI;AAAA,QACJ;AAAA,MACF;AAAA,MACA,eAAe;AAAA,IACjB;AAAA,EAAA;AAGF,MAAI,sBAAsB;AAC1B,MAAI,YAAY,CAAC,YAAY,QAAQ,GAAG;AAChB,2BAAA,qCAAU,YAC5B,kBAAkB,SAAS,UAAU,SAAS,GAAG,QAAQ,IACzD;AAEU,iDAAA,cAAa,qCAAU,gBAAe;AACtC,iDAAA,UAAU,uBAAuB;AAAA,EAAE;AAG/C,MAAA;AACA,MAAA,YAAY,QAAQ,GAAG;AACjB,YAAA;AACG,eAAA;AAAA,EAAA;AAGN,SAAA,EAAE,UAAU,qBAAqB,MAAM;AAChD;"}