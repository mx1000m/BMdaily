'use client';
import { jsx } from "react/jsx-runtime";
import { cn } from "../../../styles/theme.js";
import { useState, useRef, useCallback, useEffect } from "react";
import { getBoundedPosition } from "./getBoundedPosition.js";
import { useRespositionOnWindowResize } from "./useRepositionOnResize.js";
function Draggable({
  children,
  gridSize = 1,
  startingPosition = { x: 20, y: 20 },
  snapToGrid = false,
  disabled = false
}) {
  const [position, setPosition] = useState(startingPosition);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [dragStartPosition, setDragStartPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const draggableRef = useRef(null);
  const calculateSnapToGrid = useCallback(
    (positionValue) => {
      return Math.round(positionValue / gridSize) * gridSize;
    },
    [gridSize]
  );
  const handleDragStart = useCallback(
    (e) => {
      if (disabled) {
        return;
      }
      setIsDragging(true);
      setDragStartPosition({ x: e.clientX, y: e.clientY });
      setDragOffset({
        x: e.clientX - position.x,
        y: e.clientY - position.y
      });
    },
    [position, disabled]
  );
  useEffect(() => {
    if (!isDragging) {
      return;
    }
    const handleGlobalMove = (e) => {
      const newPosition = getBoundedPosition({
        draggableRef,
        position: {
          x: e.clientX - dragOffset.x,
          y: e.clientY - dragOffset.y
        }
      });
      setPosition(newPosition);
    };
    const handleGlobalEnd = (e) => {
      const moveDistance = Math.hypot(
        e.clientX - dragStartPosition.x,
        e.clientY - dragStartPosition.y
      );
      if (moveDistance > 2) {
        e.preventDefault();
        e.stopPropagation();
        const clickEvent = (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          document.removeEventListener("click", clickEvent, true);
        };
        document.addEventListener("click", clickEvent, true);
      }
      setPosition((prev) => ({
        x: snapToGrid ? calculateSnapToGrid(prev.x) : prev.x,
        y: snapToGrid ? calculateSnapToGrid(prev.y) : prev.y
      }));
      setIsDragging(false);
    };
    document.addEventListener("pointermove", handleGlobalMove);
    document.addEventListener("pointerup", handleGlobalEnd);
    return () => {
      document.removeEventListener("pointermove", handleGlobalMove);
      document.removeEventListener("pointerup", handleGlobalEnd);
    };
  }, [
    isDragging,
    dragOffset,
    snapToGrid,
    calculateSnapToGrid,
    dragStartPosition
  ]);
  useRespositionOnWindowResize(draggableRef, position, setPosition);
  return /* @__PURE__ */ jsx(
    "div",
    {
      ref: draggableRef,
      "data-testid": "ockDraggable",
      className: cn(
        "fixed touch-none select-none",
        "cursor-grab active:cursor-grabbing"
      ),
      style: {
        left: `${position.x}px`,
        top: `${position.y}px`
      },
      onPointerDown: handleDragStart,
      children
    }
  );
}
export {
  Draggable
};
//# sourceMappingURL=Draggable.js.map
