import { jsx } from "react/jsx-runtime";
import { createContext, useContext, useState, useMemo, useCallback, useEffect } from "react";
import { useAccount, useConfig, useSwitchChain, useWaitForTransactionReceipt } from "wagmi";
import { waitForTransactionReceipt } from "wagmi/actions";
import { useAnalytics } from "../../core/analytics/hooks/useAnalytics.js";
import { TransactionEvent } from "../../core/analytics/types.js";
import { Capabilities } from "../../core/constants.js";
import { useCapabilitiesSafe } from "../../internal/hooks/useCapabilitiesSafe.js";
import { useValue } from "../../internal/hooks/useValue.js";
import { useOnchainKit } from "../../useOnchainKit.js";
import { GENERIC_ERROR_MESSAGE } from "../constants.js";
import { useCallsStatus } from "../hooks/useCallsStatus.js";
import { useSendCall } from "../hooks/useSendCall.js";
import { useSendCalls } from "../hooks/useSendCalls.js";
import { useSendWalletTransactions } from "../hooks/useSendWalletTransactions.js";
import { getPaymasterUrl } from "../utils/getPaymasterUrl.js";
import { isUserRejectedRequestError } from "../utils/isUserRejectedRequestError.js";
const emptyContext = {};
const TransactionContext = createContext(emptyContext);
function useTransactionContext() {
  const context = useContext(TransactionContext);
  if (context === emptyContext) {
    throw new Error(
      "useTransactionContext must be used within a Transaction component"
    );
  }
  return context;
}
function TransactionProvider({
  calls,
  capabilities: transactionCapabilities,
  chainId,
  children,
  contracts,
  isSponsored,
  onError,
  onStatus,
  onSuccess,
  resetAfter
}) {
  const account = useAccount();
  const config = useConfig();
  const { config: { paymaster } = { paymaster: void 0 } } = useOnchainKit();
  const [errorMessage, setErrorMessage] = useState("");
  const [errorCode, setErrorCode] = useState("");
  const [isToastVisible, setIsToastVisible] = useState(false);
  const [lifecycleStatus, setLifecycleStatus] = useState({
    statusName: "init",
    statusData: null
  });
  const [transactionId, setTransactionId] = useState("");
  const [transactionCount, setTransactionCount] = useState();
  const [transactionHashList, setTransactionHashList] = useState([]);
  const transactions = calls || contracts;
  const walletCapabilities = useCapabilitiesSafe({
    chainId
  });
  const { switchChainAsync } = useSwitchChain();
  if (!contracts && !calls) {
    throw new Error(
      "Transaction: calls or contracts must be provided as a prop to the Transaction component."
    );
  }
  if (calls && contracts) {
    throw new Error(
      "Transaction: Only one of contracts or calls can be provided as a prop to the Transaction component."
    );
  }
  const {
    status: statusSendCalls,
    sendCallsAsync,
    reset: resetSendCalls
  } = useSendCalls({
    setLifecycleStatus,
    setTransactionId
  });
  const {
    status: statusSendCall,
    sendCallAsync,
    data: singleTransactionHash,
    reset: resetSendCall
  } = useSendCall({
    setLifecycleStatus,
    transactionHashList
  });
  const transactionStatus = useMemo(() => {
    var _a;
    if ((_a = walletCapabilities[Capabilities.AtomicBatch]) == null ? void 0 : _a.supported) {
      return statusSendCalls;
    }
    return statusSendCall;
  }, [statusSendCall, statusSendCalls, walletCapabilities]);
  const capabilities = useMemo(() => {
    if (isSponsored && paymaster) {
      return {
        paymasterService: { url: paymaster },
        // this needs to be below so devs can override default paymaster
        // with their personal paymaster in production playgroundd
        ...transactionCapabilities
      };
    }
    return transactionCapabilities;
  }, [isSponsored, paymaster, transactionCapabilities]);
  const sendWalletTransactions = useSendWalletTransactions({
    capabilities,
    sendCallAsync,
    sendCallsAsync,
    walletCapabilities
  });
  const { transactionHash: batchedTransactionHash, status: callStatus } = useCallsStatus({
    setLifecycleStatus,
    transactionId
  });
  const { data: receipt } = useWaitForTransactionReceipt({
    hash: singleTransactionHash || batchedTransactionHash
  });
  const { sendAnalytics } = useAnalytics();
  const handleAnalytics = useCallback(
    (event, data) => {
      sendAnalytics(event, data);
    },
    [sendAnalytics]
  );
  useEffect(() => {
    setErrorMessage("");
    if (lifecycleStatus.statusName === "error") {
      setErrorMessage(lifecycleStatus.statusData.message);
      setErrorCode(lifecycleStatus.statusData.code);
      onError == null ? void 0 : onError(lifecycleStatus.statusData);
    }
    if (lifecycleStatus.statusName === "transactionLegacyExecuted") {
      setTransactionHashList(lifecycleStatus.statusData.transactionHashList);
    }
    if (lifecycleStatus.statusName === "success") {
      onSuccess == null ? void 0 : onSuccess({
        transactionReceipts: lifecycleStatus.statusData.transactionReceipts
      });
    }
    onStatus == null ? void 0 : onStatus(lifecycleStatus);
  }, [
    onError,
    onStatus,
    onSuccess,
    lifecycleStatus,
    lifecycleStatus.statusData,
    // Keep statusData, so that the effect runs when it changes
    lifecycleStatus.statusName
    // Keep statusName, so that the effect runs when it changes
  ]);
  useEffect(() => {
    if (transactionStatus === "pending") {
      setLifecycleStatus({
        statusName: "transactionPending",
        statusData: null
      });
    }
  }, [transactionStatus]);
  useEffect(() => {
    if (!receipt) {
      return;
    }
    setLifecycleStatus({
      statusName: "success",
      statusData: {
        transactionReceipts: [receipt]
      }
    });
    if (resetAfter) {
      const timeoutId = setTimeout(() => {
        setErrorMessage("");
        setErrorCode("");
        setIsToastVisible(false);
        setTransactionId("");
        setTransactionHashList([]);
        setTransactionCount(void 0);
        resetSendCalls();
        resetSendCall();
      }, resetAfter);
      return () => clearTimeout(timeoutId);
    }
  }, [receipt, resetAfter, resetSendCalls, resetSendCall]);
  const getTransactionLegacyReceipts = useCallback(async () => {
    const receipts = [];
    for (const hash of transactionHashList) {
      try {
        const txnReceipt = await waitForTransactionReceipt(config, {
          hash,
          chainId
        });
        receipts.push(txnReceipt);
      } catch (err) {
        setLifecycleStatus({
          statusName: "error",
          statusData: {
            code: "TmTPc01",
            // Transaction module TransactionProvider component 01 error
            error: JSON.stringify(err),
            message: GENERIC_ERROR_MESSAGE
          }
        });
      }
    }
    setLifecycleStatus({
      statusName: "success",
      statusData: {
        transactionReceipts: receipts
      }
    });
  }, [chainId, config, transactionHashList]);
  useEffect(() => {
    if (!transactions || transactionHashList.length !== transactionCount || transactionCount < 2) {
      return;
    }
    getTransactionLegacyReceipts();
  }, [
    transactions,
    transactionCount,
    transactionHashList,
    getTransactionLegacyReceipts
  ]);
  const switchChain = useCallback(
    async (targetChainId) => {
      if (targetChainId && account.chainId !== targetChainId) {
        await switchChainAsync({ chainId: targetChainId });
      }
    },
    [account.chainId, switchChainAsync]
  );
  const buildTransaction = useCallback(async () => {
    setLifecycleStatus({
      statusName: "buildingTransaction",
      statusData: null
    });
    try {
      handleAnalytics(TransactionEvent.TransactionInitiated, {
        address: account.address
      });
      const resolvedTransactions = await (typeof transactions === "function" ? transactions() : Promise.resolve(transactions));
      setTransactionCount(resolvedTransactions == null ? void 0 : resolvedTransactions.length);
      return resolvedTransactions;
    } catch (err) {
      handleAnalytics(TransactionEvent.TransactionFailure, {
        error: err.message,
        metadata: {
          code: errorCode
        }
      });
      setLifecycleStatus({
        statusName: "error",
        statusData: {
          code: "TmTPc04",
          // Transaction module TransactionProvider component 04 error
          error: JSON.stringify(err),
          message: "Error building transactions"
        }
      });
      return void 0;
    }
  }, [transactions, handleAnalytics, account.address, errorCode]);
  const handleSubmit = useCallback(async () => {
    setErrorMessage("");
    setIsToastVisible(true);
    try {
      await switchChain(chainId);
      const resolvedTransactions = await buildTransaction();
      await sendWalletTransactions(resolvedTransactions);
    } catch (err) {
      const errorMessage2 = isUserRejectedRequestError(err) ? "Request denied." : GENERIC_ERROR_MESSAGE;
      setLifecycleStatus({
        statusName: "error",
        statusData: {
          code: "TmTPc03",
          // Transaction module TransactionProvider component 03 error
          error: JSON.stringify(err),
          message: errorMessage2
        }
      });
    }
  }, [buildTransaction, chainId, sendWalletTransactions, switchChain]);
  const value = useValue({
    chainId,
    errorCode,
    errorMessage,
    isLoading: callStatus === "PENDING",
    isToastVisible,
    lifecycleStatus,
    onSubmit: handleSubmit,
    paymasterUrl: getPaymasterUrl(capabilities),
    receipt,
    setIsToastVisible,
    setLifecycleStatus,
    setTransactionId,
    transactions,
    transactionId,
    transactionHash: singleTransactionHash || batchedTransactionHash,
    transactionCount
  });
  useEffect(() => {
    if (!receipt) {
      return;
    }
    if (receipt.status === "success") {
      handleAnalytics(TransactionEvent.TransactionSuccess, {
        paymaster: Boolean(isSponsored && paymaster),
        address: account.address,
        transactionHash: receipt.transactionHash
      });
    } else {
      handleAnalytics(TransactionEvent.TransactionFailure, {
        error: "Transaction failed",
        metadata: {
          code: errorCode
        }
      });
    }
  }, [
    receipt,
    handleAnalytics,
    isSponsored,
    paymaster,
    account.address,
    errorCode
  ]);
  return /* @__PURE__ */ jsx(TransactionContext.Provider, { value, children });
}
export {
  TransactionContext,
  TransactionProvider,
  useTransactionContext
};
//# sourceMappingURL=TransactionProvider.js.map
