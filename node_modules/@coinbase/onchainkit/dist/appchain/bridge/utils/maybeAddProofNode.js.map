{"version":3,"file":"maybeAddProofNode.js","sources":["../../../../src/appchain/bridge/utils/maybeAddProofNode.ts"],"sourcesContent":["import { type Hex, fromRlp, toRlp } from 'viem';\n\n/* v8 ignore start */\nexport function maybeAddProofNode(key: string, proof: readonly Hex[]) {\n  const lastProofRlp = proof[proof.length - 1];\n  const lastProof = fromRlp(lastProofRlp);\n  if (lastProof.length !== 17) {\n    return proof;\n  }\n\n  const modifiedProof = [...proof];\n  for (const item of lastProof) {\n    // Find any nodes located inside of the branch node.\n    if (!Array.isArray(item)) {\n      continue;\n    }\n    // Check if the key inside the node matches the key we're looking for. We remove the first\n    // two characters (0x) and then we remove one more character (the first nibble) since this\n    // is the identifier for the type of node we're looking at. In this case we don't actually\n    // care what type of node it is because a branch node would only ever be the final proof\n    // element if (1) it includes the leaf node we're looking for or (2) it stores the value\n    // within itself. If (1) then this logic will work, if (2) then this won't find anything\n    // and we won't append any proof elements, which is exactly what we would want.\n    const suffix = item[0].slice(3);\n    if (typeof suffix !== 'string' || !key.endsWith(suffix)) {\n      continue;\n    }\n    modifiedProof.push(toRlp(item));\n  }\n  return modifiedProof;\n}\n/* v8 ignore stop */\n"],"names":[],"mappings":";AAGgB,SAAA,kBAAkB,KAAa,OAAuB;AACpE,QAAM,eAAe,MAAM,MAAM,SAAS,CAAC;AACrC,QAAA,YAAY,QAAQ,YAAY;AAClC,MAAA,UAAU,WAAW,IAAI;AACpB,WAAA;AAAA,EAAA;AAGH,QAAA,gBAAgB,CAAC,GAAG,KAAK;AAC/B,aAAW,QAAQ,WAAW;AAE5B,QAAI,CAAC,MAAM,QAAQ,IAAI,GAAG;AACxB;AAAA,IAAA;AASF,UAAM,SAAS,KAAK,CAAC,EAAE,MAAM,CAAC;AAC9B,QAAI,OAAO,WAAW,YAAY,CAAC,IAAI,SAAS,MAAM,GAAG;AACvD;AAAA,IAAA;AAEY,kBAAA,KAAK,MAAM,IAAI,CAAC;AAAA,EAAA;AAEzB,SAAA;AACT;"}