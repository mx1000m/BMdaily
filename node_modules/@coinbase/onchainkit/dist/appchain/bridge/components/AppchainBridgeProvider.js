'use client';
import { jsx } from "react/jsx-runtime";
import { getChainExplorer } from "../../../core/network/getChainExplorer.js";
import { useValue } from "../../../internal/hooks/useValue.js";
import { baseSvg } from "../../../internal/svg/baseSvg.js";
import { coinbaseLogoSvg } from "../../../internal/svg/coinbaseLogoSvg.js";
import { toReadableAmount } from "../../../swap/utils/toReadableAmount.js";
import { createContext, useState, useEffect, useCallback, useContext } from "react";
import { erc20Abi } from "viem";
import { useAccount, useConfig } from "wagmi";
import { getBalance, readContract } from "wagmi/actions";
import { DEFAULT_BRIDGEABLE_TOKENS } from "../constants.js";
import { useChainConfig } from "../hooks/useAppchainConfig.js";
import { useDeposit } from "../hooks/useDeposit.js";
import { useWithdraw } from "../hooks/useWithdraw.js";
import { defaultPriceFetcher } from "../utils/defaultPriceFetcher.js";
const AppchainBridgeContext = createContext(void 0);
const AppchainBridgeProvider = ({
  children,
  chain,
  appchain,
  bridgeableTokens = DEFAULT_BRIDGEABLE_TOKENS,
  handleFetchPrice = defaultPriceFetcher
}) => {
  const [from, setFrom] = useState({
    ...chain,
    icon: baseSvg
  });
  const [to, setTo] = useState({
    ...appchain.chain,
    icon: appchain.icon || coinbaseLogoSvg
  });
  const { config, error } = useChainConfig({
    l2ChainId: chain.id,
    appchainChainId: appchain.chain.id
  });
  if (error) {
    console.error(error);
    throw new Error(
      "Error loading chain configuration. Ensure you have the correct chain ID."
    );
  }
  if (bridgeableTokens.length === 0) {
    throw new Error(
      "Bridgeable tokens must be provided as a parameter to AppchainBridge."
    );
  }
  if (!config) {
    return null;
  }
  const { address } = useAccount();
  const wagmiConfig = useConfig();
  const [bridgeParams, setBridgeParams] = useState({
    amount: "",
    amountUSD: "0.00",
    token: bridgeableTokens[0],
    recipient: address
  });
  const [isPriceLoading, setIsPriceLoading] = useState(false);
  const [isAddressModalOpen, setIsAddressModalOpen] = useState(false);
  const [isWithdrawModalOpen, setIsWithdrawModalOpen] = useState(false);
  const [isSuccessModalOpen, setIsSuccessModalOpen] = useState(false);
  const [isResumeTransactionModalOpen, setIsResumeTransactionModalOpen] = useState(false);
  const direction = from.id === chain.id ? "deposit" : "withdraw";
  const [balance, setBalance] = useState("");
  const [resumeWithdrawalTxHash, setResumeWithdrawalTxHash] = useState();
  const {
    deposit,
    depositStatus,
    transactionHash: depositTransactionHash,
    resetDepositStatus
  } = useDeposit();
  const {
    withdraw,
    withdrawStatus,
    waitForWithdrawal,
    proveAndFinalizeWithdrawal,
    finalizedWithdrawalTxHash,
    resetWithdrawStatus
  } = useWithdraw({
    config,
    chain,
    bridgeParams
  });
  useEffect(() => {
    setBridgeParams((prev) => ({
      ...prev,
      recipient: address
    }));
  }, [address]);
  const fetchBalance = useCallback(async () => {
    if (!address) {
      return;
    }
    const tokenAddress = direction === "deposit" ? bridgeParams.token.address : bridgeParams.token.remoteToken;
    let _balance;
    if (!tokenAddress || /* v8 ignore next 1 */
    direction === "withdraw" && bridgeParams.token.isCustomGasToken) {
      const ethBalance = await getBalance(wagmiConfig, {
        address,
        chainId: from.id
      });
      _balance = toReadableAmount(
        ethBalance.value.toString(),
        ethBalance.decimals
      );
    } else {
      const erc20Balance = await readContract(wagmiConfig, {
        abi: erc20Abi,
        functionName: "balanceOf",
        args: [address],
        address: tokenAddress,
        chainId: from.id
      });
      _balance = toReadableAmount(
        erc20Balance.toString(),
        bridgeParams.token.decimals
      );
    }
    setBalance(_balance);
  }, [address, direction, bridgeParams.token, from.id, wagmiConfig]);
  useEffect(() => {
    fetchBalance();
  }, [fetchBalance]);
  useEffect(() => {
    if (withdrawStatus === "claimSuccess" || depositStatus === "depositSuccess") {
      fetchBalance();
    }
  }, [withdrawStatus, depositStatus, fetchBalance]);
  const handleToggle = useCallback(() => {
    const tmp = from;
    setFrom(to);
    setTo(tmp);
    resetDepositStatus();
    resetWithdrawStatus();
  }, [from, to, resetDepositStatus, resetWithdrawStatus]);
  const handleAmountChange = useCallback(
    async ({
      amount,
      token,
      remoteToken
    }) => {
      setIsPriceLoading(true);
      setBridgeParams((prev) => ({
        ...prev,
        amount,
        token,
        remoteToken
      }));
      const amountUSD = await handleFetchPrice(amount, token);
      setBridgeParams((prev) => ({
        ...prev,
        amountUSD
      }));
      setIsPriceLoading(false);
    },
    [handleFetchPrice]
  );
  const handleAddressSelect = useCallback((address2) => {
    setBridgeParams((prev) => ({
      ...prev,
      recipient: address2
    }));
  }, []);
  const handleResumeTransaction = useCallback((txHash) => {
    setResumeWithdrawalTxHash(txHash);
    setIsResumeTransactionModalOpen(false);
  }, []);
  const handleOpenExplorer = useCallback(() => {
    const blockExplorerUrl = getChainExplorer(chain.id);
    const txHash = depositStatus === "depositSuccess" ? depositTransactionHash : finalizedWithdrawalTxHash;
    window.open(`${blockExplorerUrl}/tx/${txHash}`, "_blank");
  }, [
    chain.id,
    depositStatus,
    depositTransactionHash,
    finalizedWithdrawalTxHash
  ]);
  const handleDeposit = useCallback(async () => {
    await deposit({
      config,
      from,
      bridgeParams
    });
  }, [deposit, config, from, bridgeParams]);
  const handleWithdraw = useCallback(async () => {
    await withdraw();
  }, [withdraw]);
  const handleResetState = useCallback(() => {
    setIsSuccessModalOpen(false);
    setIsWithdrawModalOpen(false);
    setIsResumeTransactionModalOpen(false);
    setResumeWithdrawalTxHash(void 0);
  }, []);
  useEffect(() => {
    if (withdrawStatus === "withdrawSuccess" || resumeWithdrawalTxHash) {
      setIsWithdrawModalOpen(true);
    }
  }, [withdrawStatus, resumeWithdrawalTxHash]);
  useEffect(() => {
    if (!isWithdrawModalOpen) {
      resetWithdrawStatus();
    }
  }, [isWithdrawModalOpen, resetWithdrawStatus]);
  useEffect(() => {
    if (depositStatus === "depositSuccess") {
      setIsSuccessModalOpen(true);
    }
  }, [depositStatus]);
  useEffect(() => {
    if (withdrawStatus === "claimSuccess") {
      setIsSuccessModalOpen(true);
    }
  }, [withdrawStatus]);
  const value = useValue({
    // Internal
    config,
    from,
    to,
    bridgeableTokens,
    bridgeParams,
    isPriceLoading,
    // Bridge UI
    balance,
    handleToggle,
    handleAmountChange,
    // Address modal
    isAddressModalOpen,
    setIsAddressModalOpen,
    handleAddressSelect,
    // Success modal
    isSuccessModalOpen,
    setIsSuccessModalOpen,
    handleOpenExplorer,
    handleResetState,
    // Resume transaction modal
    isResumeTransactionModalOpen,
    setIsResumeTransactionModalOpen,
    resumeWithdrawalTxHash,
    setResumeWithdrawalTxHash,
    handleResumeTransaction,
    // Deposits and Withdrawals
    handleDeposit,
    depositStatus,
    depositTransactionHash,
    direction,
    handleWithdraw,
    withdrawStatus,
    waitForWithdrawal,
    proveAndFinalizeWithdrawal,
    finalizedWithdrawalTxHash,
    isWithdrawModalOpen,
    setIsWithdrawModalOpen,
    resetDepositStatus,
    resetWithdrawStatus
  });
  return /* @__PURE__ */ jsx(AppchainBridgeContext.Provider, { value, children });
};
const useAppchainBridgeContext = () => {
  const context = useContext(AppchainBridgeContext);
  if (context === void 0) {
    throw new Error("useAppchainBridge must be used within a BridgeProvider");
  }
  return context;
};
export {
  AppchainBridgeProvider,
  useAppchainBridgeContext
};
//# sourceMappingURL=AppchainBridgeProvider.js.map
